Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: .cvsignore
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: Makefile.am
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: TODO
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: admin.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: admin.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: admin_var.h
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/algorithm.c ./algorithm.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/algorithm.c	Mon Jun 20 03:02:54 2005
+++ ./algorithm.c	Thu Feb  2 17:05:27 2006
@@ -35,18 +35,20 @@
 #include <sys/types.h>
 #include <stdlib.h>
 
+#include "racoon.h"
+
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 #include "debug.h"
 
-#include "crypto_openssl.h"
+#include "crypto_impl.h"
 #include "dhgroup.h"
 #include "algorithm.h"
 #include "oakley.h"
-#include "isakmp_var.h"
 #include "isakmp.h"
+#include "isakmp_var.h"
 #include "ipsec_doi.h"
 #include "gcmalloc.h"
 
@@ -291,7 +293,7 @@
 
 	for (i = 0; i < ARRAYLEN(oakley_hashdef); i++)
 		if (doi == oakley_hashdef[i].doi) {
-			plog(LLV_DEBUG, LOCATION, NULL, "hash(%s)\n",
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "hash(%s)\n",
 				oakley_hashdef[i].name);
 			return &oakley_hashdef[i];
 		}
@@ -374,7 +376,7 @@
 
 	for (i = 0; i < ARRAYLEN(oakley_hmacdef); i++)
 		if (doi == oakley_hmacdef[i].doi) {
-			plog(LLV_DEBUG, LOCATION, NULL, "hmac(%s)\n",
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "hmac(%s)\n",
 				oakley_hmacdef[i].name);
 			return &oakley_hmacdef[i];
 		}
@@ -434,7 +436,7 @@
 
 	for (i = 0; i < ARRAYLEN(oakley_encdef); i++)
 		if (doi == oakley_encdef[i].doi) {
-			plog(LLV_DEBUG, LOCATION, NULL, "encryption(%s)\n",
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "encryption(%s)\n",
 				oakley_encdef[i].name);
 			return &oakley_encdef[i];
 		}
@@ -574,7 +576,7 @@
 
 	for (i = 0; i < ARRAYLEN(ipsec_encdef); i++)
 		if (doi == ipsec_encdef[i].doi) {
-			plog(LLV_DEBUG, LOCATION, NULL, "encryption(%s)\n",
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "encryption(%s)\n",
 				ipsec_encdef[i].name);
 			return &ipsec_encdef[i];
 		}
@@ -617,7 +619,7 @@
 
 	for (i = 0; i < ARRAYLEN(ipsec_hmacdef); i++)
 		if (doi == ipsec_hmacdef[i].doi) {
-			plog(LLV_DEBUG, LOCATION, NULL, "hmac(%s)\n",
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "hmac(%s)\n",
 				oakley_hmacdef[i].name);
 			return &ipsec_hmacdef[i];
 		}
@@ -675,7 +677,7 @@
 
 	for (i = 0; i < ARRAYLEN(oakley_dhdef); i++)
 		if (doi == oakley_dhdef[i].doi) {
-			plog(LLV_DEBUG, LOCATION, NULL, "hmac(%s)\n",
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "hmac(%s)\n",
 				oakley_dhdef[i].name);
 			return &oakley_dhdef[i];
 		}
@@ -810,7 +812,7 @@
 		break;
 	default:
 		/* unknown class, punt */
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"unknown algclass %d\n", class);
 		return -1;
 	}
@@ -823,7 +825,7 @@
 	case algtype_aes:
 	case algtype_twofish:
 		if (len % 8 != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"key length %d is not multiple of 8\n", len);
 			return -1;
 		}
@@ -855,14 +857,14 @@
 		break;
 	default:
 		if (len) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"key length is not allowed");
 			return -1;
 		}
 		break;
 	}
 	if (badrange) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"key length out of range\n");
 		return -1;
 	}
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: backupsa.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: backupsa.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: cfparse.y
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: cfparse_proto.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: cftoken.l
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: cftoken_proto.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: contrib
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: crypto_openssl.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: crypto_openssl.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: debug.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: debugrm.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: debugrm.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: dhgroup.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: diff.kame
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: dnssec.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: dnssec.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: doc
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: dump.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: dump.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: eaytest.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: evt.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: gcmalloc.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: getcertsbyname.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: grabmyaddr.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: grabmyaddr.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: gssapi.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: gssapi.h
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/handler.c ./handler.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/handler.c	Sat Aug 20 20:32:47 2005
+++ ./handler.c	Thu Feb  2 17:03:01 2006
@@ -42,7 +42,7 @@
 #include <errno.h>
 
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 #include "sockmisc.h"
@@ -52,29 +52,33 @@
 #include <resolv.h>
 #endif
 
-#include "schedule.h"
-#include "grabmyaddr.h"
+/* #include "schedule.h" */
+/* #include "grabmyaddr.h" */
 #include "algorithm.h"
 #include "crypto_openssl.h"
-#include "policy.h"
+/* #include "policy.h" */
 #include "proposal.h"
+#include "isakmp.h"
 #include "isakmp_var.h"
 #include "evt.h"
-#include "isakmp.h"
 #ifdef ENABLE_HYBRID
 #include "isakmp_xauth.h"  
 #include "isakmp_cfg.h"
 #endif
 #include "isakmp_inf.h"
 #include "oakley.h"
+#include "isakmp_impl.h"
 #include "remoteconf.h"
-#include "localconf.h"
+/* #include "localconf.h" */
 #include "handler.h"
 #include "gcmalloc.h"
-#include "nattraversal.h"
+/* #include "nattraversal.h" */
 
 #include "sainfo.h"
 
+#include "racoon.h"
+#include "crypto_impl.h"
+
 #ifdef HAVE_GSSAPI
 #include "gssapi.h"
 #endif
@@ -100,7 +104,7 @@
 
 struct ph1handle *
 getph1byindex(index)
-	isakmp_index *index;
+	isakmp_index_t *index;
 {
 	struct ph1handle *p;
 
@@ -120,14 +124,14 @@
  */
 struct ph1handle *
 getph1byindex0(index)
-	isakmp_index *index;
+	isakmp_index_t *index;
 {
 	struct ph1handle *p;
 
 	LIST_FOREACH(p, &ph1tree, chain) {
 		if (p->status == PHASE1ST_EXPIRED)
 			continue;
-		if (memcmp(&p->index, index, sizeof(cookie_t)) == 0)
+		if (memcmp(&p->index, index, sizeof(isakmp_cookie_t)) == 0)
 			return p;
 	}
 
@@ -165,8 +169,8 @@
 	LIST_FOREACH(p, &ph1tree, chain) {
 		if (p->status == PHASE1ST_EXPIRED)
 			continue;
-		if (cmpsaddrwop(local, p->local) == 0
-		 && cmpsaddrwop(remote, p->remote) == 0)
+		if (rcs_cmpsa_wop(local, p->local) == 0
+		 && rcs_cmpsa_wop(remote, p->remote) == 0)
 			return p;
 	}
 
@@ -187,7 +191,7 @@
 	LIST_FOREACH(p, &ph1tree, chain) {
 		if (p->status == PHASE1ST_EXPIRED)
 			continue;
-		if (cmpsaddrwop(remote, p->remote) == 0)
+		if (rcs_cmpsa_wop(remote, p->remote) == 0)
 			return p;
 	}
 
@@ -211,7 +215,7 @@
 
 	buf = vmalloc(cnt * sizeof(struct ph1dump));
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer\n");
 		return NULL;
 	}
@@ -370,7 +374,7 @@
 {
 	/* validity check */
 	if (iph1->remote == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"invalid isakmp SA handler. no remote address.\n");
 		return -1;
 	}
@@ -413,6 +417,7 @@
 }
 
 /* %%% management phase 2 handler */
+#if 0
 /*
  * search ph2handle with policy id.
  */
@@ -433,6 +438,7 @@
 
 	return NULL;
 }
+#endif
 
 /*
  * search ph2handle with sequence number.
@@ -470,14 +476,14 @@
 }
 
 struct ph2handle *
-getph2byid(src, dst, spid)
+getph2byselector(src, dst, selector)
 	struct sockaddr *src, *dst;
-	u_int32_t spid;
+	struct rcf_policy *selector;
 {
 	struct ph2handle *p;
 
 	LIST_FOREACH(p, &ph2tree, chain) {
-		if (spid == p->spid &&
+		if (p->selector == selector &&
 		    CMPSADDR(src, p->src) == 0 &&
 		    CMPSADDR(dst, p->dst) == 0)
 			return p;
@@ -493,8 +499,8 @@
 	struct ph2handle *p;
 
 	LIST_FOREACH(p, &ph2tree, chain) {
-		if (cmpsaddrstrict(src, p->src) == 0 &&
-		    cmpsaddrstrict(dst, p->dst) == 0)
+		if (rcs_cmpsa(src, p->src) == 0 &&
+		    rcs_cmpsa(dst, p->dst) == 0)
 			return p;
 	}
 
@@ -761,7 +767,7 @@
 	struct contacted *p;
 
 	LIST_FOREACH(p, &ctdtree, chain) {
-		if (cmpsaddrstrict(remote, p->remote) == 0)
+		if (rcs_cmpsa(remote, p->remote) == 0)
 			return p;
 	}
 
@@ -782,7 +788,7 @@
 	if (new == NULL)
 		return -1;
 
-	new->remote = dupsaddr(remote);
+	new->remote = rcs_sadup(remote);
 
 	LIST_INSERT_HEAD(&ctdtree, new, chain);
 
@@ -819,7 +825,7 @@
 
 	hash = eay_md5_one(rbuf);
 	if (!hash) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate buffer.\n");
 		return -1;
 	}
@@ -837,7 +843,7 @@
 	/*
 	 * the packet was processed before, but the remote address mismatches.
 	 */
-	if (cmpsaddrstrict(remote, r->remote) != 0)
+	if (rcs_cmpsa(remote, r->remote) != 0)
 		return 2;
 
 	/*
@@ -847,9 +853,9 @@
 
 	/* check the previous time to send */
 	if (t - r->time_send < 1) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"the packet retransmitted in a short time from %s\n",
-			saddr2str(remote));
+		     rcs_sa2str(remote));
 		/*XXX should it be error ? */
 	}
 
@@ -860,9 +866,9 @@
 
 	/* resend the packet if needed */
 	len = sendfromto(s, r->sendbuf->v, r->sendbuf->l,
-			r->local, r->remote, lcconf->count_persend);
+			 r->local, r->remote, 1 /* lcconf->count_persend */);
 	if (len == -1) {
-		plog(LLV_ERROR, LOCATION, NULL, "sendfromto failed\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "sendfromto failed\n");
 		return -1;
 	}
 
@@ -871,9 +877,9 @@
 	if (r->retry_counter <= 0) {
 		rem_recvdpkt(r);
 		del_recvdpkt(r);
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"deleted the retransmission packet to %s.\n",
-			saddr2str(remote));
+		     rcs_sa2str(remote));
 	} else
 		r->time_send = t;
 
@@ -889,49 +895,55 @@
 	vchar_t *sbuf, *rbuf;
 {
 	struct recvdpkt *new = NULL;
+	int retry_counter;
 
-	if (lcconf->retry_counter == 0) {
+#ifdef notyet
+	retry_counter = ikev1_max_retry_to_send(conf);
+#else
+	retry_counter = 1;
+#endif
+	if (retry_counter == 0) {
 		/* no need to add it */
 		return 0;
 	}
 
 	new = racoon_calloc(1, sizeof(*new));
 	if (!new) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate buffer.\n");
 		return -1;
 	}
 
 	new->hash = eay_md5_one(rbuf);
 	if (!new->hash) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate buffer.\n");
 		del_recvdpkt(new);
 		return -1;
 	}
-	new->remote = dupsaddr(remote);
+	new->remote = rcs_sadup(remote);
 	if (new->remote == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate buffer.\n");
 		del_recvdpkt(new);
 		return -1;
 	}
-	new->local = dupsaddr(local);
+	new->local = rcs_sadup(local);
 	if (new->local == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate buffer.\n");
 		del_recvdpkt(new);
 		return -1;
 	}
 	new->sendbuf = vdup(sbuf);
 	if (new->sendbuf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate buffer.\n");
 		del_recvdpkt(new);
 		return -1;
 	}
 
-	new->retry_counter = lcconf->retry_counter;
+	new->retry_counter = retry_counter;
 	new->time_send = 0;
 	new->created = time(NULL);
 
@@ -968,12 +980,22 @@
 {
 	struct recvdpkt *r, *next;
 	time_t t, lt;
+	int retry_counter;
+	int retry_interval;
+
+#ifdef notyet
+	retry_counter = ikev1_max_retry_to_send();
+	retry_interval = ikev1_interval_to_send();
+#else
+	retry_counter = 1;
+	retry_interval = 1;
+#endif
 
 	/* set current time */
 	t = time(NULL);
 
 	/* set the lifetime of the retransmission */
-	lt = lcconf->retry_counter * lcconf->retry_interval;
+	lt = retry_counter * retry_interval;
 
 	for (r = LIST_FIRST(&rcptree); r; r = next) {
 		next = LIST_NEXT(r, chain);
@@ -990,7 +1012,11 @@
 void
 init_recvdpkt()
 {
+#ifdef notyet
 	time_t lt = lcconf->retry_counter * lcconf->retry_interval;
+#else
+	time_t lt = 2;
+#endif
 
 	LIST_INIT(&rcptree);
 
@@ -1046,7 +1072,7 @@
 		/* 
 		 * Sainfo has been removed
 		 */
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "Reload: No sainfo for ph2\n");
 		return 0;
 	}
@@ -1055,7 +1081,7 @@
 		/*
 		 * XXX why do we have a NULL approval sometimes ???
 		 */
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "No approval found !\n");
 		return 0;
 	}	
@@ -1066,8 +1092,8 @@
 	 * for pk_sendgetspi()
 	 */
 
-	plog(LLV_DEBUG, LOCATION, NULL, "active single bundle:\n");
-	printsaprop0(LLV_DEBUG, approval);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "active single bundle:\n");
+	printsaprop0(PLOG_DEBUG, approval);
 
 	/*
 	 * Validate approval against sainfo
@@ -1077,55 +1103,55 @@
 	 * XXX lifebyte
 	 */
 	if (iph2->ph1 != NULL && iph2->ph1->rmconf != NULL) {
-		check_level = iph2->ph1->rmconf->pcheck_level;
+		check_level = ikev1_proposal_check(iph2->ph1->rmconf);
 	} else {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "No phase1 rmconf found !\n");
-		check_level = PROP_CHECK_EXACT;
+		check_level = RCT_PCT_EXACT;
 	}
 
 	switch (check_level) {
-	case PROP_CHECK_OBEY:
-		plog(LLV_DEBUG, LOCATION, NULL,
+	case RCT_PCT_OBEY:
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "Reload: OBEY for ph2, ok\n");
 		return 1;
 		break;
 
-	case PROP_CHECK_STRICT:
+	case RCT_PCT_STRICT:
 		/* FALLTHROUGH */
-	case PROP_CHECK_CLAIM:
+	case RCT_PCT_CLAIM:
 		if (sainfo->lifetime < approval->lifetime) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: lifetime mismatch\n");
 			return 0;
 		}
 
 		if (sainfo->lifebyte < approval->lifebyte) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: lifebyte mismatch\n");
 			return 0;
 		}
 
 		if (sainfo->pfs_group &&
 		   sainfo->pfs_group != approval->pfs_group) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: PFS group mismatch\n");
 			return 0;
 		}
 		break;
 
-	case PROP_CHECK_EXACT:
+	case RCT_PCT_EXACT:
 		if (sainfo->lifetime != approval->lifetime ||
 		    sainfo->lifebyte != approval->lifebyte ||
 		    sainfo->pfs_group != iph2->approval->pfs_group) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 			    "Reload: lifetime | pfs mismatch\n");
 			return 0;
 		}
 		break;
 
 	default:
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "Reload: Shouldn't be here !\n");
 		return 0;
 		break;
@@ -1136,7 +1162,7 @@
 			break;
 	}
 	if (alg == NULL) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "Reload: alg == NULL (auth)\n");
 		return 0;
 	}
@@ -1144,38 +1170,38 @@
 	found = 0;
 	for (alg = sainfo->algs[algclass_ipsec_enc]; 
 	    (found == 0 && alg != NULL); alg = alg->next) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "Reload: next ph2 enc alg...\n");
 
 		if (alg->alg != approval->head->head->trns_id){
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: encmode mismatch (%d / %d)\n",
 				 alg->alg, approval->head->head->trns_id);
 			continue;
 		}
 
 		switch (check_level){
-		/* PROP_CHECK_STRICT cannot happen here */
-		case PROP_CHECK_EXACT:
+		/* RCT_PCT_STRICT cannot happen here */
+		case RCT_PCT_EXACT:
 			if (alg->encklen != approval->head->head->encklen) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					 "Reload: enclen mismatch\n");
 				continue;
 			}
 			break;
 
-		case PROP_CHECK_CLAIM:
+		case RCT_PCT_CLAIM:
 			/* FALLTHROUGH */
-		case PROP_CHECK_STRICT:
+		case RCT_PCT_STRICT:
 			if (alg->encklen > approval->head->head->encklen) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					 "Reload: enclen mismatch\n");
 				continue;
 			}
 			break;
 
 		default:
-			plog(LLV_ERROR, LOCATION, NULL, 
+			plog(PLOG_INTERR, PLOGLOC, NULL, 
 			    "unexpected check_level\n");
 			continue;
 			break;
@@ -1184,7 +1210,7 @@
 	}
 
 	if (!found){
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "Reload: No valid enc\n");
 		return 0;
 	}
@@ -1192,7 +1218,7 @@
 	/*
 	 * XXX comp
 	 */
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		 "Reload: ph2 check ok\n");
 
 	return 1;
@@ -1207,7 +1233,7 @@
 	if(iph2 == NULL)
 		return;
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		 "Deleting a Ph2...\n");
 
 	if (iph2->status == PHASE2ST_ESTABLISHED)
@@ -1222,7 +1248,7 @@
 		 * - delete generated SPD
 		 * - unbind / rem / del ph2
 		 */
-		purge_ipsec_spi(iph2->dst, iph2->approval->head->proto_id,
+		purge_ipsec_spi(iph2->ph1, iph2->dst, iph2->approval->head->proto_id,
 						spis, 2);
 	}else{
 		unbindph12(iph2);
@@ -1237,7 +1263,7 @@
 	if(iph1 == NULL)
 		return;
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		 "Removing PH1...\n");
 
 	if (iph1->status == PHASE1ST_ESTABLISHED){
@@ -1252,9 +1278,10 @@
 }
 
 
+#ifdef notyet
 static int revalidate_ph1tree_rmconf(void){
 	struct ph1handle *p, *next;
-	struct remoteconf *newrmconf;
+	struct rcf_remote *newrmconf;
 
 	for (p = LIST_FIRST(&ph1tree); p; p = next) {
 		next = LIST_NEXT(p, chain);
@@ -1290,6 +1317,7 @@
 /* rmconf is already updated here
  */
 static int revalidate_ph1(struct ph1handle *iph1){
+	rc_type exchange_mode;
 	struct isakmpsa *p, *approval;
 	struct etypes *e;
 
@@ -1299,115 +1327,96 @@
 		return 0;
 
 	approval=iph1->approval;
-
-	for (e = iph1->rmconf->etypes; e != NULL; e = e->next){
-		if (iph1->etype == e->type)
-			break;
-	}
-
-	if (e == NULL){
-		plog(LLV_DEBUG, LOCATION, NULL,
-			 "Reload: Exchange type mismatch\n");
-		return 0;
-	}
-
-	if (iph1->etype == ISAKMP_ETYPE_AGG &&
-	   approval->dh_group != iph1->rmconf->dh_group){
-		plog(LLV_DEBUG, LOCATION, NULL,
-			 "Reload: DH mismatch\n");
-		return 0;
-	}
-
 	for (p=iph1->rmconf->proposal; p != NULL; p=p->next){
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			 "Reload: Trying next proposal...\n");
 
 		if(approval->authmethod != p->authmethod){
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: Authmethod mismatch\n");
 			continue;
 		}
 
 		if(approval->enctype != p->enctype){
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: enctype mismatch\n");
 			continue;
 		}
 
 		switch (iph1->rmconf->pcheck_level) {
-		case PROP_CHECK_OBEY:
-			plog(LLV_DEBUG, LOCATION, NULL,
+		case RCT_PCT_OBEY:
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: OBEY pcheck level, ok...\n");
 			return 1;
 			break;
 
-		case PROP_CHECK_CLAIM:
+		case RCT_PCT_CLAIM:
 			/* FALLTHROUGH */
-		case PROP_CHECK_STRICT:
+		case RCT_PCT_STRICT:
 			if (approval->encklen < p->encklen) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					 "Reload: encklen mismatch\n");
 				continue;
 			}
 
 			if (approval->lifetime > p->lifetime) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					 "Reload: lifetime mismatch\n");
 				continue;
 			}
 
 			if (approval->lifebyte > p->lifebyte) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					 "Reload: lifebyte mismatch\n");
 				continue;
 			}
 			break;
 
-		case PROP_CHECK_EXACT:
+		case RCT_PCT_EXACT:
 			if (approval->encklen != p->encklen) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					 "Reload: encklen mismatch\n");
 				continue;
 			}
 
 			if (approval->lifetime != p->lifetime) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					 "Reload: lifetime mismatch\n");
 				continue;
 			}
 
 			if (approval->lifebyte != p->lifebyte) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					 "Reload: lifebyte mismatch\n");
 				continue;
 			}
 			break;
 
 		default:
-			plog(LLV_ERROR, LOCATION, NULL, 
+			plog(PLOG_INTERR, PLOGLOC, NULL, 
 			    "unexpected check_level\n");
 			continue;
 			break;
 		}
 
 		if (approval->hashtype != p->hashtype) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: hashtype mismatch\n");
 			continue;
 		}
 
 		if (iph1->etype != ISAKMP_ETYPE_AGG &&
 		    approval->dh_group != p->dh_group) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "Reload: dhgroup mismatch\n");
 			continue;
 		}
 
-		plog(LLV_DEBUG, LOCATION, NULL, "Reload: Conf ok\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "Reload: Conf ok\n");
 		return 1;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL, "Reload: No valid conf found\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "Reload: No valid conf found\n");
 	return 0;
 }
 
@@ -1438,7 +1447,7 @@
 			continue;
 
 		if(!revalidate_ph2(p)){
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				 "PH2 not validated, removing it\n");
 			remove_ph2(p);
 		}
@@ -1458,6 +1467,7 @@
 
 	return 1;
 }
+#endif
 
 #ifdef ENABLE_HYBRID
 struct ph1handle *
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/handler.h ./handler.h
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/handler.h	Mon Jun 20 07:37:47 2005
+++ ./handler.h	Wed Feb  1 21:16:46 2006
@@ -1,4 +1,5 @@
-/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/*	$KAME: handler.h,v 1.44 2002/07/10 23:22:03 itojun Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -29,16 +30,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef _HANDLER_H
-#define _HANDLER_H
-
-#include <sys/queue.h>
-#include <openssl/rsa.h>
-
-#include <sys/time.h>
-
-#include "isakmp_var.h"
-#include "oakley.h"
+#include "ike_pfkey.h"
 
 /* Phase 1 handler */
 /*
@@ -104,112 +96,86 @@
  * acquire msg		I	R
  * ID payload		I	R		I	R
  */
-#ifdef ENABLE_HYBRID
-struct isakmp_cfg_state;
-#endif
 struct ph1handle {
-	isakmp_index index;
+	isakmp_index_t	index;
 
-	int status;			/* status of this SA */
-	int side;			/* INITIATOR or RESPONDER */
+	int status;		/* status of this SA */
+	int side;		/* INITIATOR or RESPONDER */
 
 	struct sockaddr *remote;	/* remote address to negosiate ph1 */
-	struct sockaddr *local;		/* local address to negosiate ph1 */
-			/* XXX copy from rmconf due to anonymous configuration.
-			 * If anonymous will be forbidden, we do delete them. */
+	struct sockaddr *local;	/* local address to negosiate ph1 */
+	/* XXX copy from rmconf due to anonymous configuration.
+	 * If anonymous will be forbidden, we do delete them. */
 
-	struct remoteconf *rmconf;	/* pointer to remote configuration */
+	struct rcf_remote *rmconf;	/* pointer to remote configuration */
+	struct isakmpsa *proposal;
 
 	struct isakmpsa *approval;	/* pointer to SA(s) approved. */
-	vchar_t *authstr;		/* place holder of string for auth. */
-					/* for example pre-shared key */
+	vchar_t *authstr;	/* place holder of string for auth. */
+	/* for example pre-shared key */
 
-	u_int8_t version;		/* ISAKMP version */
-	u_int8_t etype;			/* Exchange type actually for use */
-	u_int8_t flags;			/* Flags */
-	u_int32_t msgid;		/* message id */
-
-#ifdef ENABLE_NATT
-	struct ph1natt_options *natt_options;	/* Selected NAT-T IKE version */
-	u_int32_t natt_flags;		/* NAT-T related flags */
-#endif
-#ifdef ENABLE_FRAG
-	int frag;			/* IKE phase 1 fragmentation */
-	struct isakmp_frag_item *frag_chain;	/* Received fragments */
-#endif
-
-	struct sched *sce;		/* schedule for expire */
-
-	struct sched *scr;		/* schedule for resend */
-	int retry_counter;		/* for resend. */
-	vchar_t *sendbuf;		/* buffer for re-sending */
-
-	vchar_t *dhpriv;		/* DH; private value */
-	vchar_t *dhpub;			/* DH; public value */
-	vchar_t *dhpub_p;		/* DH; partner's public value */
-	vchar_t *dhgxy;			/* DH; shared secret */
-	vchar_t *nonce;			/* nonce value */
-	vchar_t *nonce_p;		/* partner's nonce value */
-	vchar_t *skeyid;		/* SKEYID */
-	vchar_t *skeyid_d;		/* SKEYID_d */
-	vchar_t *skeyid_a;		/* SKEYID_a, i.e. hash */
-	vchar_t *skeyid_e;		/* SKEYID_e, i.e. encryption */
-	vchar_t *key;			/* cipher key */
-	vchar_t *hash;			/* HASH minus general header */
-	vchar_t *sig;			/* SIG minus general header */
-	vchar_t *sig_p;			/* peer's SIG minus general header */
-	cert_t *cert;			/* CERT minus general header */
-	cert_t *cert_p;			/* peer's CERT minus general header */
-	cert_t *crl_p;			/* peer's CRL minus general header */
-	cert_t *cr_p;			/* peer's CR not including general */
-	RSA *rsa;			/* my RSA key */
-	RSA *rsa_p;			/* peer's RSA key */
-	struct genlist *rsa_candidates;	/* possible candidates for peer's RSA key */
-	vchar_t *id;			/* ID minus gen header */
-	vchar_t *id_p;			/* partner's ID minus general header */
-					/* i.e. strut ipsecdoi_id_b*. */
-	struct isakmp_ivm *ivm;		/* IVs */
-
-	vchar_t *sa;			/* whole SA payload to send/to be sent*/
-					/* to calculate HASH */
-					/* NOT INCLUDING general header. */
-
-	vchar_t *sa_ret;		/* SA payload to reply/to be replyed */
-					/* NOT INCLUDING general header. */
-					/* NOTE: Should be release after use. */
+	u_int8_t version;	/* ISAKMP version */
+	u_int8_t etype;		/* Exchange type actually for use */
+	u_int8_t flags;		/* Flags */
+	u_int32_t msgid;	/* message id */
+
+	struct sched *sce;	/* schedule for expire */
+
+	struct sched *scr;	/* schedule for resend */
+	int retry_counter;	/* for resend. */
+	vchar_t *sendbuf;	/* buffer for re-sending */
+
+	vchar_t *dhpriv;	/* DH; private value */
+	vchar_t *dhpub;		/* DH; public value */
+	vchar_t *dhpub_p;	/* DH; partner's public value */
+	vchar_t *dhgxy;		/* DH; shared secret */
+	vchar_t *nonce;		/* nonce value */
+	vchar_t *nonce_p;	/* partner's nonce value */
+	vchar_t *skeyid;	/* SKEYID */
+	vchar_t *skeyid_d;	/* SKEYID_d */
+	vchar_t *skeyid_a;	/* SKEYID_a, i.e. hash */
+	vchar_t *skeyid_e;	/* SKEYID_e, i.e. encryption */
+	vchar_t *key;		/* cipher key */
+	vchar_t *hash;		/* HASH minus general header */
+	vchar_t *sig;		/* SIG minus general header */
+	vchar_t *sig_p;		/* peer's SIG minus general header */
+	cert_t *cert;		/* CERT minus general header */
+	cert_t *cert_p;		/* peer's CERT minus general header */
+	cert_t *crl_p;		/* peer's CRL minus general header */
+	cert_t *cr_p;		/* peer's CR not including general */
+	vchar_t *id;		/* ID minus gen header */
+	vchar_t *id_p;		/* partner's ID minus general header */
+	/* i.e. strut ipsecdoi_id_b*. */
+	struct isakmp_ivm *ivm;	/* IVs */
+
+	vchar_t *sa;		/* whole SA payload to send/to be sent */
+	/* to calculate HASH */
+	/* NOT INCLUDING general header. */
+
+	vchar_t *sa_ret;	/* SA payload to reply/to be replyed */
+	/* NOT INCLUDING general header. */
+	/* NOTE: Should be release after use. */
 
 #ifdef HAVE_GSSAPI
-	void *gssapi_state;		/* GSS-API specific state. */
-					/* Allocated when needed */
-	vchar_t *gi_i;			/* optional initiator GSS id */
-	vchar_t *gi_r;			/* optional responder GSS id */
+	void *gssapi_state;	/* GSS-API specific state. */
+	/* Allocated when needed */
+	vchar_t *gi_i;		/* optional initiator GSS id */
+	vchar_t *gi_r;		/* optional responder GSS id */
 #endif
 
 	struct isakmp_pl_hash *pl_hash;	/* pointer to hash payload */
 
-	time_t created;			/* timestamp for establish */
+	time_t created;		/* timestamp for establish */
 #ifdef ENABLE_STATS
 	struct timeval start;
 	struct timeval end;
 #endif
 
-#ifdef ENABLE_DPD
-	int		dpd_support;	/* Does remote supports DPD ? */
-	time_t		dpd_lastack;	/* Last ack received */
-	u_int16_t	dpd_seq;		/* DPD seq number to receive */
-	u_int8_t	dpd_fails;		/* number of failures */
-	struct sched	*dpd_r_u;
-#endif
-
-	u_int32_t msgid2;		/* msgid counter for Phase 2 */
-	int ph2cnt;	/* the number which is negotiated by this phase 1 */
-	LIST_HEAD(_ph2ofph1_, ph2handle) ph2tree;
-
-	LIST_ENTRY(ph1handle) chain;
-#ifdef ENABLE_HYBRID
-	struct isakmp_cfg_state *mode_cfg;	/* ISAKMP mode config state */
-#endif       
+	u_int32_t msgid2;	/* msgid counter for Phase 2 */
+	int ph2cnt;		/* the number which is negotiated by this phase 1 */
+	    LIST_HEAD(_ph2ofph1_, ph2handle) ph2tree;
 
+	    LIST_ENTRY(ph1handle) chain;
 };
 
 /* Phase 2 handler */
@@ -242,73 +208,75 @@
 #define PHASE2ST_MAX		11
 
 struct ph2handle {
-	struct sockaddr *src;		/* my address of SA. */
-	struct sockaddr *dst;		/* peer's address of SA. */
+	struct sockaddr *src;	/* my address of SA. */
+	struct sockaddr *dst;	/* peer's address of SA. */
 
-		/*
-		 * copy ip address from ID payloads when ID type is ip address.
-		 * In other case, they must be null.
-		 */
+	/*
+	 * copy ip address from ID payloads when ID type is ip address.
+	 * In other case, they must be null.
+	 */
 	struct sockaddr *src_id;
 	struct sockaddr *dst_id;
 
-	u_int32_t spid;			/* policy id by kernel */
+	struct sadb_request sadb_request;
+#if 0
+	u_int32_t spid;		/* policy id by kernel */
+#endif
+	struct rcf_selector *selector;
 
-	int status;			/* ipsec sa status */
-	u_int8_t side;			/* INITIATOR or RESPONDER */
+	int status;		/* ipsec sa status */
+	u_int8_t side;		/* INITIATOR or RESPONDER */
 
-	struct sched *sce;		/* schedule for expire */
-	struct sched *scr;		/* schedule for resend */
-	int retry_counter;		/* for resend. */
-	vchar_t *sendbuf;		/* buffer for re-sending */
-	vchar_t *msg1;			/* buffer for re-sending */
-				/* used for responder's first message */
-
-	int retry_checkph1;		/* counter to wait phase 1 finished. */
-					/* NOTE: actually it's timer. */
-
-	u_int32_t seq;			/* sequence number used by PF_KEY */
-			/*
-			 * NOTE: In responder side, we can't identify each SAs
-			 * with same destination address for example, when
-			 * socket based SA is required.  So we set a identifier
-			 * number to "seq", and sent kernel by pfkey.
-			 */
-	u_int8_t satype;		/* satype in PF_KEY */
-			/*
-			 * saved satype in the original PF_KEY request from
-			 * the kernel in order to reply a error.
-			 */
+	struct sched *sce;	/* schedule for expire */
+	struct sched *scr;	/* schedule for resend */
+	int retry_counter;	/* for resend. */
+	vchar_t *sendbuf;	/* buffer for re-sending */
+	vchar_t *msg1;		/* buffer for re-sending */
+	/* used for responder's first message */
+
+	int retry_checkph1;	/* counter to wait phase 1 finished. */
+	/* NOTE: actually it's timer. */
+
+	u_int32_t seq;		/* sequence number used by PF_KEY */
+	/*
+	 * NOTE: In responder side, we can't identify each SAs
+	 * with same destination address for example, when
+	 * socket based SA is required.  So we set a identifier
+	 * number to "seq", and sent kernel by pfkey.
+	 */
+	rc_type satype;		/* satype in rc_type */
+	/*
+	 * saved satype in the original PF_KEY request from
+	 * the kernel in order to reply a error.
+	 */
 
-	u_int8_t flags;			/* Flags for phase 2 */
-	u_int32_t msgid;		/* msgid for phase 2 */
+	u_int8_t flags;		/* Flags for phase 2 */
+	u_int32_t msgid;	/* msgid for phase 2 */
 
-	struct sainfo *sainfo;		/* place holder of sainfo */
+	struct sainfo *sainfo;	/* place holder of sainfo */
 	struct saprop *proposal;	/* SA(s) proposal. */
 	struct saprop *approval;	/* SA(s) approved. */
-	caddr_t spidx_gen;		/* policy from peer's proposal */
+	caddr_t spidx_gen;	/* policy from peer's proposal */
 
-	struct dhgroup *pfsgrp;		/* DH; prime number */
-	vchar_t *dhpriv;		/* DH; private value */
-	vchar_t *dhpub;			/* DH; public value */
-	vchar_t *dhpub_p;		/* DH; partner's public value */
-	vchar_t *dhgxy;			/* DH; shared secret */
-	vchar_t *id;			/* ID minus gen header */
-	vchar_t *id_p;			/* peer's ID minus general header */
-	vchar_t *nonce;			/* nonce value in phase 2 */
-	vchar_t *nonce_p;		/* partner's nonce value in phase 2 */
-
-	vchar_t *sa;			/* whole SA payload to send/to be sent*/
-					/* to calculate HASH */
-					/* NOT INCLUDING general header. */
-
-	vchar_t *sa_ret;		/* SA payload to reply/to be replyed */
-					/* NOT INCLUDING general header. */
-					/* NOTE: Should be release after use. */
+	struct dhgroup *pfsgrp;	/* DH; prime number */
+	vchar_t *dhpriv;	/* DH; private value */
+	vchar_t *dhpub;		/* DH; public value */
+	vchar_t *dhpub_p;	/* DH; partner's public value */
+	vchar_t *dhgxy;		/* DH; shared secret */
+	vchar_t *id;		/* ID minus gen header */
+	vchar_t *id_p;		/* peer's ID minus general header */
+	vchar_t *nonce;		/* nonce value in phase 2 */
+	vchar_t *nonce_p;	/* partner's nonce value in phase 2 */
+
+	vchar_t *sa;		/* whole SA payload to send/to be sent */
+	/* to calculate HASH */
+	/* NOT INCLUDING general header. */
+
+	vchar_t *sa_ret;	/* SA payload to reply/to be replyed */
+	/* NOT INCLUDING general header. */
+	/* NOTE: Should be release after use. */
 
-	struct isakmp_ivm *ivm;		/* IVs */
-
-	int generated_spidx;	/* mark handlers whith generated policy */
+	struct isakmp_ivm *ivm;	/* IVs */
 
 #ifdef ENABLE_STATS
 	struct timeval start;
@@ -316,8 +284,8 @@
 #endif
 	struct ph1handle *ph1;	/* back pointer to isakmp status */
 
-	LIST_ENTRY(ph2handle) chain;
-	LIST_ENTRY(ph2handle) ph1bind;	/* chain to ph1handle */
+	          LIST_ENTRY(ph2handle) chain;
+	          LIST_ENTRY(ph2handle) ph1bind;	/* chain to ph1handle */
 };
 
 /*
@@ -325,7 +293,7 @@
  */
 struct contacted {
 	struct sockaddr *remote;	/* remote address to negosiate ph1 */
-	LIST_ENTRY(contacted) chain;
+	         LIST_ENTRY(contacted) chain;
 };
 
 /*
@@ -333,16 +301,16 @@
  */
 struct recvdpkt {
 	struct sockaddr *remote;	/* the remote address */
-	struct sockaddr *local;		/* the local address */
-	vchar_t *hash;			/* hash of the received packet */
-	vchar_t *sendbuf;		/* buffer for the response */
-	int retry_counter;		/* how many times to send */
-	time_t time_send;		/* timestamp to send a packet */
-	time_t created;			/* timestamp to create a queue */
+	struct sockaddr *local;	/* the local address */
+	vchar_t *hash;		/* hash of the received packet */
+	vchar_t *sendbuf;	/* buffer for the response */
+	int retry_counter;	/* how many times to send */
+	time_t time_send;	/* timestamp to send a packet */
+	time_t created;		/* timestamp to create a queue */
 
-	struct sched *scr;		/* schedule for resend, may not used */
+	struct sched *scr;	/* schedule for resend, may not used */
 
-	LIST_ENTRY(recvdpkt) chain;
+	      LIST_ENTRY(recvdpkt) chain;
 };
 
 /* for parsing ISAKMP header. */
@@ -398,20 +366,20 @@
  * Otherwise IV mismatched happens between the intitiator and the responder.
  */
 struct isakmp_ivm {
-	vchar_t *iv;	/* for decoding packet */
-			/* if phase 1, it's for computing phase2 iv */
-	vchar_t *ive;	/* for encoding packet */
+	vchar_t *iv;		/* for decoding packet */
+	/* if phase 1, it's for computing phase2 iv */
+	vchar_t *ive;		/* for encoding packet */
 };
 
 /* for dumping */
 struct ph1dump {
-	isakmp_index index;
+	isakmp_index_t index;
 	int status;
 	int side;
 	struct sockaddr_storage remote;
 	struct sockaddr_storage local;
 	u_int8_t version;
-	u_int8_t etype;	
+	u_int8_t etype;
 	time_t created;
 	int ph2cnt;
 };
@@ -421,17 +389,10 @@
 struct ph2handle;
 struct policyindex;
 
-extern struct ph1handle *getph1byindex __P((isakmp_index *));
-extern struct ph1handle *getph1byindex0 __P((isakmp_index *));
+extern struct ph1handle *getph1byindex __P((isakmp_index_t *));
+extern struct ph1handle *getph1byindex0 __P((isakmp_index_t *));
 extern struct ph1handle *getph1byaddr __P((struct sockaddr *,
-	struct sockaddr *));
-extern struct ph1handle *getph1byaddrwop __P((struct sockaddr *,
-	struct sockaddr *));
-extern struct ph1handle *getph1bydstaddrwop __P((struct sockaddr *));
-#ifdef ENABLE_HYBRID
-struct ph1handle *getph1bylogin __P((char *));
-int purgeph1bylogin __P((char *));
-#endif
+					   struct sockaddr *));
 extern vchar_t *dumpph1 __P((void));
 extern struct ph1handle *newph1 __P((void));
 extern void delph1 __P((struct ph1handle *));
@@ -443,13 +404,10 @@
 extern struct ph2handle *getph2byspidx __P((struct policyindex *));
 extern struct ph2handle *getph2byspid __P((u_int32_t));
 extern struct ph2handle *getph2byseq __P((u_int32_t));
-extern struct ph2handle *getph2bysaddr __P((struct sockaddr *,
-	struct sockaddr *));
 extern struct ph2handle *getph2bymsgid __P((struct ph1handle *, u_int32_t));
-extern struct ph2handle *getph2byid __P((struct sockaddr *,
-	struct sockaddr *, u_int32_t));
 extern struct ph2handle *getph2bysaidx __P((struct sockaddr *,
-	struct sockaddr *, u_int, u_int32_t));
+					    struct sockaddr *, u_int,
+					    u_int32_t));
 extern struct ph2handle *newph2 __P((void));
 extern void initph2 __P((struct ph2handle *));
 extern void delph2 __P((struct ph2handle *));
@@ -467,15 +425,7 @@
 extern void initctdtree __P((void));
 
 extern int check_recvdpkt __P((struct sockaddr *,
-	struct sockaddr *, vchar_t *));
+			       struct sockaddr *, vchar_t *));
 extern int add_recvdpkt __P((struct sockaddr *, struct sockaddr *,
-	vchar_t *, vchar_t *));
+			     vchar_t *, vchar_t *));
 extern void init_recvdpkt __P((void));
-
-#ifdef ENABLE_HYBRID
-extern int exclude_cfg_addr __P((const struct sockaddr *));
-#endif
-
-extern int revalidate_ph12(void);
-
-#endif /* _HANDLER_H */
Only in .: ikev1.c
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/ipsec_doi.c ./ipsec_doi.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/ipsec_doi.c	Tue Oct 18 01:31:39 2005
+++ ./ipsec_doi.c	Thu Feb  2 16:24:03 2006
@@ -1,4 +1,4 @@
-/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/*	$KAME: ipsec_doi.c,v 1.168 2004/03/03 02:28:46 sakane Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -29,20 +29,22 @@
  * SUCH DAMAGE.
  */
 
-#include "config.h"
+#include <config.h>
 
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
 
+#include <netkey/key_var.h>
 #include <netinet/in.h>
 
-#ifndef HAVE_NETINET6_IPSEC
+#ifdef IPV6_INRIA_VERSION
 #include <netinet/ipsec.h>
 #else
 #include <netinet6/ipsec.h>
 #endif
 
+#include <assert.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -61,49 +63,41 @@
 
 #include "var.h"
 #include "vmbuf.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "plog.h"
 #include "debug.h"
 
-#include "cfparse_proto.h"
-#include "isakmp_var.h"
+/* #include "cfparse_proto.h" */
 #include "isakmp.h"
+#include "isakmp_impl.h"
+#include "isakmp_var.h"
 #include "ipsec_doi.h"
+#include "dhgroup.h"
 #include "oakley.h"
 #include "remoteconf.h"
-#include "localconf.h"
+/* #include "localconf.h" */
 #include "sockmisc.h"
 #include "handler.h"
-#include "policy.h"
+/* #include "policy.h" */
 #include "algorithm.h"
 #include "sainfo.h"
 #include "proposal.h"
-#include "crypto_openssl.h"
+#include "crypto_impl.h"
 #include "strnames.h"
 #include "gcmalloc.h"
 
-#ifdef ENABLE_NATT
-#include "nattraversal.h"
-#endif
-#ifdef ENABLE_HYBRID
-static int switch_authmethod(int);
-#endif
-
 #ifdef HAVE_GSSAPI
-#include <iconv.h>
 #include "gssapi.h"
-#ifdef HAVE_ICONV_2ND_CONST
-#define __iconv_const const
-#else
-#define __iconv_const
-#endif
 #endif
 
+#include "ike_conf.h"
+#include "racoon.h"
+
 int verbose_proposal_check = 1;
 
 static vchar_t *get_ph1approval __P((struct ph1handle *, struct prop_pair **));
 static struct isakmpsa *get_ph1approvalx __P((struct prop_pair *,
-	struct isakmpsa *, struct isakmpsa *, int));
+	struct isakmpsa *, struct isakmpsa *));
 static void print_ph1mismatched __P((struct prop_pair *, struct isakmpsa *));
 static int t2isakmpsa __P((struct isakmp_pl_t *, struct isakmpsa *));
 static int cmp_aproppair_i __P((struct prop_pair *, struct prop_pair *));
@@ -160,7 +154,9 @@
 static vchar_t *setph2proposal0 __P((const struct ph2handle *,
 	const struct saprop *, const struct saproto *));
 
+#if 0
 static vchar_t *getidval __P((int, vchar_t *));
+#endif
 
 #ifdef HAVE_GSSAPI
 static struct isakmpsa *fixup_initiator_sa __P((struct isakmpsa *,
@@ -218,23 +214,19 @@
 	int prophlen;
 	int i;
 
-	if (iph1->approval) {
-		delisakmpsa(iph1->approval);
-		iph1->approval = NULL;
-	}
+	iph1->approval = NULL;
 
 	for (i = 0; i < MAXPROPPAIRLEN; i++) {
 		if (pair[i] == NULL)
 			continue;
 		for (s = pair[i]; s; s = s->next) {
-			prophlen = 
-			    sizeof(struct isakmp_pl_p) + s->prop->spi_size;
-
+			prophlen = sizeof(struct isakmp_pl_p)
+					+ s->prop->spi_size;
 			/* compare proposal and select one */
 			for (p = s; p; p = p->tnext) {
-				if ((sa = get_ph1approvalx(p, 
-				    iph1->rmconf->proposal, &tsa, 
-				    iph1->rmconf->pcheck_level)) != NULL)
+				sa = get_ph1approvalx(p, ikev1_proposal(iph1),
+						      &tsa);
+				if (sa != NULL)
 					goto found;
 			}
 		}
@@ -253,17 +245,17 @@
 						+ s->prop->spi_size;
 				for (p = s; p; p = p->tnext) {
 					print_ph1mismatched(p,
-						iph1->rmconf->proposal);
+						ikev1_proposal(iph1));
 				}
 			}
 		}
 	}
-	plog(LLV_ERROR, LOCATION, NULL, "no suitable proposal found.\n");
+	plog(PLOG_PROTOERR, PLOGLOC, NULL, "no suitable proposal found.\n");
 
 	return NULL;
 
 found:
-	plog(LLV_DEBUG, LOCATION, NULL, "an acceptable proposal found.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "an acceptable proposal found.\n");
 
 	/* check DH group settings */
 	if (sa->dhgrp) {
@@ -271,10 +263,9 @@
 			/* it's ok */
 			goto saok;
 		}
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, 0,
 			"invalid DH parameter found, use default.\n");
 		oakley_dhgrp_free(sa->dhgrp);
-		sa->dhgrp=NULL;
 	}
 
 	if (oakley_setdhgroup(sa->dh_group, &sa->dhgrp) == -1) {
@@ -285,42 +276,40 @@
 saok:
 #ifdef HAVE_GSSAPI
 	if (sa->gssid != NULL)
-		plog(LLV_DEBUG, LOCATION, NULL, "gss id in new sa '%.*s'\n",
-		    sa->gssid->l, sa->gssid->v);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "gss id in new sa '%s'\n",
+		    sa->gssid->v);
 	if (iph1-> side == INITIATOR) {
-		if (iph1->rmconf->proposal->gssid != NULL)
-			iph1->gi_i = vdup(iph1->rmconf->proposal->gssid);
+		if (ikev1_proposal(iph1)->gssid != NULL)
+			iph1->gi_i = vdup(ikev1_proposal(iph1)->gssid);
 		if (tsa.gssid != NULL)
 			iph1->gi_r = vdup(tsa.gssid);
 		iph1->approval = fixup_initiator_sa(sa, &tsa);
 	} else {
 		if (tsa.gssid != NULL) {
 			iph1->gi_r = vdup(tsa.gssid);
-			iph1->gi_i = gssapi_get_id(iph1);
+			if (ikev1_proposal(iph1)->gssid != NULL)
+				iph1->gi_i =
+				    vdup(ikev1_proposal(iph1)->gssid);
+			else
+				iph1->gi_i = gssapi_get_default_id(iph1);
 			if (sa->gssid == NULL && iph1->gi_i != NULL)
 				sa->gssid = vdup(iph1->gi_i);
 		}
 		iph1->approval = sa;
 	}
 	if (iph1->gi_i != NULL)
-		plog(LLV_DEBUG, LOCATION, NULL, "GIi is %.*s\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "GIi is %*s\n",
 		    iph1->gi_i->l, iph1->gi_i->v);
 	if (iph1->gi_r != NULL)
-		plog(LLV_DEBUG, LOCATION, NULL, "GIr is %.*s\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "GIr is %*s\n",
 		    iph1->gi_r->l, iph1->gi_r->v);
 #else
 	iph1->approval = sa;
 #endif
-	if(iph1->approval) {
-		plog(LLV_DEBUG, LOCATION, NULL, "agreed on %s auth.\n",
-		    s_oakley_attr_method(iph1->approval->authmethod));
-	}
 
 	newsa = get_sabyproppair(p, iph1);
-	if (newsa == NULL){
-		delisakmpsa(iph1->approval);
+	if (newsa == NULL)
 		iph1->approval = NULL;
-	}
 
 	return newsa;
 }
@@ -332,22 +321,20 @@
  * proposal: my proposals.
  */
 static struct isakmpsa *
-get_ph1approvalx(p, proposal, sap, check_level)
+get_ph1approvalx(p, proposal, sap)
 	struct prop_pair *p;
 	struct isakmpsa *proposal, *sap;
-	int check_level;
 {
 	struct isakmp_pl_p *prop = p->prop;
 	struct isakmp_pl_t *trns = p->trns;
 	struct isakmpsa sa, *s, *tsap;
-	int authmethod;
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
        		"prop#=%d, prot-id=%s, spi-size=%d, #trns=%d\n",
 		prop->p_no, s_ipsecdoi_proto(prop->proto_id),
 		prop->spi_size, prop->num_t);
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"trns#=%d, trns-id=%s\n",
 		trns->t_no,
 		s_ipsecdoi_trns(prop->proto_id, trns->t_id));
@@ -358,40 +345,36 @@
 	if (t2isakmpsa(trns, tsap) < 0)
 		return NULL;
 	for (s = proposal; s != NULL; s = s->next) {
-#ifdef ENABLE_HYBRID
-		authmethod = switch_authmethod(s->authmethod);
-#else
-		authmethod = s->authmethod;
-#endif
-		plog(LLV_DEBUG, LOCATION, NULL, "Compared: DB:Peer\n");
-		plog(LLV_DEBUG, LOCATION, NULL, "(lifetime = %ld:%ld)\n",
-			(long)s->lifetime, (long)tsap->lifetime);
-		plog(LLV_DEBUG, LOCATION, NULL, "(lifebyte = %zu:%zu)\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "Compared: DB:Peer\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "(lifetime = %ld:%ld)\n",
+			s->lifetime, tsap->lifetime);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "(lifebyte = %ld:%ld)\n",
 			s->lifebyte, tsap->lifebyte);
-		plog(LLV_DEBUG, LOCATION, NULL, "enctype = %s:%s\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "enctype = %s:%s\n",
 			s_oakley_attr_v(OAKLEY_ATTR_ENC_ALG,
 					s->enctype),
 			s_oakley_attr_v(OAKLEY_ATTR_ENC_ALG,
 					tsap->enctype));
-		plog(LLV_DEBUG, LOCATION, NULL, "(encklen = %d:%d)\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "(encklen = %d:%d)\n",
 			s->encklen, tsap->encklen);
-		plog(LLV_DEBUG, LOCATION, NULL, "hashtype = %s:%s\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "hashtype = %s:%s\n",
 			s_oakley_attr_v(OAKLEY_ATTR_HASH_ALG,
 					s->hashtype),
 			s_oakley_attr_v(OAKLEY_ATTR_HASH_ALG,
 					tsap->hashtype));
-		plog(LLV_DEBUG, LOCATION, NULL, "authmethod = %s:%s\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "authmethod = %s:%s\n",
 			s_oakley_attr_v(OAKLEY_ATTR_AUTH_METHOD,
 					s->authmethod),
 			s_oakley_attr_v(OAKLEY_ATTR_AUTH_METHOD,
 					tsap->authmethod));
-		plog(LLV_DEBUG, LOCATION, NULL, "dh_group = %s:%s\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "dh_group = %s:%s\n",
 			s_oakley_attr_v(OAKLEY_ATTR_GRP_DESC,
 					s->dh_group),
 			s_oakley_attr_v(OAKLEY_ATTR_GRP_DESC,
 					tsap->dh_group));
 #if 0
-		/* XXX to be considered ? */
+		/* XXX to be considered */
+		if (tsap->lifetime > s->lifetime) ;
 		if (tsap->lifebyte > s->lifebyte) ;
 #endif
 		/*
@@ -399,75 +382,15 @@
 		 * is bigger than mine, it might be accepted.
 		 */
 		if(tsap->enctype == s->enctype &&
-		    tsap->authmethod == authmethod &&
+		    tsap->authmethod == s->authmethod &&
 		    tsap->hashtype == s->hashtype &&
 		    tsap->dh_group == s->dh_group &&
-		    tsap->encklen == s->encklen) {
-			switch(check_level) {
-			case PROP_CHECK_OBEY:
-				goto found;
-				break;
-
-			case PROP_CHECK_STRICT:
-				if ((tsap->lifetime > s->lifetime) ||
-				    (tsap->lifebyte > s->lifebyte))
-					continue;
-				goto found;
-				break;
-
-			case PROP_CHECK_CLAIM:
-				if (tsap->lifetime < s->lifetime)
-					s->lifetime = tsap->lifetime;
-				if (tsap->lifebyte < s->lifebyte)
-					s->lifebyte = tsap->lifebyte;
-				goto found;
-				break;
-
-			case PROP_CHECK_EXACT:
-				if ((tsap->lifetime != s->lifetime) ||
-				    (tsap->lifebyte != s->lifebyte))
-					continue;
-				goto found;
-				break;
-
-			default:
-				plog(LLV_ERROR, LOCATION, NULL, 
-				    "Unexpected proposal_check value\n");
-				continue;
-				break;
-			}
-		}
+		    tsap->encklen == s->encklen)
+			break;
 	}
 
-found:
-	if (tsap->dhgrp != NULL){
+	if (tsap->dhgrp != NULL)
 		oakley_dhgrp_free(tsap->dhgrp);
-		tsap->dhgrp = NULL;
-	}
-
-	if ((s = dupisakmpsa(s)) != NULL) {
-		switch(check_level) {
-		case PROP_CHECK_OBEY:
-			s->lifetime = tsap->lifetime;
-			s->lifebyte = tsap->lifebyte;
-			break;
-
-		case PROP_CHECK_STRICT:
-			s->lifetime = tsap->lifetime;
-			s->lifebyte = tsap->lifebyte;
-			break;
-
-		case PROP_CHECK_CLAIM:
-			if (tsap->lifetime < s->lifetime)
-				s->lifetime = tsap->lifetime;
-			if (tsap->lifebyte < s->lifebyte)
-				s->lifebyte = tsap->lifebyte;
-			break;
-
-		default:
-			break;
-		}
-	}
 	return s;
 }
 
@@ -488,7 +411,7 @@
 		return;
 	for (s = proposal; s ; s = s->next) {
 		if (sa.enctype != s->enctype) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"rejected enctype: "
 				"DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = "
 				"%s:%s\n",
@@ -500,7 +423,7 @@
 					sa.enctype));
 		}
 		if (sa.authmethod != s->authmethod) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"rejected authmethod: "
 				"DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = "
 				"%s:%s\n",
@@ -512,7 +435,7 @@
 					sa.authmethod));
 		}
 		if (sa.hashtype != s->hashtype) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"rejected hashtype: "
 				"DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = "
 				"%s:%s\n",
@@ -524,7 +447,7 @@
 					sa.hashtype));
 		}
 		if (sa.dh_group != s->dh_group) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"rejected dh_group: "
 				"DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = "
 				"%s:%s\n",
@@ -537,10 +460,8 @@
 		}
 	}
 
-	if (sa.dhgrp != NULL){
+	if (sa.dhgrp != NULL)
 		oakley_dhgrp_free(sa.dhgrp);
-		sa.dhgrp=NULL;
-	}
 }
 
 /*
@@ -577,7 +498,7 @@
 		type = ntohs(d->type) & ~ISAKMP_GEN_MASK;
 		flag = ntohs(d->type) & ISAKMP_GEN_MASK;
 
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"type=%s, flag=0x%04x, lorv=%s\n",
 			s_oakley_attr(type), flag,
 			s_oakley_attr_v(type, ntohs(d->lorv)));
@@ -692,7 +613,7 @@
 			if (!prev
 			 || (ntohs(prev->type) & ~ISAKMP_GEN_MASK) !=
 					OAKLEY_ATTR_SA_LD_TYPE) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				    "life duration must follow ltype\n");
 				break;
 			}
@@ -702,7 +623,7 @@
 				sa->lifetime = ipsecdoi_set_ld(val);
 				vfree(val);
 				if (sa->lifetime == 0) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"invalid life duration.\n");
 					goto err;
 				}
@@ -710,15 +631,15 @@
 			case IPSECDOI_ATTR_SA_LD_TYPE_KB:
 				sa->lifebyte = ipsecdoi_set_ld(val);
 				vfree(val);
-				if (sa->lifebyte == 0) {
-					plog(LLV_ERROR, LOCATION, NULL,
+				if (sa->lifetime == 0) {
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"invalid life duration.\n");
 					goto err;
 				}
 				break;
 			default:
 				vfree(val);
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid life type: %d\n", life_t);
 				goto err;
 			}
@@ -728,7 +649,7 @@
 		{
 			int len = ntohs(d->lorv);
 			if (len % 8 != 0) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"keylen %d: not multiple of 8\n",
 					len);
 				goto err;
@@ -748,82 +669,16 @@
 #ifdef HAVE_GSSAPI
 		case OAKLEY_ATTR_GSS_ID:
 		{
-			iconv_t cd;
-			size_t srcleft, dstleft, rv;
-			__iconv_const char *src;
-			char *dst;
 			int len = ntohs(d->lorv);
 
-			/*
-			 * Older verions of racoon just placed the
-			 * ISO-Latin-1 string on the wire directly.
-			 * Check to see if we are configured to be
-			 * compatible with this behavior.
-			 */
-			if (lcconf->gss_id_enc == LC_GSSENC_LATIN1) {
-				sa->gssid = vmalloc(len);
-				memcpy(sa->gssid->v, d + 1, len);
-				plog(LLV_DEBUG, LOCATION, NULL,
-				  "received old-style gss id '%.*s' (len %d)\n",
-				  sa->gssid->l, sa->gssid->v, sa->gssid->l);
-				break;
-			}
-
-			/*
-			 * For Windows 2000 compatibility, we expect
-			 * the GSS ID attribute on the wire to be
-			 * encoded in UTF-16LE.  Internally, we work
-			 * in ISO-Latin-1.  Therefore, we should need
-			 * 1/2 the specified length, which should always
-			 * be a multiple of 2 octets.
-			 */
-			cd = iconv_open("latin1", "utf-16le");
-			if (cd == (iconv_t) -1) {
-				plog(LLV_ERROR, LOCATION, NULL,
-				    "unable to initialize utf-16le -> latin1 "
-				    "conversion descriptor: %s\n",
-				    strerror(errno));
-				break;
-			}
-
-			sa->gssid = vmalloc(len / 2);
-
-			src = (__iconv_const char *)(d + 1);
-			srcleft = len;
-
-			dst = sa->gssid->v;
-			dstleft = len / 2;
-
-			rv = iconv(cd, (__iconv_const char **)&src, &srcleft, 
-				   &dst, &dstleft);
-			if (rv != 0) {
-				if (rv == -1) {
-					plog(LLV_ERROR, LOCATION, NULL,
-					    "unable to convert GSS ID from "
-					    "utf-16le -> latin1: %s\n",
-					    strerror(errno));
-				} else {
-					plog(LLV_ERROR, LOCATION, NULL,
-					    "%zd character%s in GSS ID cannot "
-					    "be represented in latin1\n",
-					    rv, rv == 1 ? "" : "s");
-				}
-				(void) iconv_close(cd);
-				vfree(sa->gssid);
-				sa->gssid = NULL;
-				break;
-			}
-			(void) iconv_close(cd);
-
-			/* XXX dstleft should always be 0; assert it? */
-			sa->gssid->l = (len / 2) - dstleft;
-
-			plog(LLV_DEBUG, LOCATION, NULL,
-			    "received gss id '%.*s' (len %d)\n",
-			    sa->gssid->l, sa->gssid->v, sa->gssid->l);
+			sa->gssid = vmalloc(len);
+			memcpy(sa->gssid->v, d + 1, len);
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
+			    "received gss id '%s' (len %d)\n", sa->gssid->v,
+			    sa->gssid->l);
 			break;
 		}
-#endif /* HAVE_GSSAPI */
+#endif
 
 		default:
 			break;
@@ -846,7 +701,7 @@
 		 || sa->enctype == OAKLEY_ATTR_ENC_ALG_IDEA
 #endif
 		 || sa->enctype == OAKLEY_ATTR_ENC_ALG_3DES) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"keylen must not be specified "
 				"for encryption algorithm %d\n",
 				sa->enctype);
@@ -911,22 +766,21 @@
 	struct prop_pair *p;
 	int i, n, num;
 	int error = -1;
-	vchar_t *sa_ret = NULL;
 
 	/* get proposal pair of SA sent. */
 	spair = get_proppair(iph2->sa, IPSECDOI_TYPE_PH2);
 	if (spair == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to get prop pair.\n");
 		goto end;
 	}
 
 	/* XXX should check the number of transform */
 
-	/* get proposal pair of SA replayed */
+	/* get proposal pair of SA replyed */
 	rpair = get_proppair(iph2->sa_ret, IPSECDOI_TYPE_PH2);
 	if (rpair == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to get prop pair.\n");
 		goto end;
 	}
@@ -941,30 +795,30 @@
 		}
 	}
 	if (num == 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"no proposal received.\n");
 		goto end;
 	}
 	if (num != 1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"some proposals received.\n");
 		goto end;
 	}
 
 	if (spair[n] == NULL) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, 0,
 			"invalid proposal number:%d received.\n", i);
 	}
 	
 
 	if (rpair[n]->tnext != NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"multi transforms replyed.\n");
 		goto end;
 	}
 
 	if (cmp_aproppair_i(rpair[n], spair[n])) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"proposal mismathed.\n");
 		goto end;
 	}
@@ -979,7 +833,7 @@
 		goto end;
 
 	/* make a SA to be replayed. */
-	sa_ret = iph2->sa_ret;
+	VPTRINIT(iph2->sa_ret);
 	iph2->sa_ret = get_sabyproppair(p, iph2->ph1);
 	free_proppair0(p);
 	if (iph2->sa_ret == NULL)
@@ -992,8 +846,6 @@
 		free_proppair(rpair);
 	if (spair)
 		free_proppair(spair);
-	if (sa_ret)
-		vfree(sa_ret);
 
 	return error;
 }
@@ -1024,14 +876,14 @@
 		}
 		if (!r) {
 			/* no suitable transform found */
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"no suitable transform found.\n");
 			return -1;
 		}
 
 		/* compare prop */
 		if (p->prop->p_no != r->prop->p_no) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"proposal #%d mismatched, "
 				"expected #%d.\n",
 				r->prop->p_no, p->prop->p_no);
@@ -1039,14 +891,14 @@
 		}
 
 		if (p->prop->proto_id != r->prop->proto_id) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"proto_id mismathed: my:%d peer:%d\n",
 				r->prop->proto_id, p->prop->proto_id);
 			return -1;
 		}
 
 		if (p->prop->proto_id != r->prop->proto_id) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid spi size: %d.\n",
 				p->prop->proto_id);
 			return -1;
@@ -1054,19 +906,19 @@
 
 		/* check #of transforms */
 		if (p->prop->num_t != 1) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"#of transform is %d, "
 				"but expected 1.\n", p->prop->num_t);
 			/*FALLTHROUGH*/
 		}
 
 		if (p->trns->t_id != r->trns->t_id) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"transform number has been modified.\n");
 			/*FALLTHROUGH*/
 		}
 		if (p->trns->reserved != r->trns->reserved) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"reserved field should be zero.\n");
 			/*FALLTHROUGH*/
 		}
@@ -1074,14 +926,14 @@
 		/* compare attribute */
 		len = ntohs(r->trns->h.len) - sizeof(*p->trns);
 		if (memcmp(p->trns + 1, r->trns + 1, len) != 0) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"attribute has been modified.\n");
 			/*FALLTHROUGH*/
 		}
 	}
 	if ((p && !q) || (!p && q)) {
 		/* # of protocols mismatched */
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"#of protocols mismatched.\n");
 		return -1;
 	}
@@ -1103,15 +955,15 @@
 
 	iph2->approval = NULL;
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"begin compare proposals.\n");
 
 	for (i = 0; i < MAXPROPPAIRLEN; i++) {
 		if (pair[i] == NULL)
 			continue;
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"pair[%d]: %p\n", i, pair[i]);
-		print_proppair(LLV_DEBUG, pair[i]);;
+		print_proppair(PLOG_DEBUG, pair[i]);;
 
 		/* compare proposal and select one */
 		ret = get_ph2approvalx(iph2, pair[i]);
@@ -1121,7 +973,7 @@
 		}
 	}
 
-	plog(LLV_ERROR, LOCATION, NULL, "no suitable policy found.\n");
+	plog(PLOG_PROTOERR, PLOGLOC, NULL, "no suitable policy found.\n");
 
 	return NULL;
 }
@@ -1145,18 +997,18 @@
 
 	for (q1 = pr0; q1; q1 = q1->next) {
 		for (q2 = iph2->proposal; q2; q2 = q2->next) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"peer's single bundle:\n");
-			printsaprop0(LLV_DEBUG, q1);
-			plog(LLV_DEBUG, LOCATION, NULL,
+			printsaprop0(PLOG_DEBUG, q1);
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"my single bundle:\n");
-			printsaprop0(LLV_DEBUG, q2);
+			printsaprop0(PLOG_DEBUG, q2);
 
 			pr = cmpsaprop_alloc(iph2->ph1, q1, q2, iph2->side);
 			if (pr != NULL)
 				goto found;
 
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"not matched\n");
 		}
 	}
@@ -1167,7 +1019,7 @@
 
 found:
 	flushsaprop(pr0);
-	plog(LLV_DEBUG, LOCATION, NULL, "matched\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "matched\n");
 	iph2->approval = pr;
 
     {
@@ -1198,7 +1050,7 @@
 
 		n = racoon_calloc(1, sizeof(struct prop_pair));
 		if (!n) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"failed to get buffer.\n");
 			goto err;
 		}
@@ -1247,16 +1099,12 @@
 {
 	struct prop_pair *p, *q, *r, *s;
 
-	p = pair;
-	while (p) {
+	for (p = pair; p; p = q) {
 		q = p->next;
-		r = p;
-		while (r) {
+		for (r = p; r; r = s) {
 			s = r->tnext;
 			racoon_free(r);
-			r = s;
 		}
-		p = q;
 	}
 }
 
@@ -1276,13 +1124,13 @@
 	int i;
 	struct ipsecdoi_sa_b *sab = (struct ipsecdoi_sa_b *)sa->v;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "total SA len=%zu\n", sa->l);
-	plogdump(LLV_DEBUG, sa->v, sa->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "total SA len=%d\n", sa->l);
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, sa->v, sa->l);
 
 	/* check SA payload size */
 	if (sa->l < sizeof(*sab)) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"Invalid SA length = %zu.\n", sa->l);
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
+			"Invalid SA length = %d.\n", sa->l);
 		return NULL;
 	}
 
@@ -1296,7 +1144,7 @@
 
 	pair = racoon_calloc(1, MAXPROPPAIRLEN * sizeof(*pair));
 	if (pair == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to get buffer.\n");
 		return NULL;
 	}
@@ -1320,7 +1168,7 @@
 	     pa++) {
 		/* check the value of next payload */
 		if (pa->type != ISAKMP_NPTYPE_P) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"Invalid payload type=%u\n", pa->type);
 			vfree(pbuf);
 			return NULL;
@@ -1329,11 +1177,11 @@
 		prop = (struct isakmp_pl_p *)pa->ptr;
 		proplen = pa->len;
 
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"proposal #%u len=%d\n", prop->p_no, proplen);
 
 		if (proplen == 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid proposal with length %d\n", proplen);
 			vfree(pbuf);
 			return NULL;
@@ -1341,7 +1189,7 @@
 
 		/* check Protocol ID */
 		if (!check_protocol[mode]) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"unsupported mode %d\n", mode);
 			continue;
 		}
@@ -1372,8 +1220,8 @@
 		if (!pair[i])
 			continue;
 
-		plog(LLV_DEBUG, LOCATION, NULL, "pair %d:\n", i);
-		print_proppair(LLV_DEBUG, pair[i]);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "pair %d:\n", i);
+		print_proppair(PLOG_DEBUG, pair[i]);
 
 		notrans = nprop = 0;
 		for (p = pair[i]; p; p = p->next) {
@@ -1391,7 +1239,7 @@
 		 * with multiple proposals.  this should be fixed.
 		 */
 		if (pair[i]->next) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(LLV_WARNING, PLOGLOC, NULL,
 				"proposal #%u ignored "
 				"(multiple proposal not supported)\n",
 				pair[i]->prop->p_no);
@@ -1407,7 +1255,7 @@
 			pair[i] = NULL;
 			num_p--;
 		} else {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"proposal #%u: %d transform\n",
 				pair[i]->prop->p_no, nprop);
 		}
@@ -1416,7 +1264,7 @@
 
 	/* bark if no proposal is found. */
 	if (num_p <= 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"no Proposal found.\n");
 		return NULL;
 	}
@@ -1462,7 +1310,7 @@
 
 		/* check the value of next payload */
 		if (pa->type != ISAKMP_NPTYPE_T) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"Invalid payload type=%u\n", pa->type);
 			break;
 		}
@@ -1470,18 +1318,18 @@
 		trns = (struct isakmp_pl_t *)pa->ptr;
 		trnslen = pa->len;
 
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"transform #%u len=%u\n", trns->t_no, trnslen);
 
 		/* check transform ID */
 		if (prop->proto_id >= ARRAYLEN(check_transform)) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"unsupported proto_id %u\n",
 				prop->proto_id);
 			continue;
 		}
 		if (prop->proto_id >= ARRAYLEN(check_attributes)) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"unsupported proto_id %u\n",
 				prop->proto_id);
 			continue;
@@ -1489,7 +1337,7 @@
 
 		if (!check_transform[prop->proto_id]
 		 || !check_attributes[prop->proto_id]) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"unsupported proto_id %u\n",
 				prop->proto_id);
 			continue;
@@ -1503,7 +1351,7 @@
 
 		p = racoon_calloc(1, sizeof(*p));
 		if (p == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"failed to get buffer.\n");
 			vfree(pbuf);
 			return -1;
@@ -1551,14 +1399,14 @@
 
 	newtlen = sizeof(struct ipsecdoi_sa_b);
 	for (p = pair; p; p = p->next) {
-		newtlen += sizeof(struct isakmp_pl_p);
-		newtlen += p->prop->spi_size;
-		newtlen += ntohs(p->trns->h.len);
+		newtlen += (sizeof(struct isakmp_pl_p)
+				+ p->prop->spi_size
+				+ ntohs(p->trns->h.len));
 	}
 
 	newsa = vmalloc(newtlen);
 	if (newsa == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, "failed to get newsa.\n");
+		plog(PLOG_PROTOERR, PLOGLOC, NULL, "failed to get newsa.\n");
 		return NULL;
 	}
 	bp = newsa->v;
@@ -1566,8 +1414,8 @@
 	((struct isakmp_gen *)bp)->len = htons(newtlen);
 
 	/* update some of values in SA header */
-	((struct ipsecdoi_sa_b *)bp)->doi = htonl(iph1->rmconf->doitype);
-	((struct ipsecdoi_sa_b *)bp)->sit = htonl(iph1->rmconf->sittype);
+	((struct ipsecdoi_sa_b *)bp)->doi = htonl(ikev1_doitype(iph1->rmconf));
+	((struct ipsecdoi_sa_b *)bp)->sit = htonl(ikev1_sittype(iph1->rmconf));
 	bp += sizeof(struct ipsecdoi_sa_b);
 
 	/* create proposal payloads */
@@ -1707,7 +1555,7 @@
 
 	newsa = vmalloc(newtlen);
 	if (newsa == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, "failed to get newsa.\n");
+		plog(PLOG_PROTOERR, PLOGLOC, NULL, "failed to get newsa.\n");
 		return NULL;
 	}
 	bp = newsa->v;
@@ -1780,8 +1628,8 @@
 		ld = ntohl(*(u_int32_t *)buf->v);
 		break;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"length %zu of life duration "
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
+			"length %d of life duration "
 			"isn't supported.\n", buf->l);
 		return 0;
 	}
@@ -1801,7 +1649,7 @@
 	case IPSEC_DOI:
 		return 0;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid value of DOI 0x%08x.\n", doi);
 		return -1;
 	}
@@ -1821,12 +1669,12 @@
 
 	case IPSECDOI_SIT_SECRECY:
 	case IPSECDOI_SIT_INTEGRITY:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"situation 0x%08x unsupported yet.\n", sit);
 		return -1;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid situation 0x%08x.\n", sit);
 		return -1;
 	}
@@ -1845,7 +1693,7 @@
 		return 0;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"Illegal protocol id=%u.\n", proto_id);
 		return -1;
 	}
@@ -1868,7 +1716,7 @@
 		return 0;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid protocol id %d.\n", proto_id);
 		return -1;
 	}
@@ -1883,7 +1731,7 @@
 	case IPSECDOI_PROTO_ISAKMP:
 		if (size != 0) {
 			/* WARNING */
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"SPI size isn't zero, but IKE proposal.\n");
 		}
 		return 0;
@@ -1891,7 +1739,7 @@
 	case IPSECDOI_PROTO_IPSEC_AH:
 	case IPSECDOI_PROTO_IPSEC_ESP:
 		if (size != 4) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid SPI size=%d for IPSEC proposal.\n",
 				size);
 			return -1;
@@ -1900,7 +1748,7 @@
 
 	case IPSECDOI_PROTO_IPCOMP:
 		if (size != 2 && size != 4) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid SPI size=%d for IPCOMP proposal.\n",
 				size);
 			return -1;
@@ -1925,7 +1773,7 @@
 	case IPSECDOI_KEY_IKE:
 		return 0;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid transform-id=%u in proto_id=%u.\n",
 			t_id, IPSECDOI_KEY_IKE);
 		return -1;
@@ -1943,16 +1791,13 @@
 	switch (t_id) {
 	case IPSECDOI_AH_MD5:
 	case IPSECDOI_AH_SHA:
-	case IPSECDOI_AH_SHA256:
-	case IPSECDOI_AH_SHA384:
-	case IPSECDOI_AH_SHA512:
 		return 0;
 	case IPSECDOI_AH_DES:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"not support transform-id=%u in AH.\n", t_id);
 		return -1;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid transform-id=%u in AH.\n", t_id);
 		return -1;
 	}
@@ -1973,7 +1818,7 @@
 	case IPSECDOI_ESP_RC5:
 	case IPSECDOI_ESP_CAST:
 	case IPSECDOI_ESP_BLOWFISH:
-	case IPSECDOI_ESP_AES:
+	/* case IPSECDOI_ESP_RIJNDAEL: */
 	case IPSECDOI_ESP_TWOFISH:
 		return 0;
 	case IPSECDOI_ESP_DES_IV32:
@@ -1981,11 +1826,11 @@
 	case IPSECDOI_ESP_IDEA:
 	case IPSECDOI_ESP_3IDEA:
 	case IPSECDOI_ESP_RC4:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"not support transform-id=%u in ESP.\n", t_id);
 		return -1;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid transform-id=%u in ESP.\n", t_id);
 		return -1;
 	}
@@ -2005,7 +1850,7 @@
 	case IPSECDOI_IPCOMP_LZS:
 		return 0;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid transform-id=%u in IPCOMP.\n", t_id);
 		return -1;
 	}
@@ -2032,7 +1877,7 @@
 		flag = ntohs(d->type) & ISAKMP_GEN_MASK;
 		lorv = ntohs(d->lorv);
 
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"type=%s, flag=0x%04x, lorv=%s\n",
 			s_oakley_attr(type), flag,
 			s_oakley_attr_v(type, lorv));
@@ -2052,7 +1897,7 @@
 		case OAKLEY_ATTR_KEY_LEN:
 		case OAKLEY_ATTR_FIELD_SIZE:
 			if (!flag) {	/* TLV*/
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"oakley attribute %d must be TV.\n",
 					type);
 				return -1;
@@ -2062,7 +1907,7 @@
 
 		/* sanity check for TLV.  length must be specified. */
 		if (!flag && lorv == 0) {	/*TLV*/
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid length %d for TLV attribute %d.\n",
 				lorv, type);
 			return -1;
@@ -2071,7 +1916,7 @@
 		switch (type) {
 		case OAKLEY_ATTR_ENC_ALG:
 			if (!alg_oakley_encdef_ok(lorv)) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalied encryption algorithm=%d.\n",
 					lorv);
 				return -1;
@@ -2080,7 +1925,7 @@
 
 		case OAKLEY_ATTR_HASH_ALG:
 			if (!alg_oakley_hashdef_ok(lorv)) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalied hash algorithm=%d.\n",
 					lorv);
 				return -1;
@@ -2091,37 +1936,17 @@
 			switch (lorv) {
 			case OAKLEY_ATTR_AUTH_METHOD_PSKEY:
 			case OAKLEY_ATTR_AUTH_METHOD_RSASIG:
-#ifdef ENABLE_HYBRID
-			case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_I:
-#if 0 /* Clashes with OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB */
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_I:
-#endif
-#endif
 			case OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB:
 				break;
 			case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
-#ifdef ENABLE_HYBRID
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_R:
-			case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_R:
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_R:
-			case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_I:
-			case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_R:
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_I:
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_R:
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_I:
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_R:
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_I:
-			case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_R:
-#endif
 			case OAKLEY_ATTR_AUTH_METHOD_RSAENC:
 			case OAKLEY_ATTR_AUTH_METHOD_RSAREV:
-				plog(LLV_ERROR, LOCATION, NULL,
-					"auth method %s isn't supported.\n",
-					s_oakley_attr_method(lorv));
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
+					"auth method %d isn't supported.\n",
+					lorv);
 				return -1;
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid auth method %d.\n",
 					lorv);
 				return -1;
@@ -2130,7 +1955,7 @@
 
 		case OAKLEY_ATTR_GRP_DESC:
 			if (!alg_oakley_dhdef_ok(lorv)) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid DH group %d.\n",
 					lorv);
 				return -1;
@@ -2142,7 +1967,7 @@
 			case OAKLEY_ATTR_GRP_TYPE_MODP:
 				break;
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"unsupported DH group type %d.\n",
 					lorv);
 				return -1;
@@ -2157,7 +1982,7 @@
 		case OAKLEY_ATTR_GRP_GEN_TWO:
 		case OAKLEY_ATTR_GRP_CURVE_A:
 		case OAKLEY_ATTR_GRP_CURVE_B:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"attr type=%u isn't supported.\n", type);
 			return -1;
 
@@ -2167,7 +1992,7 @@
 			case OAKLEY_ATTR_SA_LD_TYPE_KB:
 				break;
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid life type %d.\n", lorv);
 				return -1;
 			}
@@ -2182,7 +2007,7 @@
 			break;
 
 		case OAKLEY_ATTR_FIELD_SIZE:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"attr type=%u isn't supported.\n", type);
 			return -1;
 
@@ -2193,7 +2018,7 @@
 			break;
 
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid attribute type %d.\n", type);
 			return -1;
 		}
@@ -2249,18 +2074,18 @@
 		flag = ntohs(d->type) & ISAKMP_GEN_MASK;
 		lorv = ntohs(d->lorv);
 
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"type=%s, flag=0x%04x, lorv=%s\n",
 			s_ipsecdoi_attr(type), flag,
 			s_ipsecdoi_attr_v(type, lorv));
 
-		if (type < sizeof(attrseen)/sizeof(attrseen[0]))
+		if (type < ARRAYLEN(attrseen))
 			attrseen[type]++;
 
 		switch (type) {
 		case IPSECDOI_ATTR_ENC_MODE:
 			if (! flag) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"must be TV when ENC_MODE.\n");
 				return -1;
 			}
@@ -2269,17 +2094,8 @@
 			case IPSECDOI_ATTR_ENC_MODE_TUNNEL:
 			case IPSECDOI_ATTR_ENC_MODE_TRNS:
 				break;
-#ifdef ENABLE_NATT
-			case IPSECDOI_ATTR_ENC_MODE_UDPTUNNEL_RFC:
-			case IPSECDOI_ATTR_ENC_MODE_UDPTRNS_RFC:
-			case IPSECDOI_ATTR_ENC_MODE_UDPTUNNEL_DRAFT:
-			case IPSECDOI_ATTR_ENC_MODE_UDPTRNS_DRAFT:
-				plog(LLV_DEBUG, LOCATION, NULL,
-				     "UDP encapsulation requested\n");
-				break;
-#endif
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid encryption mode=%u.\n",
 					lorv);
 				return -1;
@@ -2288,7 +2104,7 @@
 
 		case IPSECDOI_ATTR_AUTH:
 			if (! flag) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"must be TV when AUTH.\n");
 				return -1;
 			}
@@ -2298,7 +2114,7 @@
 				if (proto_id == IPSECDOI_PROTO_IPSEC_AH &&
 				    trns->t_id != IPSECDOI_AH_MD5) {
 ahmismatch:
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"auth algorithm %u conflicts "
 						"with transform %u.\n",
 						lorv, trns->t_id);
@@ -2311,32 +2127,14 @@
 						goto ahmismatch;
 				}
 				break;
- 			case IPSECDOI_ATTR_AUTH_HMAC_SHA2_256:
- 				if (proto_id == IPSECDOI_PROTO_IPSEC_AH) {
- 					if (trns->t_id != IPSECDOI_AH_SHA256)
- 						goto ahmismatch;
- 				}	
- 				break;
- 			case IPSECDOI_ATTR_AUTH_HMAC_SHA2_384:
- 				if (proto_id == IPSECDOI_PROTO_IPSEC_AH) {
- 					if (trns->t_id != IPSECDOI_AH_SHA384)
- 						goto ahmismatch;
- 				}
- 				break;
- 			case IPSECDOI_ATTR_AUTH_HMAC_SHA2_512:
- 				if (proto_id == IPSECDOI_PROTO_IPSEC_AH) {
- 					if (trns->t_id != IPSECDOI_AH_SHA512)
- 					goto ahmismatch;
- 				}
- 				break;
 			case IPSECDOI_ATTR_AUTH_DES_MAC:
 			case IPSECDOI_ATTR_AUTH_KPDK:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"auth algorithm %u isn't supported.\n",
 					lorv);
 				return -1;
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid auth algorithm=%u.\n",
 					lorv);
 				return -1;
@@ -2345,7 +2143,7 @@
 
 		case IPSECDOI_ATTR_SA_LD_TYPE:
 			if (! flag) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"must be TV when LD_TYPE.\n");
 				return -1;
 			}
@@ -2355,7 +2153,7 @@
 			case IPSECDOI_ATTR_SA_LD_TYPE_KB:
 				break;
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid life type %d.\n", lorv);
 				return -1;
 			}
@@ -2364,12 +2162,12 @@
 		case IPSECDOI_ATTR_SA_LD:
 			if (flag) {
 				/* i.e. ISAKMP_GEN_TV */
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					"life duration was in TLV.\n");
 			} else {
 				/* i.e. ISAKMP_GEN_TLV */
 				if (lorv == 0) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"invalid length of LD\n");
 					return -1;
 				}
@@ -2378,13 +2176,13 @@
 
 		case IPSECDOI_ATTR_GRP_DESC:
 			if (! flag) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"must be TV when GRP_DESC.\n");
 				return -1;
 			}
 
 			if (!alg_oakley_dhdef_ok(lorv)) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid group description=%u.\n",
 					lorv);
 				return -1;
@@ -2393,7 +2191,7 @@
 
 		case IPSECDOI_ATTR_KEY_LENGTH:
 			if (! flag) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"must be TV when KEY_LENGTH.\n");
 				return -1;
 			}
@@ -2402,12 +2200,12 @@
 		case IPSECDOI_ATTR_KEY_ROUNDS:
 		case IPSECDOI_ATTR_COMP_DICT_SIZE:
 		case IPSECDOI_ATTR_COMP_PRIVALG:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"attr type=%u isn't supported.\n", type);
 			return -1;
 
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid attribute type %d.\n", type);
 			return -1;
 		}
@@ -2425,15 +2223,15 @@
 
 	if (proto_id == IPSECDOI_PROTO_IPSEC_AH &&
 	    !attrseen[IPSECDOI_ATTR_AUTH]) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"attr AUTH must be present for AH.\n");
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
+			"attr AUTH must be present for AH.\n", type);
 		return -1;
 	}
 
 	if (proto_id == IPSECDOI_PROTO_IPSEC_ESP &&
 	    trns->t_id == IPSECDOI_ESP_NULL &&
 	    !attrseen[IPSECDOI_ATTR_AUTH]) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 		    "attr AUTH must be present for ESP NULL encryption.\n");
 		return -1;
 	}
@@ -2460,17 +2258,17 @@
 		flag = ntohs(d->type) & ISAKMP_GEN_MASK;
 		lorv = ntohs(d->lorv);
 
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"type=%d, flag=0x%04x, lorv=0x%04x\n",
 			type, flag, lorv);
 
-		if (type < sizeof(attrseen)/sizeof(attrseen[0]))
+		if (type < ARRAYLEN(attrseen))
 			attrseen[type]++;
 
 		switch (type) {
 		case IPSECDOI_ATTR_ENC_MODE:
 			if (! flag) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"must be TV when ENC_MODE.\n");
 				return -1;
 			}
@@ -2479,17 +2277,8 @@
 			case IPSECDOI_ATTR_ENC_MODE_TUNNEL:
 			case IPSECDOI_ATTR_ENC_MODE_TRNS:
 				break;
-#ifdef ENABLE_NATT
-			case IPSECDOI_ATTR_ENC_MODE_UDPTUNNEL_RFC:
-			case IPSECDOI_ATTR_ENC_MODE_UDPTRNS_RFC:
-			case IPSECDOI_ATTR_ENC_MODE_UDPTUNNEL_DRAFT:
-			case IPSECDOI_ATTR_ENC_MODE_UDPTRNS_DRAFT:
-				plog(LLV_DEBUG, LOCATION, NULL,
-				     "UDP encapsulation requested\n");
-				break;
-#endif
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid encryption mode=%u.\n",
 					lorv);
 				return -1;
@@ -2498,7 +2287,7 @@
 
 		case IPSECDOI_ATTR_SA_LD_TYPE:
 			if (! flag) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"must be TV when LD_TYPE.\n");
 				return -1;
 			}
@@ -2508,7 +2297,7 @@
 			case IPSECDOI_ATTR_SA_LD_TYPE_KB:
 				break;
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid life type %d.\n", lorv);
 				return -1;
 			}
@@ -2517,12 +2306,12 @@
 		case IPSECDOI_ATTR_SA_LD:
 			if (flag) {
 				/* i.e. ISAKMP_GEN_TV */
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 					"life duration was in TLV.\n");
 			} else {
 				/* i.e. ISAKMP_GEN_TLV */
 				if (lorv == 0) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"invalid length of LD\n");
 					return -1;
 				}
@@ -2531,13 +2320,13 @@
 
 		case IPSECDOI_ATTR_GRP_DESC:
 			if (! flag) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"must be TV when GRP_DESC.\n");
 				return -1;
 			}
 
 			if (!alg_oakley_dhdef_ok(lorv)) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid group description=%u.\n",
 					lorv);
 				return -1;
@@ -2545,7 +2334,7 @@
 			break;
 
 		case IPSECDOI_ATTR_AUTH:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid attr type=%u.\n", type);
 			return -1;
 
@@ -2553,12 +2342,12 @@
 		case IPSECDOI_ATTR_KEY_ROUNDS:
 		case IPSECDOI_ATTR_COMP_DICT_SIZE:
 		case IPSECDOI_ATTR_COMP_PRIVALG:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"attr type=%u isn't supported.\n", type);
 			return -1;
 
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid attribute type %d.\n", type);
 			return -1;
 		}
@@ -2577,7 +2366,7 @@
 #if 0
 	if (proto_id == IPSECDOI_PROTO_IPCOMP &&
 	    !attrseen[IPSECDOI_ATTR_AUTH]) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"attr AUTH must be present for AH.\n", type);
 		return -1;
 	}
@@ -2605,15 +2394,15 @@
 
 	mysa = vmalloc(sablen);
 	if (mysa == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to allocate my sa buffer\n");
 		return NULL;
 	}
 
 	/* create SA payload */
 	/* not including isakmp general header */
-	((struct ipsecdoi_sa_b *)mysa->v)->doi = htonl(props->rmconf->doitype);
-	((struct ipsecdoi_sa_b *)mysa->v)->sit = htonl(props->rmconf->sittype);
+	((struct ipsecdoi_sa_b *)mysa->v)->doi = htonl(ikev1_doitype(props->rmconf));
+	((struct ipsecdoi_sa_b *)mysa->v)->sit = htonl(ikev1_sittype(props->rmconf));
 
 	(void)setph1prop(props, mysa->v + sizeof(struct ipsecdoi_sa_b));
 
@@ -2710,19 +2499,17 @@
 	int attrlen = 0;
 
 	if (sa->lifetime) {
-		u_int32_t lifetime = htonl((u_int32_t)sa->lifetime);
-
 		attrlen += sizeof(struct isakmp_data)
 			+ sizeof(struct isakmp_data);
 		if (sa->lifetime > 0xffff)
-			attrlen += sizeof(lifetime);
+			attrlen += sizeof(sa->lifetime);
 		if (buf) {
 			p = isakmp_set_attr_l(p, OAKLEY_ATTR_SA_LD_TYPE,
 						OAKLEY_ATTR_SA_LD_TYPE_SEC);
 			if (sa->lifetime > 0xffff) {
+				u_int32_t v = htonl((u_int32_t)sa->lifetime);
 				p = isakmp_set_attr_v(p, OAKLEY_ATTR_SA_LD,
-						(caddr_t)&lifetime, 
-						sizeof(lifetime));
+						(caddr_t)&v, sizeof(v));
 			} else {
 				p = isakmp_set_attr_l(p, OAKLEY_ATTR_SA_LD,
 							sa->lifetime);
@@ -2731,19 +2518,17 @@
 	}
 
 	if (sa->lifebyte) {
-		u_int32_t lifebyte = htonl((u_int32_t)sa->lifebyte);
-		
 		attrlen += sizeof(struct isakmp_data)
 			+ sizeof(struct isakmp_data);
 		if (sa->lifebyte > 0xffff)
-			attrlen += sizeof(lifebyte);
+			attrlen += sizeof(sa->lifebyte);
 		if (buf) {
 			p = isakmp_set_attr_l(p, OAKLEY_ATTR_SA_LD_TYPE,
 						OAKLEY_ATTR_SA_LD_TYPE_KB);
 			if (sa->lifebyte > 0xffff) {
+				u_int32_t v = htonl((u_int32_t)sa->lifebyte);
 				p = isakmp_set_attr_v(p, OAKLEY_ATTR_SA_LD,
-							(caddr_t)&lifebyte,
-							sizeof(lifebyte));
+							(caddr_t)&v, sizeof(v));
 			} else {
 				p = isakmp_set_attr_l(p, OAKLEY_ATTR_SA_LD,
 							sa->lifebyte);
@@ -2762,16 +2547,9 @@
 			p = isakmp_set_attr_l(p, OAKLEY_ATTR_KEY_LEN, sa->encklen);
 	}
 	if (sa->authmethod) {
-		int authmethod;
-
-#ifdef ENABLE_HYBRID
-		authmethod = switch_authmethod(sa->authmethod);
-#else
-		authmethod = sa->authmethod;
-#endif
 		attrlen += sizeof(struct isakmp_data);
 		if (buf)
-			p = isakmp_set_attr_l(p, OAKLEY_ATTR_AUTH_METHOD, authmethod);
+			p = isakmp_set_attr_l(p, OAKLEY_ATTR_AUTH_METHOD, sa->authmethod);
 	}
 	if (sa->hashtype) {
 		attrlen += sizeof(struct isakmp_data);
@@ -2812,77 +2590,16 @@
 	if (sa->authmethod == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB &&
 	    sa->gssid != NULL) {
 		attrlen += sizeof(struct isakmp_data);
-		/*
-		 * Older versions of racoon just placed the ISO-Latin-1
-		 * string on the wire directly.  Check to see if we are
-		 * configured to be compatible with this behavior.  Otherwise,
-		 * we encode the GSS ID as UTF-16LE for Windows 2000
-		 * compatibility, which requires twice the number of octets.
-		 */
-		if (lcconf->gss_id_enc == LC_GSSENC_LATIN1)
-			attrlen += sa->gssid->l;
-		else
-			attrlen += sa->gssid->l * 2;
+		attrlen += sa->gssid->l;
 		if (buf) {
-			plog(LLV_DEBUG, LOCATION, NULL, "gss id attr: len %d, "
-			    "val '%.*s'\n", sa->gssid->l, sa->gssid->l,
-			    sa->gssid->v);
-			if (lcconf->gss_id_enc == LC_GSSENC_LATIN1) {
-				p = isakmp_set_attr_v(p, OAKLEY_ATTR_GSS_ID,
-					(caddr_t)sa->gssid->v,
-					sa->gssid->l);
-			} else {
-				size_t dstleft = sa->gssid->l * 2;
-				size_t srcleft = sa->gssid->l;
-				const char *src = (const char *)sa->gssid->v;
-				char *odst, *dst = racoon_malloc(dstleft);
-				iconv_t cd;
-				size_t rv;
-
-				cd = iconv_open("utf-16le", "latin1");
-				if (cd == (iconv_t) -1) {
-					plog(LLV_ERROR, LOCATION, NULL,
-					    "unable to initialize "
-					    "latin1 -> utf-16le "
-					    "converstion descriptor: %s\n",
-					    strerror(errno));
-					attrlen -= sa->gssid->l * 2;
-					goto gssid_done;
-				}
-				odst = dst;
-				rv = iconv(cd, (__iconv_const char **)&src, 
-				    &srcleft, &dst, &dstleft);
-				if (rv != 0) {
-					if (rv == -1) {
-						plog(LLV_ERROR, LOCATION, NULL,
-						    "unable to convert GSS ID "
-						    "from latin1 -> utf-16le: "
-						    "%s\n", strerror(errno));
-					} else {
-						/* should never happen */
-						plog(LLV_ERROR, LOCATION, NULL,
-						    "%zd character%s in GSS ID "
-						    "cannot be represented "
-						    "in utf-16le\n",
-						    rv, rv == 1 ? "" : "s");
-					}
-					(void) iconv_close(cd);
-					attrlen -= sa->gssid->l * 2;
-					goto gssid_done;
-				}
-				(void) iconv_close(cd);
-
-				/* XXX Check srcleft and dstleft? */
-
-				p = isakmp_set_attr_v(p, OAKLEY_ATTR_GSS_ID,
-					odst, sa->gssid->l * 2);
-
-				racoon_free(odst);
-			}
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "gss id attr: len %d, "
+			    "val '%s'\n", sa->gssid->l, sa->gssid->v);
+			p = isakmp_set_attr_v(p, OAKLEY_ATTR_GSS_ID,
+				(caddr_t)sa->gssid->v, 
+				sa->gssid->l);
 		}
 	}
- gssid_done:
-#endif /* HAVE_GSSAPI */
+#endif
 
 	return attrlen;
 }
@@ -2984,7 +2701,7 @@
 			break;
 		case IPSECDOI_PROTO_IPSEC_AH:
 			if (tr->authtype == IPSECDOI_ATTR_AUTH_NONE) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"no authentication algorithm found "
 					"but protocol is AH.\n");
 				vfree(p);
@@ -2995,7 +2712,7 @@
 		case IPSECDOI_PROTO_IPCOMP:
 			break;
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid protocol: %d\n", pr->proto_id);
 			vfree(p);
 			return NULL;
@@ -3069,7 +2786,7 @@
 	}
 
 	if (np_t == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"no suitable proposal was created.\n");
 		return NULL;
 	}
@@ -3100,7 +2817,7 @@
 
 	iph2->sa = vmalloc(sizeof(*sab));
 	if (iph2->sa == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to allocate my sa buffer\n");
 		return -1;
 	}
@@ -3114,20 +2831,6 @@
 	propoff = 0;
 	for (a = proposal; a; a = a->next) {
 		for (b = a->head; b; b = b->next) {
-#ifdef ENABLE_NATT
-			if (iph2->ph1->natt_flags & NAT_DETECTED) {
-			  int udp_diff = iph2->ph1->natt_options->mode_udp_diff;
-			  plog (LLV_INFO, LOCATION, NULL,
-				"NAT detected -> UDP encapsulation "
-				"(ENC_MODE %d->%d).\n",
-				b->encmode,
-				b->encmode+udp_diff);
-			  /* Tunnel -> UDP-Tunnel, Transport -> UDP_Transport */
-			  b->encmode += udp_diff;
-			  b->udp_encap = 1;
-			}
-#endif
-
 			q = setph2proposal0(iph2, a, b);
 			if (q == NULL) {
 				VPTRINIT(iph2->sa);
@@ -3136,7 +2839,7 @@
 
 			iph2->sa = vrealloc(iph2->sa, iph2->sa->l + q->l);
 			if (iph2->sa == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"failed to allocate my sa buffer\n");
 				if (q)
 					vfree(q);
@@ -3190,7 +2893,7 @@
 	switch (proto_id) {
 	case IPSECDOI_PROTO_IPSEC_ESP:
 		if (enc == 0 || comp != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"illegal algorithm defined "
 				"ESP enc=%s auth=%s comp=%s.\n",
 				TMPALGTYPE2STR(enc),
@@ -3201,7 +2904,7 @@
 		break;
 	case IPSECDOI_PROTO_IPSEC_AH:
 		if (enc != 0 || auth == 0 || comp != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"illegal algorithm defined "
 				"AH enc=%s auth=%s comp=%s.\n",
 				TMPALGTYPE2STR(enc),
@@ -3212,7 +2915,7 @@
 		break;
 	case IPSECDOI_PROTO_IPCOMP:
 		if (enc != 0 || auth != 0 || comp == 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"illegal algorithm defined "
 				"IPcomp enc=%s auth=%s comp=%s.\n",
 				TMPALGTYPE2STR(enc),
@@ -3222,7 +2925,7 @@
 		}
 		break;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid ipsec protocol %d\n", proto_id);
 		return -1;
 	}
@@ -3275,16 +2978,18 @@
 	struct ph1handle *iph1;
 {
 	struct ipsecdoi_id_b *id_b;
+#if 0
 	struct sockaddr *sa;
 	caddr_t sa1, sa2;
+#endif
 
 	if (iph1->id_p == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid iph1 passed id_p == NULL\n");
 		return ISAKMP_INTERNAL_ERROR;
 	}
 	if (iph1->id_p->l < sizeof(*id_b)) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid value passed as \"ident\" (len=%lu)\n",
 			(u_long)iph1->id_p->l);
 		return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
@@ -3297,7 +3002,7 @@
 	    iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_PSKEY) {
 		 if (id_b->type != IPSECDOI_ID_IPV4_ADDR
 		  && id_b->type != IPSECDOI_ID_IPV6_ADDR) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"Expecting IP address type in main mode, "
 				"but %s.\n", s_ipsecdoi_ident(id_b->type));
 			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
@@ -3310,9 +3015,9 @@
 	case IPSECDOI_ID_IPV6_ADDR_SUBNET:
 	case IPSECDOI_ID_IPV4_ADDR_RANGE:
 	case IPSECDOI_ID_IPV6_ADDR_RANGE:
-		plog(LLV_WARNING, LOCATION, NULL,
-			"such ID type %s is not proper.\n",
-			s_ipsecdoi_ident(id_b->type));
+		plog(PLOG_PROTOWARN, PLOGLOC, 0,
+		     "peer ID type %s is not acceptable\n",
+		     s_ipsecdoi_ident(id_b->type));
 		/*FALLTHROUGH*/
 	}
 
@@ -3321,7 +3026,7 @@
 	    id_b->type == IPSECDOI_ID_IPV6_ADDR) {
 
 		if (id_b->proto_id == 0 && ntohs(id_b->port) != 0) {
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
 				"protocol ID and Port mismatched. "
 				"proto_id:%d port:%d\n",
 				id_b->proto_id, ntohs(id_b->port));
@@ -3346,13 +3051,13 @@
 					break;
 #endif
 				default:
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"invalid family: %d\n",
 						iph1->remote->sa_family);
 					return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 				}
 				if (ntohs(id_b->port) != port) {
-					plog(LLV_WARNING, LOCATION, NULL,
+					plog(PLOG_PROTOWARN, PLOGLOC, 0,
 						"port %d expected, but %d\n",
 						port, ntohs(id_b->port));
 					/*FALLTHROUGH*/
@@ -3362,72 +3067,26 @@
 	}
 
 	/* compare with the ID if specified. */
-	if (genlist_next(iph1->rmconf->idvl_p, 0)) {
-		vchar_t *ident0 = NULL;
-		vchar_t ident;
-		struct idspec *id;
-		struct genlist_entry *gpb;
-
-		for (id = genlist_next (iph1->rmconf->idvl_p, &gpb); id; id = genlist_next (0, &gpb)) {
-			/* check the type of both IDs */
-			if (id->idtype != doi2idtype(id_b->type))
-				continue;  /* ID type mismatch */
-			if (id->id == 0)
-				goto matched;
-
-			/* compare defined ID with the ID sent by peer. */
-			if (ident0 != NULL)
-				vfree(ident0);
-			ident0 = getidval(id->idtype, id->id);
-
-			switch (id->idtype) {
-			case IDTYPE_ASN1DN:
-				ident.v = (caddr_t)(id_b + 1);
-				ident.l = iph1->id_p->l - 1; /* had ident.l = ident0->l; but why?? */
-				      /* is the actual packet contents length sometimes wrong? */
-				if (eay_cmp_asn1dn(ident0, &ident) == 0)
-					goto matched;
-				break;
-			case IDTYPE_ADDRESS:
-				sa = (struct sockaddr *)ident0->v;
-				sa2 = (caddr_t)(id_b + 1);
-				switch (sa->sa_family) {
-				case AF_INET:
-					if (iph1->id_p->l - sizeof(*id_b) != sizeof(struct in_addr))
-						continue;  /* ID value mismatch */
-					sa1 = (caddr_t)&((struct sockaddr_in *)sa)->sin_addr;
-					if (memcmp(sa1, sa2, sizeof(struct in_addr)) == 0)
-						goto matched;
-					break;
-#ifdef INET6
-				case AF_INET6:
-					if (iph1->id_p->l - sizeof(*id_b) != sizeof(struct in6_addr))
-						continue;  /* ID value mismatch */
-					sa1 = (caddr_t)&((struct sockaddr_in6 *)sa)->sin6_addr;
-					if (memcmp(sa1, sa2, sizeof(struct in6_addr)) == 0)
-						goto matched;
-					break;
-#endif
-				default:
-					break;
-				}
-				break;
-			default:
-				if (memcmp(ident0->v, id_b + 1, ident0->l) == 0)
-					goto matched;
-				break;
+	if (ikev1_peers_id(iph1->rmconf)) {
+		rc_type rc_id_type;
+		vchar_t *id_data;
+
+		/* check the type of both IDs */
+		id_data = ikev1_id2rct_id(id_b, &rc_id_type);
+		if (!id_data) {
+			plog(PLOG_INTERR, PLOGLOC, 0,
+			     "failed allocating memory\n");
+			return ISAKMP_NTYPE_INVALID_ID_INFORMATION; /* ??? */
+		}
+		if (ike_compare_id(rc_id_type, id_data, ikev1_peers_id(iph1->rmconf)) != 0) {
+			if (ikev1_verify_id(iph1->rmconf) == RCT_BOOL_ON) {
+				plog(PLOG_PROTOERR, PLOGLOC, 0,
+				     "peer identifier does not match\n");
+				return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 			}
+			plog(PLOG_PROTOWARN, PLOGLOC, 0,
+			     "peer identifier does not match\n");
 		}
-		if (ident0 != NULL) {
-			vfree(ident0);
-			ident0 = NULL;
-		}
-		plog(LLV_WARNING, LOCATION, NULL, "No ID match.\n");
-		if (iph1->rmconf->verify_identifier)
-			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
-matched: /* ID value match */
-		if (ident0 != NULL)
-			vfree(ident0);
 	}
 
 	return 0;
@@ -3442,121 +3101,45 @@
 ipsecdoi_setid1(iph1)
 	struct ph1handle *iph1;
 {
-	vchar_t *ret = NULL;
+	struct rc_idlist *id;
+	vchar_t *id_data = 0;
+	int id_type;
 	struct ipsecdoi_id_b id_b;
-	vchar_t *ident = NULL;
-	struct sockaddr *ipid = NULL;
+	vchar_t *ret;
+
+	id = ikev1_my_id(iph1->rmconf);
+	id_data = ike_identifier_data(id, &id_type);
+	if (!id_data)
+		goto err;
 
 	/* init */
+	id_b.type = id_type;
 	id_b.proto_id = 0;
 	id_b.port = 0;
-	ident = NULL;
-
-	switch (iph1->rmconf->idvtype) {
-	case IDTYPE_FQDN:
-		id_b.type = IPSECDOI_ID_FQDN;
-		ident = getidval(iph1->rmconf->idvtype, iph1->rmconf->idv);
-		break;
-	case IDTYPE_USERFQDN:
-		id_b.type = IPSECDOI_ID_USER_FQDN;
-		ident = getidval(iph1->rmconf->idvtype, iph1->rmconf->idv);
-		break;
-	case IDTYPE_KEYID:
-		id_b.type = IPSECDOI_ID_KEY_ID;
-		ident = getidval(iph1->rmconf->idvtype, iph1->rmconf->idv);
-		break;
-	case IDTYPE_ASN1DN:
-		id_b.type = IPSECDOI_ID_DER_ASN1_DN;
-		if (iph1->rmconf->idv) {
-			/* XXX it must be encoded to asn1dn. */
-			ident = vdup(iph1->rmconf->idv);
-		} else {
-			if (oakley_getmycert(iph1) < 0) {
-				plog(LLV_ERROR, LOCATION, NULL,
-					"failed to get own CERT.\n");
-				goto err;
-			}
-			ident = eay_get_x509asn1subjectname(&iph1->cert->cert);
-		}
-		break;
-	case IDTYPE_ADDRESS:
-		/*
-		 * if the value of the id type was set by the configuration
-		 * file, then use it.  otherwise the value is get from local
-		 * ip address by using ike negotiation.
-		 */
-		if (iph1->rmconf->idv)
-			ipid = (struct sockaddr *)iph1->rmconf->idv->v;
-		/*FALLTHROUGH*/
-	default:
-	    {
-		int l;
-		caddr_t p;
 
-		if (ipid == NULL)
-			ipid = iph1->local;
-
-		/* use IP address */
-		switch (ipid->sa_family) {
-		case AF_INET:
-			id_b.type = IPSECDOI_ID_IPV4_ADDR;
-			l = sizeof(struct in_addr);
-			p = (caddr_t)&((struct sockaddr_in *)ipid)->sin_addr;
-			break;
-#ifdef INET6
-		case AF_INET6:
-			id_b.type = IPSECDOI_ID_IPV6_ADDR;
-			l = sizeof(struct in6_addr);
-			p = (caddr_t)&((struct sockaddr_in6 *)ipid)->sin6_addr;
-			break;
-#endif
-		default:
-			plog(LLV_ERROR, LOCATION, NULL,
-				"invalid address family.\n");
-			goto err;
-		}
-		id_b.proto_id = IPPROTO_UDP;
-		id_b.port = htons(PORT_ISAKMP);
-		ident = vmalloc(l);
-		if (!ident) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"failed to get ID buffer.\n");
-			return 0;
-		}
-		memcpy(ident->v, p, ident->l);
-	    }
-	}
-	if (!ident) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"failed to get ID buffer.\n");
-		return 0;
-	}
-
-	ret = vmalloc(sizeof(id_b) + ident->l);
-	if (ret == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"failed to get ID buffer.\n");
+	ret = vmalloc(sizeof(id_b) + id_data->l);
+	if (ret == NULL)
 		goto err;
-	}
 
 	memcpy(ret->v, &id_b, sizeof(id_b));
-	memcpy(ret->v + sizeof(id_b), ident->v, ident->l);
+	memcpy(ret->v + sizeof(id_b), id_data->v, id_data->l);
 
 	iph1->id = ret;
 
-	plog(LLV_DEBUG, LOCATION, NULL,
-		"use ID type of %s\n", s_ipsecdoi_ident(id_b.type));
-	if (ident)
-		vfree(ident);
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
+	     "using ID type %s\n", s_ipsecdoi_ident(id_b.type));
+	if (id_data)
+		vfree(id_data);
 	return 0;
 
 err:
-	if (ident)
-		vfree(ident);
-	plog(LLV_ERROR, LOCATION, NULL, "failed get my ID\n");
+	if (id_data)
+		vfree(id_data);
+	plog(PLOG_INTERR, PLOGLOC, NULL, "failed constructing my ID\n");
 	return -1;
 }
 
+#if 0
 static vchar_t *
 getidval(type, val)
 	int type;
@@ -3571,42 +3154,24 @@
 
 	return new;
 }
+#endif
 
+#if 0
 /* it's only called by cfparse.y. */
 int
 set_identifier(vpp, type, value)
 	vchar_t **vpp, *value;
 	int type;
 {
-	return set_identifier_qual(vpp, type, value, IDQUAL_UNSPEC);
-}
-
-int
-set_identifier_qual(vpp, type, value, qual)
-	vchar_t **vpp, *value;
-	int type;
-	int qual;
-{
 	vchar_t *new = NULL;
 
 	/* simply return if value is null. */
-	if (!value){
-		if( type == IDTYPE_FQDN || type == IDTYPE_USERFQDN){
-			plog(LLV_ERROR, LOCATION, NULL,
-				 "No %s\n", type == IDTYPE_FQDN ? "fqdn":"user fqdn");
-			return -1;
-		}
+	if (!value)
 		return 0;
-	}
 
 	switch (type) {
 	case IDTYPE_FQDN:
 	case IDTYPE_USERFQDN:
-		if(value->l <= 1){
-			plog(LLV_ERROR, LOCATION, NULL,
-				 "Empty %s\n", type == IDTYPE_FQDN ? "fqdn":"user fqdn");
-			return -1;
-		}
 		/* length is adjusted since QUOTEDSTRING teminates NULL. */
 		new = vmalloc(value->l - 1);
 		if (new == NULL)
@@ -3614,54 +3179,31 @@
 		memcpy(new->v, value->v, new->l);
 		break;
 	case IDTYPE_KEYID:
-		/* 
-		 * If no qualifier is specified: IDQUAL_UNSPEC. It means
-		 * to use a file for backward compatibility sake. 
-		 */
-		switch(qual) {
-		case IDQUAL_FILE:
-		case IDQUAL_UNSPEC: {
-			FILE *fp;
-			char b[512];
-			int tlen, len;
-
-			fp = fopen(value->v, "r");
-			if (fp == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
-					"can not open %s\n", value->v);
+	{
+		FILE *fp;
+		char b[512];
+		int tlen, len;
+
+		fp = fopen(value->v, "r");
+		if (fp == NULL) {
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
+				"can not open %s\n", value->v);
+			return -1;
+		}
+		tlen = 0;
+		while ((len = fread(b, 1, sizeof(b), fp)) != 0) {
+			new = vrealloc(new, tlen + len);
+			if (!new) {
+				fclose(fp);
 				return -1;
 			}
-			tlen = 0;
-			while ((len = fread(b, 1, sizeof(b), fp)) != 0) {
-				new = vrealloc(new, tlen + len);
-				if (!new) {
-					fclose(fp);
-					return -1;
-				}
-				memcpy(new->v + tlen, b, len);
-				tlen += len;
-			}
-			break;
-		}
-
-		case IDQUAL_TAG:
-			new = vmalloc(value->l - 1);
-			if (new == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
-					"can not allocate memory");
-				return -1;
-			}
-			memcpy(new->v, value->v, new->l);
-			break;
-
-		default:
-			plog(LLV_ERROR, LOCATION, NULL,
-				"unknown qualifier");
-			return -1;
+			memcpy(new->v + tlen, b, len);
+			tlen += len;
 		}
 		break;
-	
-	case IDTYPE_ADDRESS: {
+	}
+	case IDTYPE_ADDRESS:
+	{
 		struct sockaddr *sa;
 
 		/* length is adjusted since QUOTEDSTRING teminates NULL. */
@@ -3670,48 +3212,21 @@
 
 		sa = str2saddr(value->v, NULL);
 		if (sa == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid ip address %s\n", value->v);
 			return -1;
 		}
 
-		new = vmalloc(sysdep_sa_len(sa));
+		new = vmalloc(sa->sa_len);
 		if (new == NULL)
 			return -1;
 		memcpy(new->v, sa, new->l);
 		break;
 	}
 	case IDTYPE_ASN1DN:
-		if (value->v[0] == '~')
-			/* Hex-encoded ASN1 strings */
-			new = eay_hex2asn1dn(value->v + 1, - 1);
-		else
-			/* DN encoded strings */
-			new = eay_str2asn1dn(value->v, value->l - 1);
-
+		new = eay_str2asn1dn(value->v, value->l - 1);
 		if (new == NULL)
 			return -1;
-
-		if (loglevel >= LLV_DEBUG) {
-			X509_NAME *xn;
-			BIO *bio;
-			unsigned char *ptr = (unsigned char *) new->v, *buf;
-			size_t len;
-			char save;
-
-			xn = d2i_X509_NAME(NULL, (void *)&ptr, new->l);
-			bio = BIO_new(BIO_s_mem());
-			
-			X509_NAME_print_ex(bio, xn, 0, 0);
-			len = BIO_get_mem_data(bio, &ptr);
-			save = ptr[len];
-			ptr[len] = 0;
-			plog(LLV_DEBUG, LOCATION, NULL, "Parsed DN: %s\n", ptr);
-			ptr[len] = save;
-			X509_NAME_free(xn);
-			BIO_free(bio);
-		}
-
 		break;
 	}
 
@@ -3719,6 +3234,7 @@
 
 	return 0;
 }
+#endif
 
 /*
  * create ID payload for phase 2, and set into iph2->id and id_p.  There are
@@ -3731,38 +3247,37 @@
 ipsecdoi_setid2(iph2)
 	struct ph2handle *iph2;
 {
-	struct secpolicy *sp;
+	struct rcf_selector *sel;
+	int proto;
 
 	/* check there is phase 2 handler ? */
-	sp = getspbyspid(iph2->spid);
-	if (sp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"no policy found for spid:%u.\n", iph2->spid);
-		return -1;
-	}
+	sel = iph2->selector;
+	assert(sel->src->type == RCT_ADDR_INET);
+	assert(sel->dst->type == RCT_ADDR_INET);
+	proto = sel->upper_layer_protocol;
+	if (proto == RC_PROTO_ANY)
+		proto = 0;
 
-	iph2->id = ipsecdoi_sockaddr2id((struct sockaddr *)&sp->spidx.src,
-					sp->spidx.prefs, sp->spidx.ul_proto);
+	iph2->id = ipsecdoi_sockaddr2id(sel->src->a.ipaddr, sel->src->prefixlen, proto);
 	if (iph2->id == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"failed to get ID for %s\n",
-			spidx2str(&sp->spidx));
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
+		     "failed to create ID payload for %s\n",
+		     vmem2str(sel->sl_index));
 		return -1;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "use local ID type %s\n",
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "use local ID type %s\n",
 		s_ipsecdoi_ident(((struct ipsecdoi_id_b *)iph2->id->v)->type));
 
 	/* remote side */
-	iph2->id_p = ipsecdoi_sockaddr2id((struct sockaddr *)&sp->spidx.dst,
-				sp->spidx.prefd, sp->spidx.ul_proto);
+	iph2->id_p = ipsecdoi_sockaddr2id(sel->dst->a.ipaddr, sel->dst->prefixlen, proto);
 	if (iph2->id_p == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"failed to get ID for %s\n",
-			spidx2str(&sp->spidx));
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
+		     "failed to create ID payload for %s\n",
+		     vmem2str(sel->sl_index));
 		VPTRINIT(iph2->id);
 		return -1;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"use remote ID type %s\n",
 		s_ipsecdoi_ident(((struct ipsecdoi_id_b *)iph2->id_p->v)->type));
 
@@ -3791,7 +3306,7 @@
 	switch (saddr->sa_family) {
 	case AF_INET:
 		len1 = sizeof(struct in_addr);
-		if (prefixlen == ~0) {
+		if (prefixlen == (sizeof(struct in_addr) << 3)) {
 			type = IPSECDOI_ID_IPV4_ADDR;
 			len2 = 0;
 		} else {
@@ -3804,7 +3319,7 @@
 #ifdef INET6
 	case AF_INET6:
 		len1 = sizeof(struct in6_addr);
-		if (prefixlen == ~0) {
+		if (prefixlen == (sizeof(struct in6_addr) << 3)) {
 			type = IPSECDOI_ID_IPV6_ADDR;
 			len2 = 0;
 		} else {
@@ -3816,7 +3331,7 @@
 		break;
 #endif
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid family: %d.\n", saddr->sa_family);
 		return NULL;
 	}
@@ -3824,7 +3339,7 @@
 	/* get ID buffer */
 	new = vmalloc(sizeof(struct ipsecdoi_id_b) + len1 + len2);
 	if (new == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to get ID buffer.\n");
 		return NULL;
 	}
@@ -3849,8 +3364,7 @@
 
 	/* set prefix */
 	if (len2) {
-		u_char *p = (unsigned char *) new->v + 
-			sizeof(struct ipsecdoi_id_b) + len1;
+		u_char *p = new->v + sizeof(struct ipsecdoi_id_b) + len1;
 		u_int bits = prefixlen;
 
 		while (bits >= 8) {
@@ -3890,9 +3404,7 @@
 	switch (id_b->type) {
 	case IPSECDOI_ID_IPV4_ADDR:
 	case IPSECDOI_ID_IPV4_ADDR_SUBNET:
-#ifndef __linux__
 		saddr->sa_len = sizeof(struct sockaddr_in);
-#endif
 		saddr->sa_family = AF_INET;
 		((struct sockaddr_in *)saddr)->sin_port =
 			(id_b->port == 0
@@ -3904,9 +3416,7 @@
 #ifdef INET6
 	case IPSECDOI_ID_IPV6_ADDR:
 	case IPSECDOI_ID_IPV6_ADDR_SUBNET:
-#ifndef __linux__
 		saddr->sa_len = sizeof(struct sockaddr_in6);
-#endif
 		saddr->sa_family = AF_INET6;
 		((struct sockaddr_in6 *)saddr)->sin6_port =
 			(id_b->port == 0
@@ -3917,7 +3427,7 @@
 		break;
 #endif
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"unsupported ID type %d\n", id_b->type);
 		return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 	}
@@ -3960,7 +3470,7 @@
 		plen = 0;
 		max = alen <<3;
 
-		p = (unsigned char *) buf->v
+		p = buf->v
 			+ sizeof(struct ipsecdoi_id_b)
 			+ alen;
 
@@ -4044,7 +3554,7 @@
 		type = ntohs(d->type) & ~ISAKMP_GEN_MASK;
 		flag = ntohs(d->type) & ISAKMP_GEN_MASK;
 
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"type=%s, flag=0x%04x, lorv=%s\n",
 			s_ipsecdoi_attr(type), flag,
 			s_ipsecdoi_attr_v(type, ntohs(d->lorv)));
@@ -4059,9 +3569,9 @@
 				life_t = type;
 				break;
 			default:
-				plog(LLV_WARNING, LOCATION, NULL,
+				plog(PLOG_PROTOWARN, PLOGLOC, 0,
 					"invalid life duration type. "
-					"use default\n");
+					"using default value.\n");
 				life_t = IPSECDOI_ATTR_SA_LD_TYPE_DEFAULT;
 				break;
 			}
@@ -4071,7 +3581,7 @@
 			if (prev == NULL
 			 || (ntohs(prev->type) & ~ISAKMP_GEN_MASK) !=
 					IPSECDOI_ATTR_SA_LD_TYPE) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				    "life duration must follow ltype\n");
 				break;
 			}
@@ -4084,7 +3594,7 @@
 				/* i.e. ISAKMP_GEN_TV */
 				ld_buf = vmalloc(sizeof(d->lorv));
 				if (ld_buf == NULL) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					    "failed to get LD buffer.\n");
 					goto end;
 				}
@@ -4094,7 +3604,7 @@
 				/* i.e. ISAKMP_GEN_TLV */
 				ld_buf = vmalloc(len);
 				if (ld_buf == NULL) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					    "failed to get LD buffer.\n");
 					goto end;
 				}
@@ -4105,7 +3615,7 @@
 				t = ipsecdoi_set_ld(ld_buf);
 				vfree(ld_buf);
 				if (t == 0) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"invalid life duration.\n");
 					goto end;
 				}
@@ -4113,11 +3623,11 @@
 				if (pp->lifetime == IPSECDOI_ATTR_SA_LD_SEC_DEFAULT)
 					pp->lifetime = t;
 				else if (pp->lifetime != t) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"lifetime mismatched "
 						"in a proposal, "
-						"prev:%ld curr:%u.\n",
-						(long)pp->lifetime, t);
+						"prev:%ld curr:%ld.\n",
+						pp->lifetime, t);
 					goto end;
 				}
 				break;
@@ -4125,7 +3635,7 @@
 				t = ipsecdoi_set_ld(ld_buf);
 				vfree(ld_buf);
 				if (t == 0) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"invalid life duration.\n");
 					goto end;
 				}
@@ -4133,17 +3643,17 @@
 				if (pp->lifebyte == 0)
 					pp->lifebyte = t;
 				else if (pp->lifebyte != t) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"lifebyte mismatched "
 						"in a proposal, "
-						"prev:%d curr:%u.\n",
+						"prev:%ld curr:%ld.\n",
 						pp->lifebyte, t);
 					goto end;
 				}
 				break;
 			default:
 				vfree(ld_buf);
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"invalid life type: %d\n", life_t);
 				goto end;
 			}
@@ -4160,7 +3670,7 @@
 			if (pp->pfs_group == 0)
 				pp->pfs_group = (u_int16_t)ntohs(d->lorv);
 			else if (pp->pfs_group != (u_int16_t)ntohs(d->lorv)) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"pfs_group mismatched "
 					"in a proposal.\n");
 				goto end;
@@ -4170,7 +3680,7 @@
 		case IPSECDOI_ATTR_ENC_MODE:
 			if (pr->encmode &&
 			    pr->encmode != (u_int16_t)ntohs(d->lorv)) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"multiple encmode exist "
 					"in a transform.\n");
 				goto end;
@@ -4180,7 +3690,7 @@
 
 		case IPSECDOI_ATTR_AUTH:
 			if (tr->authtype != IPSECDOI_ATTR_AUTH_NONE) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"multiple authtype exist "
 					"in a transform.\n");
 				goto end;
@@ -4190,7 +3700,7 @@
 
 		case IPSECDOI_ATTR_KEY_LENGTH:
 			if (pr->proto_id != IPSECDOI_PROTO_IPSEC_ESP) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"key length defined but not ESP");
 				goto end;
 			}
@@ -4228,18 +3738,12 @@
 		return IPSECDOI_AH_MD5;
         case IPSECDOI_ATTR_AUTH_HMAC_SHA1:
 		return IPSECDOI_AH_SHA;
-	case IPSECDOI_ATTR_AUTH_HMAC_SHA2_256:
-		return IPSECDOI_AH_SHA256;
-	case IPSECDOI_ATTR_AUTH_HMAC_SHA2_384:
-		return IPSECDOI_AH_SHA384;
-	case IPSECDOI_ATTR_AUTH_HMAC_SHA2_512:
-		return IPSECDOI_AH_SHA512;
         case IPSECDOI_ATTR_AUTH_DES_MAC:
 		return IPSECDOI_AH_DES;
 	case IPSECDOI_ATTR_AUTH_KPDK:
 		return IPSECDOI_AH_MD5;	/* XXX */
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid authentication algorithm:%d\n", alg);
 	}
 	return -1;
@@ -4250,21 +3754,34 @@
 fixup_initiator_sa(match, received)
 	struct isakmpsa *match, *received;
 {
-	if (received->gssid != NULL)
-		match->gssid = vdup(received->gssid);
+	struct isakmpsa *newsa;
+
+	if (received->gssid == NULL)
+		return match;
 
-	return match;
+	newsa = newisakmpsa();
+	memcpy(newsa, match, sizeof *newsa);
+
+	if (match->dhgrp != NULL) {
+		newsa->dhgrp = racoon_calloc(1, sizeof(struct dhgroup));
+		memcpy(newsa->dhgrp, match->dhgrp, sizeof (struct dhgroup));
+	}
+	newsa->next = NULL;
+	newsa->rmconf = NULL;
+
+	newsa->gssid = vdup(received->gssid);
+
+	return newsa;
 }
 #endif
 
 static int rm_idtype2doi[] = {
-	255,				/* IDTYPE_UNDEFINED, 0 */
-	IPSECDOI_ID_FQDN,		/* IDTYPE_FQDN, 1 */
-	IPSECDOI_ID_USER_FQDN,		/* IDTYPE_USERFQDN, 2 */
-	IPSECDOI_ID_KEY_ID,		/* IDTYPE_KEYID, 3 */
-	255,    /*			   IDTYPE_ADDRESS, 4 
+	IPSECDOI_ID_FQDN,
+	IPSECDOI_ID_USER_FQDN,
+	IPSECDOI_ID_KEY_ID,
+	255,	/* it's type of "address"
 		 * it expands into 4 types by another function. */
-	IPSECDOI_ID_DER_ASN1_DN,	/* IDTYPE_ASN1DN, 5 */
+	IPSECDOI_ID_DER_ASN1_DN,
 };
 
 /*
@@ -4300,46 +3817,11 @@
 	case IPSECDOI_ID_IPV6_ADDR_SUBNET:
 		return(IDTYPE_ADDRESS);
 	default:
-		plog(LLV_WARNING, LOCATION, NULL,
-			"Inproper idtype:%s in this function.\n",
-			s_ipsecdoi_ident(doi));
+		plog(PLOG_PROTOWARN, PLOGLOC, 0,
+		     "Improper idtype:%d\n",
+		     s_ipsecdoi_ident(doi));
 		return(IDTYPE_ADDRESS);	/* XXX */
 	}
 	/*NOTREACHED*/
 }
 
-#ifdef ENABLE_HYBRID
-static int
-switch_authmethod(authmethod)
-	int authmethod;
-{
-	switch(authmethod) {
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_R:
-		authmethod = OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I;
-		break;
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_R:
-		authmethod = OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_I;
-		break;
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_R:
-		authmethod = OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_I;
-		break;
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_R:
-		authmethod = OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_I;
-		break;
-	/* Those are not implemented */
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_R:
-		authmethod = OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_I;
-		break;
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_R:
-		authmethod = OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_I;
-		break;
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_R:
-		authmethod = OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_I;
-		break;
-	default:
-		break;
-	}
-
-	return authmethod;
-}
-#endif
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_agg.c
Only in .: isakmp_agg.c.bak
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_agg.h ./isakmp_agg.h
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_agg.h	Sat Jun 12 01:00:16 2004
+++ ./isakmp_agg.h	Mon Nov  7 19:06:47 2005
@@ -1,4 +1,4 @@
-/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/*	$KAME: isakmp_agg.h,v 1.4 2000/10/04 17:41:00 itojun Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -29,9 +29,6 @@
  * SUCH DAMAGE.
  */
 
-#ifndef _ISAKMP_AGG_H
-#define _ISAKMP_AGG_H
-
 extern int agg_i1send __P((struct ph1handle *, vchar_t *));
 extern int agg_i2recv __P((struct ph1handle *, vchar_t *));
 extern int agg_i2send __P((struct ph1handle *, vchar_t *));
@@ -40,5 +37,3 @@
 extern int agg_r1send __P((struct ph1handle *, vchar_t *));
 extern int agg_r2recv __P((struct ph1handle *, vchar_t *));
 extern int agg_r2send __P((struct ph1handle *, vchar_t *));
-
-#endif /* _ISAKMP_AGG_H */
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_base.c ./isakmp_base.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_base.c	Fri Sep 23 23:16:55 2005
+++ ./isakmp_base.c	Thu Feb  2 14:52:59 2006
@@ -1,4 +1,4 @@
-/*	$KAME: isakmp_base.c,v 1.49 2003/11/13 02:30:20 sakane Exp $	*/
+/*	$KAME: isakmp_base.c,v 1.50 2004/03/03 05:39:59 sakane Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -31,7 +31,9 @@
 
 /* Base Exchange (Base Mode) */
 
-#include "config.h"
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
 
 #include <sys/types.h>
 #include <sys/param.h>
@@ -52,40 +54,27 @@
 #endif
 
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 #include "sockmisc.h"
 #include "schedule.h"
 #include "debug.h"
 
-#ifdef ENABLE_HYBRID
-#include <resolv.h>
-#endif
+#include "racoon.h"
 
-#include "localconf.h"
+/* #include "localconf.h" */
 #include "remoteconf.h"
-#include "isakmp_var.h"
 #include "isakmp.h"
-#include "evt.h"
+#include "isakmp_var.h"
 #include "oakley.h"
 #include "handler.h"
 #include "ipsec_doi.h"
 #include "crypto_openssl.h"
-#include "pfkey.h"
+/* #include "pfkey.h" */
 #include "isakmp_base.h"
 #include "isakmp_inf.h"
 #include "vendorid.h"
-#ifdef ENABLE_NATT
-#include "nattraversal.h"
-#endif
-#ifdef ENABLE_FRAG
-#include "isakmp_frag.h"
-#endif
-#ifdef ENABLE_HYBRID
-#include "isakmp_xauth.h"
-#include "isakmp_cfg.h"
-#endif
 
 /* %%%
  * begin Identity Protection Mode as initiator.
@@ -102,32 +91,19 @@
 	struct ph1handle *iph1;
 	vchar_t *msg; /* must be null */
 {
-	struct payload_list *plist = NULL;
+	struct isakmp_gen *gen;
+	struct isakmp_construct p;
+	int tlen;
 	int error = -1;
-#ifdef ENABLE_NATT
-	vchar_t *vid_natt[MAX_NATT_VID_COUNT] = { NULL };
-	int i, vid_natt_i = 0;
-#endif
-#ifdef ENABLE_FRAG
-	vchar_t *vid_frag = NULL;
-#endif
-#ifdef ENABLE_HYBRID
-	vchar_t *vid_xauth = NULL;
-	vchar_t *vid_unity = NULL;
-#endif
-#ifdef ENABLE_DPD
-	vchar_t *vid_dpd = NULL;
-#endif
-
 
 	/* validity check */
 	if (msg != NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"msg has to be NULL in this function.\n");
 		goto end;
 	}
 	if (iph1->status != PHASE1ST_START) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -141,115 +117,48 @@
 		goto end;
 
 	/* create SA payload for my proposal */
-	iph1->sa = ipsecdoi_setph1proposal(iph1->rmconf->proposal);
+	iph1->sa = ipsecdoi_setph1proposal(ikev1_proposal(iph1));
 	if (iph1->sa == NULL)
 		goto end;
 
 	/* generate NONCE value */
-	iph1->nonce = eay_set_random(iph1->rmconf->nonce_size);
+	iph1->nonce = eay_set_random(ikev1_nonce_size(iph1->rmconf));
 	if (iph1->nonce == NULL)
 		goto end;
 
-#ifdef ENABLE_HYBRID
-        /* Do we need Xauth VID? */
-        switch (RMAUTHMETHOD(iph1)) {
-        case FICTIVE_AUTH_METHOD_XAUTH_PSKEY_I:
-        case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
-        case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_I:
-        case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_I:
-        case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_I:
-        case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_I:
-        case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_I:
-                if ((vid_xauth = set_vendorid(VENDORID_XAUTH)) == NULL)
-                        plog(LLV_ERROR, LOCATION, NULL,
-                             "Xauth vendor ID generation failed\n");
-
-                if ((vid_unity = set_vendorid(VENDORID_UNITY)) == NULL)
-                        plog(LLV_ERROR, LOCATION, NULL,
-                             "Unity vendor ID generation failed\n");
-                break;
-        default:
-                break;
-        }
-#endif
-#ifdef ENABLE_FRAG
-	if (iph1->rmconf->ike_frag) {
-		vid_frag = set_vendorid(VENDORID_FRAG);
-		if (vid_frag != NULL)
-			vid_frag = isakmp_frag_addcap(vid_frag, 
-			    VENDORID_FRAG_BASE);
-		if (vid_frag == NULL)
-			plog(LLV_ERROR, LOCATION, NULL, 
-			    "Frag vendorID construction failed\n");
-	}
-#endif
-#ifdef ENABLE_NATT
-	/* Is NAT-T support allowed in the config file? */
-	if (iph1->rmconf->nat_traversal) {
-		/* Advertise NAT-T capability */
-		memset (vid_natt, 0, sizeof (vid_natt));
-#ifdef VENDORID_NATT_00
-		if ((vid_natt[vid_natt_i] = set_vendorid(VENDORID_NATT_00)) != NULL)
-			vid_natt_i++;
-#endif
-#ifdef VENDORID_NATT_02
-		if ((vid_natt[vid_natt_i] = set_vendorid(VENDORID_NATT_02)) != NULL)
-			vid_natt_i++;
-#endif
-#ifdef VENDORID_NATT_02_N
-		if ((vid_natt[vid_natt_i] = set_vendorid(VENDORID_NATT_02_N)) != NULL)
-			vid_natt_i++;
-#endif
-#ifdef VENDORID_NATT_RFC
-		if ((vid_natt[vid_natt_i] = set_vendorid(VENDORID_NATT_RFC)) != NULL)
-			vid_natt_i++;
-#endif
+	/* create buffer to send isakmp payload */
+	tlen = sizeof(struct isakmp)
+		+ sizeof(*gen) + iph1->sa->l
+		+ sizeof(*gen) + iph1->id->l
+		+ sizeof(*gen) + iph1->nonce->l;
+
+	iph1->sendbuf = vmalloc(tlen);
+	if (iph1->sendbuf == NULL) {
+		plog(PLOG_INTERR, LOCATION, NULL,
+			"failed to get buffer to send.\n");
+		goto end;
 	}
-#endif
+
+	/* set isakmp header */
+	p = set_isakmp_header(iph1->sendbuf, iph1);
+	if (p.buff == NULL)
+		goto end;
 
 	/* set SA payload to propose */
-	plist = isakmp_plist_append(plist, iph1->sa, ISAKMP_NPTYPE_SA);
+	p = set_isakmp_payload_c(p, iph1->sa, ISAKMP_NPTYPE_SA);
 
 	/* create isakmp ID payload */
-	plist = isakmp_plist_append(plist, iph1->id, ISAKMP_NPTYPE_ID);
+	p = set_isakmp_payload_c(p, iph1->id, ISAKMP_NPTYPE_ID);
 
 	/* create isakmp NONCE payload */
-	plist = isakmp_plist_append(plist, iph1->nonce, ISAKMP_NPTYPE_NONCE);
-
-#ifdef ENABLE_FRAG
-	if (vid_frag)
-		plist = isakmp_plist_append(plist, vid_frag, ISAKMP_NPTYPE_VID);
-#endif
-#ifdef ENABLE_HYBRID
-	if (vid_xauth)
-		plist = isakmp_plist_append(plist, 
-		    vid_xauth, ISAKMP_NPTYPE_VID);
-	if (vid_unity)
-		plist = isakmp_plist_append(plist, 
-		    vid_unity, ISAKMP_NPTYPE_VID);
-#endif
-#ifdef ENABLE_DPD
-	if (iph1->rmconf->dpd) {
-		vid_dpd = set_vendorid(VENDORID_DPD);
-		if (vid_dpd != NULL)
-			plist = isakmp_plist_append(plist, vid_dpd, ISAKMP_NPTYPE_VID); 
-	}
-#endif  
-#ifdef ENABLE_NATT
-	/* set VID payload for NAT-T */
-	for (i = 0; i < vid_natt_i; i++)
-		plist = isakmp_plist_append(plist, vid_natt[i], ISAKMP_NPTYPE_VID);
-
-	iph1->sendbuf = isakmp_plist_set_all (&plist, iph1);
-#endif
-
+	p = set_isakmp_payload_c(p, iph1->nonce, ISAKMP_NPTYPE_NONCE);
 
 #ifdef HAVE_PRINT_ISAKMP_C
 	isakmp_printpacket(iph1->sendbuf, iph1->local, iph1->remote, 0);
 #endif
 
 	/* send the packet, add to the schedule to resend */
-	iph1->retry_counter = iph1->rmconf->retry_counter;
+	iph1->retry_counter = ikev1_max_retry_to_send(iph1->rmconf);
 	if (isakmp_ph1resend(iph1) == -1)
 		goto end;
 
@@ -258,24 +167,6 @@
 	error = 0;
 
 end:
-#ifdef ENABLE_FRAG
-	if (vid_frag)
-		vfree(vid_frag);
-#endif 
-#ifdef ENABLE_NATT
-	for (i = 0; i < vid_natt_i; i++)
-		vfree(vid_natt[i]);
-#endif
-#ifdef ENABLE_HYBRID    
-	if (vid_xauth != NULL)
-		vfree(vid_xauth);
-	if (vid_unity != NULL) 
-		vfree(vid_unity);
-#endif 
-#ifdef ENABLE_DPD
-	if (vid_dpd != NULL)    
-		vfree(vid_dpd);
-#endif     
 
 	return error;
 }
@@ -296,15 +187,10 @@
 	struct isakmp_parse_t *pa;
 	vchar_t *satmp = NULL;
 	int error = -1;
-	int vid_numeric;
-#ifdef ENABLE_HYBRID
-	vchar_t *unity_vid;
-	vchar_t *xauth_vid;
-#endif
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG1SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -317,10 +203,11 @@
 
 	/* SA payload is fixed postion */
 	if (pa->type != ISAKMP_NPTYPE_SA) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"received invalid next payload type %d, "
-			"expecting %d.\n",
-			pa->type, ISAKMP_NPTYPE_SA);
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, LOCATION,
+			   "received invalid next payload type %d, "
+			   "expecting %d.\n",
+			   pa->type, ISAKMP_NPTYPE_SA);
 		goto end;
 	}
 	if (isakmp_p2ph(&satmp, pa->ptr) < 0)
@@ -341,69 +228,39 @@
 				goto end;
 			break;
 		case ISAKMP_NPTYPE_VID:
-			vid_numeric = check_vendorid(pa->ptr);
-#ifdef ENABLE_NATT
-			if (iph1->rmconf->nat_traversal && natt_vendorid(vid_numeric))
-			  natt_handle_vendorid(iph1, vid_numeric);
-#endif
-#ifdef ENABLE_HYBRID
-			switch (vid_numeric) {
-			case VENDORID_XAUTH:
-				iph1->mode_cfg->flags |=
-				    ISAKMP_CFG_VENDORID_XAUTH;
-				break;
-
-			case VENDORID_UNITY:
-				iph1->mode_cfg->flags |=
-				    ISAKMP_CFG_VENDORID_UNITY;
-				break;
-
-			default:
-				break;
-			}
-#endif
-#ifdef ENABLE_DPD
-			if (vid_numeric == VENDORID_DPD && iph1->rmconf->dpd) {
-				iph1->dpd_support=1;
-				plog(LLV_DEBUG, LOCATION, NULL,
-					 "remote supports DPD\n");
-			}
-#endif
+			(void)check_vendorid(pa->ptr);
 			break;
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, LOCATION,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
 	if (iph1->nonce_p == NULL || iph1->id_p == NULL) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, LOCATION,
+			   "few isakmp message received.\n");
 		goto end;
 	}
 
 	/* verify identifier */
 	if (ipsecdoi_checkid1(iph1) != 0) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"invalid ID payload.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "invalid ID payload.\n");
 		goto end;
 	}
 
-#ifdef ENABLE_NATT
-	if (NATT_AVAILABLE(iph1))
-		plog(LLV_INFO, LOCATION, iph1->remote,
-		     "Selected NAT-T version: %s\n",
-		     vid_string_by_id(iph1->natt_options->version));
-#endif
-
 	/* check SA payload and set approval SA for use */
 	if (ipsecdoi_checkph1proposal(satmp, iph1) < 0) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"failed to get valid proposal.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "failed to get valid proposal.\n");
 		/* XXX send information */
 		goto end;
 	}
@@ -439,21 +296,23 @@
 	struct ph1handle *iph1;
 	vchar_t *msg;
 {
-	struct payload_list *plist = NULL;
+	struct isakmp_gen *gen;
+	struct isakmp_construct p;
 	vchar_t *vid = NULL;
+	int tlen;
 	int need_cert = 0;
 	int error = -1;
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG2RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
 
 	/* fix isakmp index */
 	memcpy(&iph1->index.r_ck, &((struct isakmp *)msg->v)->r_ck,
-		sizeof(cookie_t));
+		sizeof(isakmp_cookie_t));
 
 	/* generate DH public value */
 	if (oakley_dh_generate(iph1->approval->dhgrp,
@@ -461,53 +320,53 @@
 		goto end;
 
 	/* generate SKEYID to compute hash if not signature mode */
-	switch (AUTHMETHOD(iph1)) {
-	case OAKLEY_ATTR_AUTH_METHOD_RSASIG:
-	case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_I:
-#endif
-		break;
-	default:
+	if (iph1->approval->authmethod != OAKLEY_ATTR_AUTH_METHOD_RSASIG
+	 && iph1->approval->authmethod != OAKLEY_ATTR_AUTH_METHOD_DSSSIG) {
 		if (oakley_skeyid(iph1) < 0)
 			goto end;
-		break;
 	}
 
 	/* generate HASH to send */
-	plog(LLV_DEBUG, LOCATION, NULL, "generate HASH_I\n");
+	plog(PLOG_DEBUG, LOCATION, NULL, "generate HASH_I\n");
 	iph1->hash = oakley_ph1hash_base_i(iph1, GENERATE);
 	if (iph1->hash == NULL)
 		goto end;
-	switch (AUTHMETHOD(iph1)) {
+
+	/* create buffer to send isakmp payload */
+	tlen = sizeof(struct isakmp);
+
+	switch (iph1->approval->authmethod) {
 	case OAKLEY_ATTR_AUTH_METHOD_PSKEY:
-#ifdef ENABLE_HYBRID
-	case FICTIVE_AUTH_METHOD_XAUTH_PSKEY_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_I:
-#endif
-		vid = set_vendorid(iph1->approval->vendorid);
+		tlen += sizeof(*gen) + iph1->dhpub->l
+			+ sizeof(*gen) + iph1->hash->l;
+		if ((vid = set_vendorid(iph1->approval->vendorid)) != NULL)
+			tlen += sizeof(*gen) + vid->l;
+
+		iph1->sendbuf = vmalloc(tlen);
+		if (iph1->sendbuf == NULL) {
+			plog(PLOG_INTERR, LOCATION, NULL,
+				"failed to get buffer to send.\n");
+			goto end;
+		}
+
+		/* set isakmp header */
+		p = set_isakmp_header(iph1->sendbuf, iph1);
+		if (p.buff == NULL)
+			goto end;
 
 		/* create isakmp KE payload */
-		plist = isakmp_plist_append(plist, iph1->dhpub, ISAKMP_NPTYPE_KE);
+		p = set_isakmp_payload_c(p, iph1->dhpub, ISAKMP_NPTYPE_KE);
 
 		/* create isakmp HASH payload */
-		plist = isakmp_plist_append(plist, iph1->hash, ISAKMP_NPTYPE_HASH);
+		p = set_isakmp_payload_c(p, iph1->hash, ISAKMP_NPTYPE_HASH);
 
 		/* append vendor id, if needed */
 		if (vid)
-			plist = isakmp_plist_append(plist, vid, ISAKMP_NPTYPE_VID);
+			p = set_isakmp_payload_c(p, vid, ISAKMP_NPTYPE_VID);
 		break;
+#ifdef HAVE_SIGNING_C
 	case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
 	case OAKLEY_ATTR_AUTH_METHOD_RSASIG:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_I:
-#endif
 		/* XXX if there is CR or not ? */
 
 		if (oakley_getmycert(iph1) < 0)
@@ -516,75 +375,57 @@
 		if (oakley_getsign(iph1) < 0)
 			goto end;
 
-		if (iph1->cert && iph1->rmconf->send_cert)
+		if (iph1->cert && ikev1_send_cert(iph1->rmconf) == RCT_BOOL_ON)
 			need_cert = 1;
 
+		tlen += sizeof(*gen) + iph1->dhpub->l
+			+ sizeof(*gen) + iph1->sig->l;
+		if (need_cert)
+			tlen += sizeof(*gen) + iph1->cert->pl->l;
+
+		iph1->sendbuf = vmalloc(tlen);
+		if (iph1->sendbuf == NULL) {
+			plog(PLOG_INTERR, LOCATION, NULL,
+				"failed to get buffer to send.\n");
+			goto end;
+		}
+
+		/* set isakmp header */
+		p = set_isakmp_header(iph1->sendbuf, iph1);
+		if (p.buff == NULL)
+			goto end;
+
 		/* create isakmp KE payload */
-		plist = isakmp_plist_append(plist, 
-		    iph1->dhpub, ISAKMP_NPTYPE_KE);
+		p = set_isakmp_payload_c(p, iph1->dhpub, ISAKMP_NPTYPE_KE);
 
 		/* add CERT payload if there */
 		if (need_cert)
-			plist = isakmp_plist_append(plist, 
-			    iph1->cert->pl, ISAKMP_NPTYPE_CERT);
-
+			p = set_isakmp_payload_c(p, iph1->cert->pl, ISAKMP_NPTYPE_CERT);
 		/* add SIG payload */
-		plist = isakmp_plist_append(plist, 
-		    iph1->sig, ISAKMP_NPTYPE_SIG);
-
+		p = set_isakmp_payload_c(p, iph1->sig, ISAKMP_NPTYPE_SIG);
 		break;
-#ifdef HAVE_GSSAPI
+#endif
 	case OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB:
 		/* ... */
 		break;
-#endif
 	case OAKLEY_ATTR_AUTH_METHOD_RSAENC:
 	case OAKLEY_ATTR_AUTH_METHOD_RSAREV:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_I:
-#endif
+		tlen += sizeof(*gen) + iph1->hash->l;
 		break;
 	}
 
-#ifdef ENABLE_NATT
-	/* generate NAT-D payloads */
-	if (NATT_AVAILABLE(iph1))
-	{
-		vchar_t *natd[2] = { NULL, NULL };
-
-		plog (LLV_INFO, LOCATION, NULL, "Adding remote and local NAT-D payloads.\n");
-		if ((natd[0] = natt_hash_addr (iph1, iph1->remote)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"NAT-D hashing failed for %s\n", saddr2str(iph1->remote));
-			goto end;
-		}
-
-		if ((natd[1] = natt_hash_addr (iph1, iph1->local)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"NAT-D hashing failed for %s\n", saddr2str(iph1->local));
-			goto end;
-		}
-
-		plist = isakmp_plist_append(plist, natd[0], iph1->natt_options->payload_nat_d);
-		plist = isakmp_plist_append(plist, natd[1], iph1->natt_options->payload_nat_d);
-	}
-#endif
-
-	iph1->sendbuf = isakmp_plist_set_all (&plist, iph1);
-
 #ifdef HAVE_PRINT_ISAKMP_C
 	isakmp_printpacket(iph1->sendbuf, iph1->local, iph1->remote, 0);
 #endif
 
 	/* send the packet, add to the schedule to resend */
-	iph1->retry_counter = iph1->rmconf->retry_counter;
+	iph1->retry_counter = ikev1_max_retry_to_send(iph1->rmconf);
 	if (isakmp_ph1resend(iph1) == -1)
 		goto end;
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph1->remote, iph1->local, iph1->sendbuf, msg) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR , LOCATION, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -614,15 +455,10 @@
 	vchar_t *pbuf = NULL;
 	struct isakmp_parse_t *pa;
 	int error = -1;
-	int ptype;
-#ifdef ENABLE_NATT
-	vchar_t	*natd_received;
-	int natd_seq = 0, natd_verified;
-#endif
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG2SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -644,6 +480,7 @@
 		case ISAKMP_NPTYPE_HASH:
 			iph1->pl_hash = (struct isakmp_pl_hash *)pa->ptr;
 			break;
+#ifdef HAVE_SIGNING_C
 		case ISAKMP_NPTYPE_CERT:
 			if (oakley_savecert(iph1, pa->ptr) < 0)
 				goto end;
@@ -652,74 +489,35 @@
 			if (isakmp_p2ph(&iph1->sig_p, pa->ptr) < 0)
 				goto end;
 			break;
+#endif
 		case ISAKMP_NPTYPE_VID:
 			(void)check_vendorid(pa->ptr);
 			break;
-
-#ifdef ENABLE_NATT
-		case ISAKMP_NPTYPE_NATD_DRAFT:
-		case ISAKMP_NPTYPE_NATD_RFC:
-			if (NATT_AVAILABLE(iph1) && iph1->natt_options &&
-			    pa->type == iph1->natt_options->payload_nat_d) {
-				natd_received = NULL;
-				if (isakmp_p2ph (&natd_received, pa->ptr) < 0)
-					goto end;
-                        
-				/* set both bits first so that we can clear them
-				   upon verifying hashes */
-				if (natd_seq == 0)
-					iph1->natt_flags |= NAT_DETECTED;
-                        
-				/* this function will clear appropriate bits bits 
-				   from iph1->natt_flags */
-				natd_verified = natt_compare_addr_hash (iph1,
-					natd_received, natd_seq++);
-                        
-				plog (LLV_INFO, LOCATION, NULL, "NAT-D payload #%d %s\n",
-					natd_seq - 1,
-					natd_verified ? "verified" : "doesn't match");
-                        
-				vfree (natd_received);
-				break;
-			}
-			/* passthrough to default... */
-#endif
-
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
-#ifdef ENABLE_NATT
-	if (NATT_AVAILABLE(iph1)) {
-		plog (LLV_INFO, LOCATION, NULL, "NAT %s %s%s\n",
-		      iph1->natt_flags & NAT_DETECTED ? 
-		      		"detected:" : "not detected",
-		      iph1->natt_flags & NAT_DETECTED_ME ? "ME " : "",
-		      iph1->natt_flags & NAT_DETECTED_PEER ? "PEER" : "");
-		if (iph1->natt_flags & NAT_DETECTED)
-			natt_float_ports (iph1);
-	}
-#endif
-
 	/* payload existency check */
 	/* validate authentication value */
-	ptype = oakley_validate_auth(iph1);
-	if (ptype != 0) {
-		if (ptype == -1) {
+    {
+	int type;
+	type = oakley_validate_auth(iph1);
+	if (type != 0) {
+		if (type == -1) {
 			/* message printed inner oakley_validate_auth() */
 			goto end;
 		}
-		EVT_PUSH(iph1->local, iph1->remote, 
-		    EVTT_PEERPH1AUTH_FAILED, NULL);
-		isakmp_info_send_n1(iph1, ptype, NULL);
+		isakmp_info_send_n1(iph1, type, NULL);
 		goto end;
 	}
+    }
 
 	/* compute sharing secret of DH */
 	if (oakley_dh_compute(iph1->approval->dhgrp, iph1->dhpub,
@@ -727,21 +525,10 @@
 		goto end;
 
 	/* generate SKEYID to compute hash if signature mode */
-	switch (AUTHMETHOD(iph1)) {
-	case OAKLEY_ATTR_AUTH_METHOD_RSASIG:
-	case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_I:
-#endif
+	if (iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_RSASIG
+	 || iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_DSSSIG) {
 		if (oakley_skeyid(iph1) < 0)
 			goto end;
-		break;
-	default:
-		break;
 	}
 
 	/* generate SKEYIDs & IV & final cipher key */
@@ -790,7 +577,7 @@
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG3RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -818,11 +605,10 @@
 	vchar_t *pbuf = NULL;
 	struct isakmp_parse_t *pa;
 	int error = -1;
-	int vid_numeric;
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_START) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -838,10 +624,11 @@
 
 	/* check the position of SA payload */
 	if (pa->type != ISAKMP_NPTYPE_SA) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"received invalid next payload type %d, "
-			"expecting %d.\n",
-			pa->type, ISAKMP_NPTYPE_SA);
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "received invalid next payload type %d, "
+			   "expecting %d.\n",
+			   pa->type, ISAKMP_NPTYPE_SA);
 		goto end;
 	}
 	if (isakmp_p2ph(&iph1->sa, pa->ptr) < 0)
@@ -862,74 +649,38 @@
 				goto end;
 			break;
 		case ISAKMP_NPTYPE_VID:
-			vid_numeric = check_vendorid(pa->ptr);
-#ifdef ENABLE_NATT
-			if (iph1->rmconf->nat_traversal && natt_vendorid(vid_numeric))
-				natt_handle_vendorid(iph1, vid_numeric);
-#endif
-#ifdef ENABLE_FRAG
-			if ((vid_numeric == VENDORID_FRAG) &&
-			    (vendorid_frag_cap(pa->ptr) & VENDORID_FRAG_BASE))
-				iph1->frag = 1;
-#endif
-#ifdef ENABLE_HYBRID
-			switch (vid_numeric) {
-			case VENDORID_XAUTH:
-				iph1->mode_cfg->flags |=
-				    ISAKMP_CFG_VENDORID_XAUTH;
-				break;
-
-			case VENDORID_UNITY:
-				iph1->mode_cfg->flags |=
-				    ISAKMP_CFG_VENDORID_UNITY;
-				break;
-
-			default:
-				break;
-			}
-#endif
-#ifdef ENABLE_DPD
-			if (vid_numeric == VENDORID_DPD && iph1->rmconf->dpd) {
-				iph1->dpd_support=1;
-				plog(LLV_DEBUG, LOCATION, NULL,
-					 "remote supports DPD\n");
-			}
-#endif 
+			(void)check_vendorid(pa->ptr);
 			break;
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
 	if (iph1->nonce_p == NULL || iph1->id_p == NULL) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "few isakmp message received.\n");
 		goto end;
 	}
 
 	/* verify identifier */
 	if (ipsecdoi_checkid1(iph1) != 0) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+		plog(PLOG_PROTOERR, LOCATION, iph1->remote,
 			"invalid ID payload.\n");
 		goto end;
 	}
 
-#ifdef ENABLE_NATT
-	if (NATT_AVAILABLE(iph1))
-		plog(LLV_INFO, LOCATION, iph1->remote,
-		     "Selected NAT-T version: %s\n",
-		     vid_string_by_id(iph1->natt_options->version));
-#endif
-
 	/* check SA payload and set approval SA for use */
 	if (ipsecdoi_checkph1proposal(iph1->sa, iph1) < 0) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"failed to get valid proposal.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "failed to get valid proposal.\n");
 		/* XXX send information */
 		goto end;
 	}
@@ -963,25 +714,14 @@
 	struct ph1handle *iph1;
 	vchar_t *msg;
 {
-	struct payload_list *plist = NULL;
+	struct isakmp_gen *gen;
+	struct isakmp_construct p;
+	int tlen;
 	int error = -1;
-#ifdef ENABLE_NATT
-	vchar_t *vid_natt = NULL;
-#endif
-#ifdef ENABLE_HYBRID    
-        vchar_t *vid_xauth = NULL;
-        vchar_t *vid_unity = NULL;
-#endif  
-#ifdef ENABLE_FRAG
-	vchar_t *vid_frag = NULL;
-#endif
-#ifdef ENABLE_DPD
-	vchar_t *vid_dpd = NULL;
-#endif  
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG1RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -994,81 +734,49 @@
 		goto end;
 
 	/* generate NONCE value */
-	iph1->nonce = eay_set_random(iph1->rmconf->nonce_size);
+	iph1->nonce = eay_set_random(ikev1_nonce_size(iph1->rmconf));
 	if (iph1->nonce == NULL)
 		goto end;
 
+	/* create buffer to send isakmp payload */
+	tlen = sizeof(struct isakmp)
+		+ sizeof(*gen) + iph1->sa_ret->l
+		+ sizeof(*gen) + iph1->id->l
+		+ sizeof(*gen) + iph1->nonce->l;
+
+	iph1->sendbuf = vmalloc(tlen);
+	if (iph1->sendbuf == NULL) { 
+		plog(PLOG_INTERR, LOCATION, NULL,
+			"failed to get buffer to send.\n");
+		goto end;
+	}
+
+	/* set isakmp header */
+	p = set_isakmp_header(iph1->sendbuf, iph1);
+	if (p.buff == NULL)
+		goto end;
+
 	/* set SA payload to reply */
-	plist = isakmp_plist_append(plist, iph1->sa_ret, ISAKMP_NPTYPE_SA);
+	p = set_isakmp_payload_c(p, iph1->sa_ret, ISAKMP_NPTYPE_SA);
 
 	/* create isakmp ID payload */
-	plist = isakmp_plist_append(plist, iph1->id, ISAKMP_NPTYPE_ID);
+	p = set_isakmp_payload_c(p, iph1->id, ISAKMP_NPTYPE_ID);
 
 	/* create isakmp NONCE payload */
-	plist = isakmp_plist_append(plist, iph1->nonce, ISAKMP_NPTYPE_NONCE);
-
-#ifdef ENABLE_NATT
-	/* has the peer announced nat-t? */
-	if (NATT_AVAILABLE(iph1))
-		vid_natt = set_vendorid(iph1->natt_options->version);
-	if (vid_natt)
-		plist = isakmp_plist_append(plist, vid_natt, ISAKMP_NPTYPE_VID);
-#endif
-#ifdef ENABLE_HYBRID
-	if (iph1->mode_cfg->flags & ISAKMP_CFG_VENDORID_XAUTH) {
-		plog (LLV_INFO, LOCATION, NULL, "Adding xauth VID payload.\n");
-		if ((vid_xauth = set_vendorid(VENDORID_XAUTH)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "Cannot create Xauth vendor ID\n");
-			goto end;
-		}
-		plist = isakmp_plist_append(plist,
-		    vid_xauth, ISAKMP_NPTYPE_VID);
-	}
-
-	if (iph1->mode_cfg->flags & ISAKMP_CFG_VENDORID_UNITY) {
-		if ((vid_unity = set_vendorid(VENDORID_UNITY)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "Cannot create Unity vendor ID\n");
-			goto end;
-		}
-		plist = isakmp_plist_append(plist,
-		    vid_unity, ISAKMP_NPTYPE_VID);
-	}
-#endif
-#ifdef ENABLE_DPD
-	/* Only send DPD support if remote announced DPD and if DPD support is active */                        
-	if (iph1->dpd_support && iph1->rmconf->dpd)
-		vid_dpd = set_vendorid(VENDORID_DPD);
-#endif
-#ifdef ENABLE_FRAG
-	if (iph1->rmconf->ike_frag) {
-		if ((vid_frag = set_vendorid(VENDORID_FRAG)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "Frag vendorID construction failed\n");
-		} else {
-			vid_frag = isakmp_frag_addcap(vid_frag,
-			    VENDORID_FRAG_BASE);
-			plist = isakmp_plist_append(plist,
-			    vid_frag, ISAKMP_NPTYPE_VID);
-		}
-	}
-#endif
-
-	iph1->sendbuf = isakmp_plist_set_all (&plist, iph1);
+	p = set_isakmp_payload_c(p, iph1->nonce, ISAKMP_NPTYPE_NONCE);
 
 #ifdef HAVE_PRINT_ISAKMP_C
 	isakmp_printpacket(iph1->sendbuf, iph1->local, iph1->remote, 0);
 #endif
 
 	/* send the packet, add to the schedule to resend */
-	iph1->retry_counter = iph1->rmconf->retry_counter;
+	iph1->retry_counter = ikev1_max_retry_to_send(iph1->rmconf);
 	if (isakmp_ph1resend(iph1) == -1)
 		goto end;
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph1->remote, iph1->local, iph1->sendbuf, msg) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -1078,25 +786,6 @@
 	error = 0;
 
 end:
-#ifdef ENABLE_NATT
-	if (vid_natt)
-		vfree(vid_natt);
-#endif
-#ifdef ENABLE_HYBRID    
-	if (vid_xauth != NULL)
-		vfree(vid_xauth);
-	if (vid_unity != NULL)
-		vfree(vid_unity);
-#endif    
-#ifdef ENABLE_FRAG
-	if (vid_frag)
-		vfree(vid_frag);
-#endif
-#ifdef ENABLE_DPD
-	if (vid_dpd)
-		vfree(vid_dpd);
-#endif
-
 	VPTRINIT(iph1->sa_ret);
 
 	return error;
@@ -1117,14 +806,10 @@
 	vchar_t *pbuf = NULL;
 	struct isakmp_parse_t *pa;
 	int error = -1;
-	int ptype;
-#ifdef ENABLE_NATT
-	int natd_seq = 0;
-#endif
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG1SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -1148,6 +833,7 @@
 		case ISAKMP_NPTYPE_HASH:
 			iph1->pl_hash = (struct isakmp_pl_hash *)pa->ptr;
 			break;
+#ifdef HAVE_SIGNING_C
 		case ISAKMP_NPTYPE_CERT:
 			if (oakley_savecert(iph1, pa->ptr) < 0)
 				goto end;
@@ -1156,43 +842,17 @@
 			if (isakmp_p2ph(&iph1->sig_p, pa->ptr) < 0)
 				goto end;
 			break;
+#endif
 		case ISAKMP_NPTYPE_VID:
 			(void)check_vendorid(pa->ptr);
 			break;
-
-#ifdef ENABLE_NATT
-		case ISAKMP_NPTYPE_NATD_DRAFT:
-		case ISAKMP_NPTYPE_NATD_RFC:
-			if (pa->type == iph1->natt_options->payload_nat_d)
-			{
-				vchar_t *natd_received = NULL;
-				int natd_verified;
-				
-				if (isakmp_p2ph (&natd_received, pa->ptr) < 0)
-					goto end;
-				
-				if (natd_seq == 0)
-					iph1->natt_flags |= NAT_DETECTED;
-				
-				natd_verified = natt_compare_addr_hash (iph1,
-					natd_received, natd_seq++);
-				
-				plog (LLV_INFO, LOCATION, NULL, "NAT-D payload #%d %s\n",
-					natd_seq - 1,
-					natd_verified ? "verified" : "doesn't match");
-				
-				vfree (natd_received);
-				break;
-			}
-			/* passthrough to default... */
-#endif
-
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
@@ -1211,28 +871,20 @@
 	if (oakley_skeyid(iph1) < 0)
 		goto end;
 
-#ifdef ENABLE_NATT
-	if (NATT_AVAILABLE(iph1))
-		plog (LLV_INFO, LOCATION, NULL, "NAT %s %s%s\n",
-		      iph1->natt_flags & NAT_DETECTED ? 
-		      		"detected:" : "not detected",
-		      iph1->natt_flags & NAT_DETECTED_ME ? "ME " : "",
-		      iph1->natt_flags & NAT_DETECTED_PEER ? "PEER" : "");
-#endif
-
 	/* payload existency check */
 	/* validate authentication value */
-	ptype = oakley_validate_auth(iph1);
-	if (ptype != 0) {
-		if (ptype == -1) {
+    {
+	int type;
+	type = oakley_validate_auth(iph1);
+	if (type != 0) {
+		if (type == -1) {
 			/* message printed inner oakley_validate_auth() */
 			goto end;
 		}
-		EVT_PUSH(iph1->local, iph1->remote, 
-		    EVTT_PEERPH1AUTH_FAILED, NULL);
-		isakmp_info_send_n1(iph1, ptype, NULL);
+		isakmp_info_send_n1(iph1, type, NULL);
 		goto end;
 	}
+    }
 
 	iph1->status = PHASE1ST_MSG2RECEIVED;
 
@@ -1266,48 +918,35 @@
 	struct ph1handle *iph1;
 	vchar_t *msg;
 {
-	struct payload_list *plist = NULL;
+	struct isakmp_gen *gen;
+	struct isakmp_construct p;
 	vchar_t *vid = NULL;
+	int tlen;
 	int need_cert = 0;
 	int error = -1;
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG2RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
 
 	/* generate HASH to send */
-	plog(LLV_DEBUG, LOCATION, NULL, "generate HASH_I\n");
-	switch (AUTHMETHOD(iph1)) {
+	plog(PLOG_DEBUG, LOCATION, NULL, "generate HASH_I\n");
+	switch (iph1->approval->authmethod) {
 	case OAKLEY_ATTR_AUTH_METHOD_PSKEY:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_R:
-#endif
 	case OAKLEY_ATTR_AUTH_METHOD_RSAENC:
 	case OAKLEY_ATTR_AUTH_METHOD_RSAREV:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_R:
-#endif
 		iph1->hash = oakley_ph1hash_common(iph1, GENERATE);
 		break;
 	case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
 	case OAKLEY_ATTR_AUTH_METHOD_RSASIG:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_R:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_R:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_R:
-#endif
-#ifdef HAVE_GSSAPI
 	case OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB:
-#endif
 		iph1->hash = oakley_ph1hash_base_r(iph1, GENERATE);
 		break;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, LOCATION, NULL,
 			"invalid authentication method %d\n",
 			iph1->approval->authmethod);
 		goto end; 
@@ -1315,34 +954,41 @@
 	if (iph1->hash == NULL)
 		goto end;
 
-	switch (AUTHMETHOD(iph1)) {
+	/* create HDR;KE;NONCE payload */
+	tlen = sizeof(struct isakmp);
+
+	switch (iph1->approval->authmethod) {
 	case OAKLEY_ATTR_AUTH_METHOD_PSKEY:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_R:
-#endif
-		vid = set_vendorid(iph1->approval->vendorid);
+		tlen += sizeof(*gen) + iph1->dhpub->l
+			+ sizeof(*gen) + iph1->hash->l;
+		if ((vid = set_vendorid(iph1->approval->vendorid)) != NULL)
+			tlen += sizeof(*gen) + vid->l;
+
+		iph1->sendbuf = vmalloc(tlen);
+		if (iph1->sendbuf == NULL) {
+			plog(PLOG_INTERR, LOCATION, NULL,
+				"failed to get iph1->sendbuf to send.\n");
+			goto end;
+		}
+
+		/* set isakmp header */
+		p = set_isakmp_header(iph1->sendbuf, iph1);
+		if (p.buff == NULL)
+			goto end;
 
 		/* create isakmp KE payload */
-		plist = isakmp_plist_append(plist, 
-		    iph1->dhpub, ISAKMP_NPTYPE_KE);
+		p = set_isakmp_payload_c(p, iph1->dhpub, ISAKMP_NPTYPE_KE);
 
 		/* create isakmp HASH payload */
-		plist = isakmp_plist_append(plist, 
-		    iph1->hash, ISAKMP_NPTYPE_HASH);
+		p = set_isakmp_payload_c(p, iph1->hash, ISAKMP_NPTYPE_HASH);
 
 		/* append vendor id, if needed */
 		if (vid)
-			plist = isakmp_plist_append(plist, 
-			    vid, ISAKMP_NPTYPE_VID);
+			p = set_isakmp_payload_c(p, vid, ISAKMP_NPTYPE_VID);
 		break;
+#ifdef HAVE_SIGNING_C
 	case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
 	case OAKLEY_ATTR_AUTH_METHOD_RSASIG:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_R:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_R:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_R:
-#endif
 		/* XXX if there is CR or not ? */
 
 		if (oakley_getmycert(iph1) < 0)
@@ -1351,65 +997,45 @@
 		if (oakley_getsign(iph1) < 0)
 			goto end;
 
-		if (iph1->cert && iph1->rmconf->send_cert)
+		if (iph1->cert && ikev1_send_cert(iph1->rmconf) == RCT_BOOL_ON)
 			need_cert = 1;
 
+		tlen += sizeof(*gen) + iph1->dhpub->l
+			+ sizeof(*gen) + iph1->sig->l;
+		if (need_cert)
+			tlen += sizeof(*gen) + iph1->cert->pl->l;
+
+		iph1->sendbuf = vmalloc(tlen);
+		if (iph1->sendbuf == NULL) {
+			plog(PLOG_INTERR, LOCATION, NULL,
+				"failed to get buffer to send.\n");
+			goto end;
+		}
+
+		/* set isakmp header */
+		p = set_isakmp_header(iph1->sendbuf, iph1);
+		if (p.buff == NULL)
+			goto end;
+
 		/* create isakmp KE payload */
-		plist = isakmp_plist_append(plist, 
-		    iph1->dhpub, ISAKMP_NPTYPE_KE);
+		p = set_isakmp_payload_c(p, iph1->dhpub, ISAKMP_NPTYPE_KE);
 
 		/* add CERT payload if there */
 		if (need_cert)
-			plist = isakmp_plist_append(plist, 
-			    iph1->cert->pl, ISAKMP_NPTYPE_CERT);
+			p = set_isakmp_payload_c(p, iph1->cert->pl, ISAKMP_NPTYPE_CERT);
 		/* add SIG payload */
-		plist = isakmp_plist_append(plist, 
-		    iph1->sig, ISAKMP_NPTYPE_SIG);
+		p = set_isakmp_payload_c(p, iph1->sig, ISAKMP_NPTYPE_SIG);
 		break;
-#ifdef HAVE_GSSAPI
+#endif
 	case OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB:
 		/* ... */
 		break;
-#endif
 	case OAKLEY_ATTR_AUTH_METHOD_RSAENC:
 	case OAKLEY_ATTR_AUTH_METHOD_RSAREV:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_R:
-#endif
+		tlen += sizeof(*gen) + iph1->hash->l;
 		break;
 	}
 
-#ifdef ENABLE_NATT
-	/* generate NAT-D payloads */
-	if (NATT_AVAILABLE(iph1)) {
-		vchar_t *natd[2] = { NULL, NULL };
-
-		plog(LLV_INFO, LOCATION, 
-		    NULL, "Adding remote and local NAT-D payloads.\n");
-		if ((natd[0] = natt_hash_addr(iph1, iph1->remote)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "NAT-D hashing failed for %s\n", 
-			    saddr2str(iph1->remote));
-			goto end;
-		}
-
-		if ((natd[1] = natt_hash_addr(iph1, iph1->local)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "NAT-D hashing failed for %s\n", 
-			    saddr2str(iph1->local));
-			goto end;
-		}
-
-		plist = isakmp_plist_append(plist, 
-		    natd[0], iph1->natt_options->payload_nat_d);
-		plist = isakmp_plist_append(plist, 
-		    natd[1], iph1->natt_options->payload_nat_d);
-	}
-#endif
-
-	iph1->sendbuf = isakmp_plist_set_all(&plist, iph1);
-
 #ifdef HAVE_PRINT_ISAKMP_C
 	isakmp_printpacket(iph1->sendbuf, iph1->local, iph1->remote, 0);
 #endif
@@ -1420,7 +1046,7 @@
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph1->remote, iph1->local, iph1->sendbuf, msg) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR, LOCATION, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_base.h ./isakmp_base.h
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_base.h	Sat Jun 12 01:00:16 2004
+++ ./isakmp_base.h	Mon Nov  7 19:06:48 2005
@@ -1,4 +1,4 @@
-/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/*	$KAME: isakmp_base.h,v 1.6 2000/10/04 17:41:00 itojun Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -29,9 +29,6 @@
  * SUCH DAMAGE.
  */
 
-#ifndef _ISAKMP_BASE_H
-#define _ISAKMP_BASE_H
-
 extern int base_i1send __P((struct ph1handle *, vchar_t *));
 extern int base_i2recv __P((struct ph1handle *, vchar_t *));
 extern int base_i2send __P((struct ph1handle *, vchar_t *));
@@ -42,5 +39,3 @@
 extern int base_r1send __P((struct ph1handle *, vchar_t *));
 extern int base_r2recv __P((struct ph1handle *, vchar_t *));
 extern int base_r2send __P((struct ph1handle *, vchar_t *));
-
-#endif /* _ISAKMP_BASE_H */
Only in .: isakmp_base.o
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_cfg.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_cfg.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_frag.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_frag.h
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_ident.c ./isakmp_ident.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_ident.c	Fri Sep 23 23:16:55 2005
+++ ./isakmp_ident.c	Thu Feb  2 16:26:21 2006
@@ -1,4 +1,4 @@
-/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/*	$KAME: isakmp_ident.c,v 1.66 2004/03/03 05:39:59 sakane Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -31,7 +31,9 @@
 
 /* Identity Protecion Exchange (Main Mode) */
 
-#include "config.h"
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
 
 #include <sys/types.h>
 #include <sys/param.h>
@@ -51,42 +53,35 @@
 # endif
 #endif
 
+#include "racoon.h"
+
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 #include "sockmisc.h"
 #include "schedule.h"
 #include "debug.h"
 
-#include "localconf.h"
+/* #include "localconf.h" */
 #include "remoteconf.h"
-#include "isakmp_var.h"
 #include "isakmp.h"
-#include "evt.h"
+#include "isakmp_var.h"
 #include "oakley.h"
 #include "handler.h"
 #include "ipsec_doi.h"
 #include "crypto_openssl.h"
-#include "pfkey.h"
+/* #include "pfkey.h" */
 #include "isakmp_ident.h"
 #include "isakmp_inf.h"
 #include "vendorid.h"
 
-#ifdef ENABLE_NATT
-#include "nattraversal.h"
-#endif
 #ifdef HAVE_GSSAPI
 #include "gssapi.h"
 #endif
-#ifdef ENABLE_HYBRID
-#include <resolv.h>
-#include "isakmp_xauth.h"
-#include "isakmp_cfg.h"
-#endif
-#ifdef ENABLE_FRAG 
-#include "isakmp_frag.h"
-#endif
+
+#include "ike_conf.h"
+#include "crypto_impl.h"
 
 static vchar_t *ident_ir2mx __P((struct ph1handle *));
 static vchar_t *ident_ir3mx __P((struct ph1handle *));
@@ -106,30 +101,19 @@
 	struct ph1handle *iph1;
 	vchar_t *msg; /* must be null */
 {
-	struct payload_list *plist = NULL;
+	struct isakmp_gen *gen;
+	struct isakmp_construct p;
+	int tlen;
 	int error = -1;
-#ifdef ENABLE_NATT
-	vchar_t *vid_natt[MAX_NATT_VID_COUNT] = { NULL };
-	int i;
-#endif
-#ifdef ENABLE_HYBRID  
-	vchar_t *vid_xauth = NULL;
-	vchar_t *vid_unity = NULL;
-#endif
-#ifdef ENABLE_FRAG 
-	vchar_t *vid_frag = NULL;
-#endif 
-#ifdef ENABLE_DPD
-	vchar_t *vid_dpd = NULL;
-#endif
+
 	/* validity check */
 	if (msg != NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"msg has to be NULL in this function.\n");
 		goto end;
 	}
 	if (iph1->status != PHASE1ST_START) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -139,76 +123,35 @@
 	isakmp_newcookie((caddr_t)&iph1->index, iph1->remote, iph1->local);
 
 	/* create SA payload for my proposal */
-	iph1->sa = ipsecdoi_setph1proposal(iph1->rmconf->proposal);
+	iph1->sa = ipsecdoi_setph1proposal(ikev1_proposal(iph1));
 	if (iph1->sa == NULL)
 		goto end;
 
-	/* set SA payload to propose */
-	plist = isakmp_plist_append(plist, iph1->sa, ISAKMP_NPTYPE_SA);
+	/* create buffer to send isakmp payload */
+	tlen = sizeof(struct isakmp)
+		+ sizeof(*gen) + iph1->sa->l;
 
-#ifdef ENABLE_NATT
-	/* set VID payload for NAT-T if NAT-T support allowed in the config file */
-	if (iph1->rmconf->nat_traversal) 
-		plist = isakmp_plist_append_natt_vids(plist, vid_natt);
-#endif
-#ifdef ENABLE_HYBRID
-	/* Do we need Xauth VID? */
-	switch (RMAUTHMETHOD(iph1)) {
-	case FICTIVE_AUTH_METHOD_XAUTH_PSKEY_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_I:
-		if ((vid_xauth = set_vendorid(VENDORID_XAUTH)) == NULL)
-			plog(LLV_ERROR, LOCATION, NULL,
-			     "Xauth vendor ID generation failed\n");
-		else
-			plist = isakmp_plist_append(plist,
-			    vid_xauth, ISAKMP_NPTYPE_VID);
-			
-		if ((vid_unity = set_vendorid(VENDORID_UNITY)) == NULL)
-			plog(LLV_ERROR, LOCATION, NULL,
-			     "Unity vendor ID generation failed\n");
-		else
-                	plist = isakmp_plist_append(plist,
-			    vid_unity, ISAKMP_NPTYPE_VID);
-		break;
-	default:
-		break;
-	}
-#endif
-#ifdef ENABLE_FRAG
-	if (iph1->rmconf->ike_frag) {
-		if ((vid_frag = set_vendorid(VENDORID_FRAG)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "Frag vendorID construction failed\n");
-		} else {
-			vid_frag = isakmp_frag_addcap(vid_frag,
-			    VENDORID_FRAG_IDENT);
-			plist = isakmp_plist_append(plist, 
-			    vid_frag, ISAKMP_NPTYPE_VID);
-		}
-	}
-#endif
-#ifdef ENABLE_DPD
-	if(iph1->rmconf->dpd){
-		vid_dpd = set_vendorid(VENDORID_DPD);
-		if (vid_dpd != NULL)
-			plist = isakmp_plist_append(plist, vid_dpd,
-			    ISAKMP_NPTYPE_VID);
+	iph1->sendbuf = vmalloc(tlen);
+	if (iph1->sendbuf == NULL) {
+		plog(PLOG_INTERR, PLOGLOC, NULL,
+			"failed to get buffer to send.\n");
+		goto end;
 	}
-#endif
 
-	iph1->sendbuf = isakmp_plist_set_all (&plist, iph1);
+	/* set isakmp header */
+	p = set_isakmp_header(iph1->sendbuf, iph1);
+	if (p.buff == NULL)
+		goto end;
+
+	/* set SA payload to propose */
+	p = set_isakmp_payload_c(p, iph1->sa, ISAKMP_NPTYPE_SA);
 
 #ifdef HAVE_PRINT_ISAKMP_C
 	isakmp_printpacket(iph1->sendbuf, iph1->local, iph1->remote, 0);
 #endif
 
 	/* send the packet, add to the schedule to resend */
-	iph1->retry_counter = iph1->rmconf->retry_counter;
+	iph1->retry_counter = ikev1_max_retry_to_send(iph1->rmconf);
 	if (isakmp_ph1resend(iph1) == -1)
 		goto end;
 
@@ -217,24 +160,6 @@
 	error = 0;
 
 end:
-#ifdef ENABLE_FRAG
-	if (vid_frag) 
-		vfree(vid_frag);
-#endif  
-#ifdef ENABLE_NATT
-	for (i = 0; i < MAX_NATT_VID_COUNT && vid_natt[i] != NULL; i++)
-		vfree(vid_natt[i]);
-#endif
-#ifdef ENABLE_HYBRID
-	if (vid_xauth != NULL)
-		vfree(vid_xauth);
-	if (vid_unity != NULL)
-		vfree(vid_unity);
-#endif
-#ifdef ENABLE_DPD
-	if (vid_dpd != NULL)
-		vfree(vid_dpd);
-#endif
 
 	return error;
 }
@@ -255,11 +180,10 @@
 	struct isakmp_parse_t *pa;
 	vchar_t *satmp = NULL;
 	int error = -1;
-	int vid_numeric;
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG1SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -281,10 +205,11 @@
 
 	/* SA payload is fixed postion */
 	if (pa->type != ISAKMP_NPTYPE_SA) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"received invalid next payload type %d, "
-			"expecting %d.\n",
-			pa->type, ISAKMP_NPTYPE_SA);
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "received invalid next payload type %d, "
+			   "expecting %d.\n",
+			   pa->type, ISAKMP_NPTYPE_SA);
 		goto end;
 	}
 	if (isakmp_p2ph(&satmp, pa->ptr) < 0)
@@ -297,53 +222,24 @@
 
 		switch (pa->type) {
 		case ISAKMP_NPTYPE_VID:
-			vid_numeric = check_vendorid(pa->ptr);
-#ifdef ENABLE_NATT
-			if (iph1->rmconf->nat_traversal && natt_vendorid(vid_numeric))
-			  natt_handle_vendorid(iph1, vid_numeric);
-#endif
-#ifdef ENABLE_HYBRID
-			switch (vid_numeric) {
-			case VENDORID_XAUTH:
-				iph1->mode_cfg->flags |=
-				    ISAKMP_CFG_VENDORID_XAUTH;
-				break;
-	
-			case VENDORID_UNITY:
-				iph1->mode_cfg->flags |=
-				    ISAKMP_CFG_VENDORID_UNITY;
-				break;
-	
-			default:
-				break;
-			}
-#endif  
-#ifdef ENABLE_DPD
-			if (vid_numeric == VENDORID_DPD && iph1->rmconf->dpd)
-				iph1->dpd_support=1;
-#endif
+			(void)check_vendorid(pa->ptr);
 			break;
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
-#ifdef ENABLE_NATT
-	if (NATT_AVAILABLE(iph1))
-		plog(LLV_INFO, LOCATION, iph1->remote,
-		     "Selected NAT-T version: %s\n",
-		     vid_string_by_id(iph1->natt_options->version));
-#endif
-
 	/* check SA payload and set approval SA for use */
 	if (ipsecdoi_checkph1proposal(satmp, iph1) < 0) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"failed to get valid proposal.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "failed to get valid proposal.\n");
 		/* XXX send information */
 		goto end;
 	}
@@ -379,14 +275,14 @@
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG2RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
 
 	/* fix isakmp index */
 	memcpy(&iph1->index.r_ck, &((struct isakmp *)msg->v)->r_ck,
-		sizeof(cookie_t));
+		sizeof(isakmp_cookie_t));
 
 	/* generate DH public value */
 	if (oakley_dh_generate(iph1->approval->dhgrp,
@@ -394,12 +290,12 @@
 		goto end;
 
 	/* generate NONCE value */
-	iph1->nonce = eay_set_random(iph1->rmconf->nonce_size);
+	iph1->nonce = eay_set_random(ikev1_nonce_size(iph1->rmconf));
 	if (iph1->nonce == NULL)
 		goto end;
 
 #ifdef HAVE_GSSAPI
-	if (AUTHMETHOD(iph1) == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB &&
+	if (iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB &&
 	    gssapi_get_itoken(iph1, NULL) < 0)
 		goto end;
 #endif
@@ -414,13 +310,13 @@
 #endif
 
 	/* send the packet, add to the schedule to resend */
-	iph1->retry_counter = iph1->rmconf->retry_counter;
+	iph1->retry_counter = ikev1_max_retry_to_send(iph1->rmconf);
 	if (isakmp_ph1resend(iph1) == -1)
 		goto end;
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph1->remote, iph1->local, iph1->sendbuf, msg) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR , PLOGLOC, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -452,14 +348,10 @@
 #ifdef HAVE_GSSAPI
 	vchar_t *gsstoken = NULL;
 #endif
-#ifdef ENABLE_NATT
-	vchar_t	*natd_received;
-	int natd_seq = 0, natd_verified;
-#endif
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG2SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -485,10 +377,12 @@
 		case ISAKMP_NPTYPE_VID:
 			(void)check_vendorid(pa->ptr);
 			break;
+#ifdef HAVE_SIGNING_C
 		case ISAKMP_NPTYPE_CR:
 			if (oakley_savecr(iph1, pa->ptr) < 0)
 				goto end;
 			break;
+#endif
 #ifdef HAVE_GSSAPI
 		case ISAKMP_NPTYPE_GSS:
 			if (isakmp_p2ph(&gsstoken, pa->ptr) < 0)
@@ -496,69 +390,31 @@
 			gssapi_save_received_token(iph1, gsstoken);
 			break;
 #endif
-
-#ifdef ENABLE_NATT
-		case ISAKMP_NPTYPE_NATD_DRAFT:
-		case ISAKMP_NPTYPE_NATD_RFC:
-			if (NATT_AVAILABLE(iph1) && iph1->natt_options &&
-			    pa->type == iph1->natt_options->payload_nat_d) {
-				natd_received = NULL;
-				if (isakmp_p2ph (&natd_received, pa->ptr) < 0)
-					goto end;
-                        
-				/* set both bits first so that we can clear them
-				   upon verifying hashes */
-				if (natd_seq == 0)
-					iph1->natt_flags |= NAT_DETECTED;
-                        
-				/* this function will clear appropriate bits bits 
-				   from iph1->natt_flags */
-				natd_verified = natt_compare_addr_hash (iph1,
-					natd_received, natd_seq++);
-                        
-				plog (LLV_INFO, LOCATION, NULL, "NAT-D payload #%d %s\n",
-					natd_seq - 1,
-					natd_verified ? "verified" : "doesn't match");
-                        
-				vfree (natd_received);
-				break;
-			}
-			/* passthrough to default... */
-#endif
-
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
-#ifdef ENABLE_NATT
-	if (NATT_AVAILABLE(iph1)) {
-		plog (LLV_INFO, LOCATION, NULL, "NAT %s %s%s\n",
-		      iph1->natt_flags & NAT_DETECTED ? 
-		      		"detected:" : "not detected",
-		      iph1->natt_flags & NAT_DETECTED_ME ? "ME " : "",
-		      iph1->natt_flags & NAT_DETECTED_PEER ? "PEER" : "");
-		if (iph1->natt_flags & NAT_DETECTED)
-			natt_float_ports (iph1);
-	}
-#endif
-
 	/* payload existency check */
 	if (iph1->dhpub_p == NULL || iph1->nonce_p == NULL) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "few isakmp message received.\n");
 		goto end;
 	}
 
+#ifdef HAVE_SIGNING_C
 	if (oakley_checkcr(iph1) < 0) {
 		/* Ignore this error in order to be interoperability. */
 		;
 	}
+#endif
 
 	iph1->status = PHASE1ST_MSG3RECEIVED;
 
@@ -599,7 +455,7 @@
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG3RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -624,9 +480,9 @@
 		goto end;
 
 #ifdef HAVE_GSSAPI
-	if (AUTHMETHOD(iph1) == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB &&
+	if (iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB &&
 	    gssapi_more_tokens(iph1)) {
-		plog(LLV_DEBUG, LOCATION, NULL, "calling get_itoken\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "calling get_itoken\n");
 		if (gssapi_get_itoken(iph1, &len) < 0)
 			goto end;
 		if (len != 0)
@@ -651,13 +507,13 @@
 		goto end;
 
 	/* send the packet, add to the schedule to resend */
-	iph1->retry_counter = iph1->rmconf->retry_counter;
+	iph1->retry_counter = ikev1_max_retry_to_send(iph1->rmconf);
 	if (isakmp_ph1resend(iph1) == -1)
 		goto end;
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph1->remote, iph1->local, iph1->sendbuf, msg0) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR , PLOGLOC, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -697,16 +553,17 @@
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG3SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
 
 	/* decrypting */
 	if (!ISSET(((struct isakmp *)msg0->v)->flags, ISAKMP_FLAG_E)) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"ignore the packet, "
-			"expecting the packet encrypted.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "ignore the packet, "
+			   "expecting the packet encrypted.\n");
 		goto end;
 	}
 	msg = oakley_do_decrypt(iph1, msg0, iph1->ivm->iv, iph1->ivm->ive);
@@ -732,6 +589,7 @@
 		case ISAKMP_NPTYPE_HASH:
 			iph1->pl_hash = (struct isakmp_pl_hash *)pa->ptr;
 			break;
+#ifdef HAVE_SIGNING_C
 		case ISAKMP_NPTYPE_CERT:
 			if (oakley_savecert(iph1, pa->ptr) < 0)
 				goto end;
@@ -740,6 +598,7 @@
 			if (isakmp_p2ph(&iph1->sig_p, pa->ptr) < 0)
 				goto end;
 			break;
+#endif
 #ifdef HAVE_GSSAPI
 		case ISAKMP_NPTYPE_GSS:
 			if (isakmp_p2ph(&gsstoken, pa->ptr) < 0)
@@ -755,10 +614,11 @@
 			break;
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
@@ -767,8 +627,9 @@
 
 	/* verify identifier */
 	if (ipsecdoi_checkid1(iph1) != 0) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"invalid ID payload.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "invalid ID payload.\n");
 		goto end;
 	}
 
@@ -782,8 +643,6 @@
 				/* msg printed inner oakley_validate_auth() */
 				goto end;
 			}
-			EVT_PUSH(iph1->local, iph1->remote, 
-			    EVTT_PEERPH1AUTH_FAILED, NULL);
 			isakmp_info_send_n1(iph1, type, NULL);
 			goto end;
 		}
@@ -796,8 +655,9 @@
 	 * payload's.
 	 */
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote, "peer's ID:");
-	plogdump(LLV_DEBUG, iph1->id_p->v, iph1->id_p->l);
+	isakmp_log(0,0, iph1->remote, 0,
+		   PLOG_DEBUG, PLOGLOC, "peer's ID:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->id_p->v, iph1->id_p->l);
 
 	/* see handler.h about IV synchronization. */
 	memcpy(iph1->ivm->iv->v, iph1->ivm->ive->v, iph1->ivm->ive->l);
@@ -848,7 +708,7 @@
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG4RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -879,11 +739,10 @@
 	vchar_t *pbuf = NULL;
 	struct isakmp_parse_t *pa;
 	int error = -1;
-	int vid_numeric;
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_START) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -899,10 +758,11 @@
 
 	/* check the position of SA payload */
 	if (pa->type != ISAKMP_NPTYPE_SA) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"received invalid next payload type %d, "
-			"expecting %d.\n",
-			pa->type, ISAKMP_NPTYPE_SA);
+		isakmp_log(0,0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "received invalid next payload type %d, "
+			   "expecting %d.\n",
+			   pa->type, ISAKMP_NPTYPE_SA);
 		goto end;
 	}
 	if (isakmp_p2ph(&iph1->sa, pa->ptr) < 0)
@@ -915,36 +775,7 @@
 
 		switch (pa->type) {
 		case ISAKMP_NPTYPE_VID:
-			vid_numeric = check_vendorid(pa->ptr);
-#ifdef ENABLE_NATT
-			if (iph1->rmconf->nat_traversal && natt_vendorid(vid_numeric))
-				natt_handle_vendorid(iph1, vid_numeric);
-#endif
-#ifdef ENABLE_FRAG
-			if ((vid_numeric == VENDORID_FRAG) &&
-			    (vendorid_frag_cap(pa->ptr) & VENDORID_FRAG_IDENT))
-				iph1->frag = 1;
-#endif   
-#ifdef ENABLE_HYBRID
-			switch (vid_numeric) {
-			case VENDORID_XAUTH:
-				iph1->mode_cfg->flags |=
-				    ISAKMP_CFG_VENDORID_XAUTH;
-				break;
-		
-			case VENDORID_UNITY:
-				iph1->mode_cfg->flags |=
-				    ISAKMP_CFG_VENDORID_UNITY;
-				break;
-	
-			default:  
-				break;
-			}
-#endif
-#ifdef ENABLE_DPD
-			if (vid_numeric == VENDORID_DPD && iph1->rmconf->dpd)
-				iph1->dpd_support=1;
-#endif
+			(void)check_vendorid(pa->ptr);
 			break;
 		default:
 			/*
@@ -954,25 +785,20 @@
 			 * the re-sent packet.  And we do same behavior
 			 * when we expect encrypted packet.
 			 */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
-#ifdef ENABLE_NATT
-	if (NATT_AVAILABLE(iph1))
-		plog(LLV_INFO, LOCATION, iph1->remote,
-		     "Selected NAT-T version: %s\n",
-		     vid_string_by_id(iph1->natt_options->version));
-#endif
-
 	/* check SA payload and set approval SA for use */
 	if (ipsecdoi_checkph1proposal(iph1->sa, iph1) < 0) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"failed to get valid proposal.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "failed to get valid proposal.\n");
 		/* XXX send information */
 		goto end;
 	}
@@ -1003,27 +829,16 @@
 	struct ph1handle *iph1;
 	vchar_t *msg;
 {
-	struct payload_list *plist = NULL;
+	struct isakmp_gen *gen;
+	struct isakmp_construct p;
+	int tlen;
 	int error = -1;
 	vchar_t *gss_sa = NULL;
 	vchar_t *vid = NULL;
-#ifdef ENABLE_NATT
-	vchar_t *vid_natt = NULL;
-#endif
-#ifdef ENABLE_HYBRID
-        vchar_t *vid_xauth = NULL;
-        vchar_t *vid_unity = NULL;
-#endif  
-#ifdef ENABLE_DPD
-	vchar_t *vid_dpd = NULL;
-#endif
-#ifdef ENABLE_FRAG          
-	vchar_t *vid_frag = NULL;
-#endif 
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG1RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -1038,80 +853,44 @@
 #endif
 		gss_sa = iph1->sa_ret;
 
-	/* set SA payload to reply */
-	plist = isakmp_plist_append(plist, gss_sa, ISAKMP_NPTYPE_SA);
+	/* create buffer to send isakmp payload */
+	tlen = sizeof(struct isakmp)
+		+ sizeof(*gen) + gss_sa->l;
 
-	/* Set Vendor ID, if necessary. */
-	if (vid)
-		plist = isakmp_plist_append(plist, vid, ISAKMP_NPTYPE_VID);
+	if ((vid = set_vendorid(iph1->approval->vendorid)) != NULL)
+		tlen += sizeof(*gen) + vid->l;
 
-#ifdef ENABLE_HYBRID
-	if (iph1->mode_cfg->flags & ISAKMP_CFG_VENDORID_XAUTH) {
-		plog (LLV_INFO, LOCATION, NULL, "Adding xauth VID payload.\n");
-		if ((vid_xauth = set_vendorid(VENDORID_XAUTH)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "Cannot create Xauth vendor ID\n");
-			goto end;
-		}
-		plist = isakmp_plist_append(plist,
-		    vid_xauth, ISAKMP_NPTYPE_VID);
+	iph1->sendbuf = vmalloc(tlen);
+	if (iph1->sendbuf == NULL) { 
+		plog(PLOG_INTERR, PLOGLOC, NULL,
+			"failed to get buffer to send.\n");
+		goto end;
 	}
 
-	if (iph1->mode_cfg->flags & ISAKMP_CFG_VENDORID_UNITY) {
-		if ((vid_unity = set_vendorid(VENDORID_UNITY)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "Cannot create Unity vendor ID\n");
-			goto end;
-		}
-		plist = isakmp_plist_append(plist,
-		    vid_unity, ISAKMP_NPTYPE_VID);
-	}
-#endif
-#ifdef ENABLE_NATT
-	/* Has the peer announced NAT-T? */
-	if (NATT_AVAILABLE(iph1))
-		vid_natt = set_vendorid(iph1->natt_options->version);
-
-	if (vid_natt)
-		plist = isakmp_plist_append(plist, vid_natt, ISAKMP_NPTYPE_VID);
-#endif
-#ifdef ENABLE_DPD
-	/* XXX only send DPD VID if remote sent it ? */
-	if(iph1->rmconf->dpd){
-		vid_dpd = set_vendorid(VENDORID_DPD);
-		if (vid_dpd != NULL)
-			plist = isakmp_plist_append(plist, vid_dpd, ISAKMP_NPTYPE_VID);
-	}
-#endif
-#ifdef ENABLE_FRAG
-	if (iph1->frag) {
-		vid_frag = set_vendorid(VENDORID_FRAG);
-		if (vid_frag != NULL)
-			vid_frag = isakmp_frag_addcap(vid_frag,
-			    VENDORID_FRAG_IDENT);
-		if (vid_frag == NULL)
-			plog(LLV_ERROR, LOCATION, NULL,
-			    "Frag vendorID construction failed\n");
-		else
-			plist = isakmp_plist_append(plist, 
-			     vid_frag, ISAKMP_NPTYPE_VID);
-	}
-#endif
+	/* set isakmp header */
+	p = set_isakmp_header(iph1->sendbuf, iph1);
+	if (p.buff == NULL)
+		goto end;
 
-	iph1->sendbuf = isakmp_plist_set_all (&plist, iph1);
+	/* set SA payload to reply */
+	p = set_isakmp_payload_c(p, gss_sa, ISAKMP_NPTYPE_SA);
+
+	/* Set Vendor ID, if necessary. */
+	if (vid)
+		p = set_isakmp_payload_c(p, vid, ISAKMP_NPTYPE_VID);
 
 #ifdef HAVE_PRINT_ISAKMP_C
 	isakmp_printpacket(iph1->sendbuf, iph1->local, iph1->remote, 0);
 #endif
 
 	/* send the packet, add to the schedule to resend */
-	iph1->retry_counter = iph1->rmconf->retry_counter;
+	iph1->retry_counter = ikev1_max_retry_to_send(iph1->rmconf);
 	if (isakmp_ph1resend(iph1) == -1)
 		goto end;
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph1->remote, iph1->local, iph1->sendbuf, msg) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -1127,26 +906,6 @@
 #endif
 	if (vid)
 		vfree(vid);
-
-#ifdef ENABLE_NATT
-	if (vid_natt)
-		vfree(vid_natt);
-#endif
-#ifdef ENABLE_HYBRID
-	if (vid_xauth != NULL)
-		vfree(vid_xauth);
-	if (vid_unity != NULL)
-		vfree(vid_unity);
-#endif
-#ifdef ENABLE_DPD
-	if (vid_dpd != NULL)
-		vfree(vid_dpd);
-#endif
-#ifdef ENABLE_FRAG
-	if (vid_frag != NULL)
-		vfree(vid_frag);
-#endif
-
 	return error;
 }
 
@@ -1170,13 +929,10 @@
 #ifdef HAVE_GSSAPI
 	vchar_t *gsstoken = NULL;
 #endif
-#ifdef ENABLE_NATT
-	int natd_seq = 0;
-#endif
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG1SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -1189,6 +945,7 @@
 	for (pa = (struct isakmp_parse_t *)pbuf->v;
 	     pa->type != ISAKMP_NPTYPE_NONE;
 	     pa++) {
+
 		switch (pa->type) {
 		case ISAKMP_NPTYPE_KE:
 			if (isakmp_p2ph(&iph1->dhpub_p, pa->ptr) < 0)
@@ -1202,9 +959,10 @@
 			(void)check_vendorid(pa->ptr);
 			break;
 		case ISAKMP_NPTYPE_CR:
-			plog(LLV_WARNING, LOCATION, iph1->remote,
-				"CR received, ignore it. "
-				"It should be in other exchange.\n");
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOWARN, PLOGLOC,
+				   "CR received, ignore it. "
+				   "It should be in other exchange.\n");
 			break;
 #ifdef HAVE_GSSAPI
 		case ISAKMP_NPTYPE_GSS:
@@ -1213,57 +971,22 @@
 			gssapi_save_received_token(iph1, gsstoken);
 			break;
 #endif
-
-#ifdef ENABLE_NATT
-		case ISAKMP_NPTYPE_NATD_DRAFT:
-		case ISAKMP_NPTYPE_NATD_RFC:
-			if (pa->type == iph1->natt_options->payload_nat_d)
-			{
-				vchar_t *natd_received = NULL;
-				int natd_verified;
-				
-				if (isakmp_p2ph (&natd_received, pa->ptr) < 0)
-					goto end;
-				
-				if (natd_seq == 0)
-					iph1->natt_flags |= NAT_DETECTED;
-				
-				natd_verified = natt_compare_addr_hash (iph1,
-					natd_received, natd_seq++);
-				
-				plog (LLV_INFO, LOCATION, NULL, "NAT-D payload #%d %s\n",
-					natd_seq - 1,
-					natd_verified ? "verified" : "doesn't match");
-				
-				vfree (natd_received);
-				break;
-			}
-			/* passthrough to default... */
-#endif
-
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
-#ifdef ENABLE_NATT
-	if (NATT_AVAILABLE(iph1))
-		plog (LLV_INFO, LOCATION, NULL, "NAT %s %s%s\n",
-		      iph1->natt_flags & NAT_DETECTED ? 
-		      		"detected:" : "not detected",
-		      iph1->natt_flags & NAT_DETECTED_ME ? "ME " : "",
-		      iph1->natt_flags & NAT_DETECTED_PEER ? "PEER" : "");
-#endif
-
 	/* payload existency check */
 	if (iph1->dhpub_p == NULL || iph1->nonce_p == NULL) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "few isakmp message received.\n");
 		goto end;
 	}
 
@@ -1305,7 +1028,7 @@
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG2RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -1316,12 +1039,12 @@
 		goto end;
 
 	/* generate NONCE value */
-	iph1->nonce = eay_set_random(iph1->rmconf->nonce_size);
+	iph1->nonce = eay_set_random(ikev1_nonce_size(iph1->rmconf));
 	if (iph1->nonce == NULL)
 		goto end;
 
 #ifdef HAVE_GSSAPI
-	if (AUTHMETHOD(iph1) == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB)
+	if (iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB)
 		gssapi_get_rtoken(iph1, NULL);
 #endif
 
@@ -1335,13 +1058,13 @@
 #endif
 
 	/* send the packet, add to the schedule to resend */
-	iph1->retry_counter = iph1->rmconf->retry_counter;
+	iph1->retry_counter = ikev1_max_retry_to_send(iph1->rmconf);
 	if (isakmp_ph1resend(iph1) == -1)
 		goto end;
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph1->remote, iph1->local, iph1->sendbuf, msg) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -1393,16 +1116,17 @@
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG2SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
 
 	/* decrypting */
 	if (!ISSET(((struct isakmp *)msg0->v)->flags, ISAKMP_FLAG_E)) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"reject the packet, "
-			"expecting the packet encrypted.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "reject the packet, "
+			   "expecting the packet encrypted.\n");
 		goto end;
 	}
 	msg = oakley_do_decrypt(iph1, msg0, iph1->ivm->iv, iph1->ivm->ive);
@@ -1428,6 +1152,7 @@
 		case ISAKMP_NPTYPE_HASH:
 			iph1->pl_hash = (struct isakmp_pl_hash *)pa->ptr;
 			break;
+#ifdef HAVE_SIGNING_C
 		case ISAKMP_NPTYPE_CR:
 			if (oakley_savecr(iph1, pa->ptr) < 0)
 				goto end;
@@ -1440,6 +1165,7 @@
 			if (isakmp_p2ph(&iph1->sig_p, pa->ptr) < 0)
 				goto end;
 			break;
+#endif
 #ifdef HAVE_GSSAPI
 		case ISAKMP_NPTYPE_GSS:
 			if (isakmp_p2ph(&gsstoken, pa->ptr) < 0)
@@ -1455,10 +1181,11 @@
 			break;
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
@@ -1468,31 +1195,18 @@
     {
 	int ng = 0;
 
-	switch (AUTHMETHOD(iph1)) {
+	switch (iph1->approval->authmethod) {
 	case OAKLEY_ATTR_AUTH_METHOD_PSKEY:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_R:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_R:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_R:
-#endif
 		if (iph1->id_p == NULL || iph1->pl_hash == NULL)
 			ng++;
 		break;
 	case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
 	case OAKLEY_ATTR_AUTH_METHOD_RSASIG:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_R:
-#endif
 		if (iph1->id_p == NULL || iph1->sig_p == NULL)
 			ng++;
 		break;
 	case OAKLEY_ATTR_AUTH_METHOD_RSAENC:
 	case OAKLEY_ATTR_AUTH_METHOD_RSAREV:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_R:
-#endif
 		if (iph1->pl_hash == NULL)
 			ng++;
 		break;
@@ -1503,22 +1217,25 @@
 		break;
 #endif
 	default:
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"invalid authmethod %d why ?\n",
-			iph1->approval->authmethod);
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_INTERR, PLOGLOC,
+			   "invalid authmethod %d why ?\n",
+			   iph1->approval->authmethod);
 		goto end;
 	}
 	if (ng) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "few isakmp message received.\n");
 		goto end;
 	}
     }
 
 	/* verify identifier */
 	if (ipsecdoi_checkid1(iph1) != 0) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
-			"invalid ID payload.\n");
+		isakmp_log(0, 0, iph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "invalid ID payload.\n");
 		goto end;
 	}
 
@@ -1532,8 +1249,6 @@
 				/* msg printed inner oakley_validate_auth() */
 				goto end;
 			}
-			EVT_PUSH(iph1->local, iph1->remote, 
-			    EVTT_PEERPH1AUTH_FAILED, NULL);
 			isakmp_info_send_n1(iph1, type, NULL);
 			goto end;
 		}
@@ -1541,18 +1256,22 @@
 	}
 #endif
 
+#ifdef HAVE_SIGNING_C
 	if (oakley_checkcr(iph1) < 0) {
 		/* Ignore this error in order to be interoperability. */
 		;
 	}
+#endif
 
 	/*
 	 * XXX: Should we do compare two addresses, ph1handle's and ID
 	 * payload's.
 	 */
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote, "peer's ID\n");
-	plogdump(LLV_DEBUG, iph1->id_p->v, iph1->id_p->l);
+	isakmp_log(0,0, iph1->remote, 0,
+		   PLOG_DEBUG, PLOGLOC,
+		   "peer's ID\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->id_p->v, iph1->id_p->l);
 
 	/* see handler.h about IV synchronization. */
 	memcpy(iph1->ivm->iv->v, iph1->ivm->ive->v, iph1->ivm->ive->l);
@@ -1611,7 +1330,7 @@
 
 	/* validity check */
 	if (iph1->status != PHASE1ST_MSG3RECEIVED) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph1->status);
 		goto end;
 	}
@@ -1621,7 +1340,7 @@
 		goto end;
 
 #ifdef HAVE_GSSAPI
-	if (AUTHMETHOD(iph1) == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB &&
+	if (iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB &&
 	    gssapi_more_tokens(iph1)) {
 		gssapi_get_rtoken(iph1, &len);
 		if (len != 0)
@@ -1631,7 +1350,7 @@
 
 	if (dohash) {
 		/* generate HASH to send */
-		plog(LLV_DEBUG, LOCATION, NULL, "generate HASH_R\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "generate HASH_R\n");
 		iph1->hash = oakley_ph1hash_common(iph1, GENERATE);
 		if (iph1->hash == NULL)
 			goto end;
@@ -1652,7 +1371,7 @@
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph1->remote, iph1->local, iph1->sendbuf, msg) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -1688,7 +1407,9 @@
 	struct ph1handle *iph1;
 {
 	vchar_t *buf = 0;
-	struct payload_list *plist = NULL;
+	struct isakmp_gen *gen;
+	struct isakmp_construct p;
+	int tlen;
 	int need_cr = 0;
 	vchar_t *cr = NULL;
 	vchar_t *vid = NULL;
@@ -1696,72 +1417,73 @@
 #ifdef HAVE_GSSAPI
 	vchar_t *gsstoken = NULL;
 #endif
-#ifdef ENABLE_NATT
-	vchar_t *natd[2] = { NULL, NULL };
-#endif
 
+#ifdef HAVE_SIGNING_C
 	/* create CR if need */
 	if (iph1->side == RESPONDER
-	 && iph1->rmconf->send_cr
+	    && ikev1_send_cert_req(iph1->rmconf) == RCT_BOOL_ON
 	 && oakley_needcr(iph1->approval->authmethod)
-	 && iph1->rmconf->peerscertfile == NULL) {
+	 && ikev1_public_key(iph1->rmconf) == NULL) {
 		need_cr = 1;
 		cr = oakley_getcr(iph1);
 		if (cr == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to get cr buffer.\n");
 			goto end;
 		}
 	}
+#endif
 
 #ifdef HAVE_GSSAPI
-	if (AUTHMETHOD(iph1) == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB)
+	if (iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB)
 		gssapi_get_token_to_send(iph1, &gsstoken);
 #endif
 
+	/* create buffer */
+	tlen = sizeof(struct isakmp)
+	     + sizeof(*gen) + iph1->dhpub->l
+	     + sizeof(*gen) + iph1->nonce->l;
+	if ((vid = set_vendorid(iph1->approval->vendorid)) != NULL)
+		tlen += sizeof(*gen) + vid->l;
+	if (need_cr)
+		tlen += sizeof(*gen) + cr->l;
+#ifdef HAVE_GSSAPI
+	if (gsstoken)
+		tlen += sizeof(*gen) + gsstoken->l;
+#endif
+
+	buf = vmalloc(tlen);
+	if (buf == NULL) {
+		plog(PLOG_INTERR, PLOGLOC, NULL,
+			"failed to get buffer to send.\n");
+		goto end;
+	}
+
+	/* set isakmp header */
+	p = set_isakmp_header(buf, iph1);
+	if (p.buff == NULL)
+		goto end;
+
 	/* create isakmp KE payload */
-	plist = isakmp_plist_append(plist, iph1->dhpub, ISAKMP_NPTYPE_KE);
+	p = set_isakmp_payload_c(p, iph1->dhpub, ISAKMP_NPTYPE_KE);
 
 	/* create isakmp NONCE payload */
-	plist = isakmp_plist_append(plist, iph1->nonce, ISAKMP_NPTYPE_NONCE);
+	p = set_isakmp_payload_c(p, iph1->nonce, ISAKMP_NPTYPE_NONCE);
 
 #ifdef HAVE_GSSAPI
-	if (AUTHMETHOD(iph1) == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB)
-		plist = isakmp_plist_append(plist, gsstoken, ISAKMP_NPTYPE_GSS);
+	if (iph1->approval->authmethod == OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB) {
+		p = set_isakmp_payload_c(p, gsstoken, ISAKMP_NPTYPE_GSS);
+	}
 #endif
 
 	/* append vendor id, if needed */
 	if (vid)
-		plist = isakmp_plist_append(plist, vid, ISAKMP_NPTYPE_VID);
+		p = set_isakmp_payload_c(p, vid, ISAKMP_NPTYPE_VID);
 
 	/* create isakmp CR payload if needed */
 	if (need_cr)
-		plist = isakmp_plist_append(plist, cr, ISAKMP_NPTYPE_CR);
+		p = set_isakmp_payload_c(p, cr, ISAKMP_NPTYPE_CR);
 
-#ifdef ENABLE_NATT
-	/* generate and append NAT-D payloads */
-	if (NATT_AVAILABLE(iph1) && iph1->status == PHASE1ST_MSG2RECEIVED)
-	{
-		if ((natd[0] = natt_hash_addr (iph1, iph1->remote)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"NAT-D hashing failed for %s\n", saddr2str(iph1->remote));
-			goto end;
-		}
-
-		if ((natd[1] = natt_hash_addr (iph1, iph1->local)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"NAT-D hashing failed for %s\n", saddr2str(iph1->local));
-			goto end;
-		}
-
-		plog (LLV_INFO, LOCATION, NULL, "Adding remote and local NAT-D payloads.\n");
-		plist = isakmp_plist_append(plist, natd[0], iph1->natt_options->payload_nat_d);
-		plist = isakmp_plist_append(plist, natd[1], iph1->natt_options->payload_nat_d);
-	}
-#endif
-	
-	buf = isakmp_plist_set_all (&plist, iph1);
-	
 	error = 0;
 
 end:
@@ -1778,13 +1500,6 @@
 	if (vid)
 		vfree(vid);
 
-#ifdef ENABLE_NATT
-	if (natd[0])
-		vfree(natd[0]);
-	if (natd[1])
-		vfree(natd[1]);
-#endif
-
 	return buf;
 }
 
@@ -1807,42 +1522,47 @@
 ident_ir3mx(iph1)
 	struct ph1handle *iph1;
 {
-	struct payload_list *plist = NULL;
 	vchar_t *buf = NULL, *new = NULL;
+	struct isakmp_construct p;
+	int tlen;
+	struct isakmp_gen *gen;
 	int need_cr = 0;
 	int need_cert = 0;
 	vchar_t *cr = NULL;
 	int error = -1;
 #ifdef HAVE_GSSAPI
-	int nptype;
 	vchar_t *gsstoken = NULL;
 	vchar_t *gsshash = NULL;
 #endif
 
-	switch (AUTHMETHOD(iph1)) {
+	tlen = sizeof(struct isakmp);
+
+	switch (iph1->approval->authmethod) {
 	case OAKLEY_ATTR_AUTH_METHOD_PSKEY:
-#ifdef ENABLE_HYBRID
-	case FICTIVE_AUTH_METHOD_XAUTH_PSKEY_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_R:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_I:
-#endif
+		tlen += sizeof(*gen) + iph1->id->l
+			+ sizeof(*gen) + iph1->hash->l;
+
+		buf = vmalloc(tlen);
+		if (buf == NULL) {
+			plog(PLOG_INTERR, PLOGLOC, NULL,
+				"failed to get buffer to send.\n");
+			goto end;
+		}
+
+		/* set isakmp header */
+		p = set_isakmp_header(buf, iph1);
+		if (p.buff == NULL)
+			goto end;
+
 		/* create isakmp ID payload */
-		plist = isakmp_plist_append(plist, iph1->id, ISAKMP_NPTYPE_ID);
+		p = set_isakmp_payload_c(p, iph1->id, ISAKMP_NPTYPE_ID);
 
 		/* create isakmp HASH payload */
-		plist = isakmp_plist_append(plist, iph1->hash, ISAKMP_NPTYPE_HASH);
+		p = set_isakmp_payload_c(p, iph1->hash, ISAKMP_NPTYPE_HASH);
 		break;
+#ifdef HAVE_SIGNING_C
 	case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
 	case OAKLEY_ATTR_AUTH_METHOD_RSASIG:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_R:
-	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSASIG_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_DSSSIG_R:
-#endif 
 		if (oakley_getmycert(iph1) < 0)
 			goto end;
 
@@ -1851,78 +1571,108 @@
 
 		/* create CR if need */
 		if (iph1->side == INITIATOR
-		 && iph1->rmconf->send_cr
-	 	 && oakley_needcr(iph1->approval->authmethod)
-		 && iph1->rmconf->peerscertfile == NULL) {
+		    && ikev1_send_cert_req(iph1->rmconf) == RCT_BOOL_ON
+		    && oakley_needcr(iph1->approval->authmethod)
+		    && ikev1_public_key(iph1->rmconf) == NULL) {
 			need_cr = 1;
 			cr = oakley_getcr(iph1);
 			if (cr == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to get cr buffer.\n");
 				goto end;
 			}
 		}
 
-		if (iph1->cert != NULL && iph1->rmconf->send_cert)
+		if (iph1->cert != NULL && ikev1_send_cert(iph1->rmconf) == RCT_BOOL_ON)
 			need_cert = 1;
 
+		tlen += sizeof(*gen) + iph1->id->l
+			+ sizeof(*gen) + iph1->sig->l;
+		if (need_cert)
+			tlen += sizeof(*gen) + iph1->cert->pl->l;
+		if (need_cr)
+			tlen += sizeof(*gen) + cr->l;
+
+		buf = vmalloc(tlen);
+		if (buf == NULL) {
+			plog(PLOG_INTERR, PLOGLOC, NULL,
+				"failed to get buffer to send.\n");
+			goto end;
+		}
+
+		/* set isakmp header */
+		p = set_isakmp_header(buf, iph1);
+		if (p.buff == NULL)
+			goto end;
+
 		/* add ID payload */
-		plist = isakmp_plist_append(plist, iph1->id, ISAKMP_NPTYPE_ID);
+		p = set_isakmp_payload_c(p, iph1->id, ISAKMP_NPTYPE_ID);
 
 		/* add CERT payload if there */
 		if (need_cert)
-			plist = isakmp_plist_append(plist, iph1->cert->pl, ISAKMP_NPTYPE_CERT);
+			p = set_isakmp_payload_c(p, iph1->cert->pl, ISAKMP_NPTYPE_CERT);
 		/* add SIG payload */
-		plist = isakmp_plist_append(plist, iph1->sig, ISAKMP_NPTYPE_SIG);
+		p = set_isakmp_payload_c(p, iph1->sig, ISAKMP_NPTYPE_SIG);
 
 		/* create isakmp CR payload */
 		if (need_cr)
-			plist = isakmp_plist_append(plist, cr, ISAKMP_NPTYPE_CR);
+			p = set_isakmp_payload_c(p, cr, ISAKMP_NPTYPE_CR);
 		break;
+#endif
 #ifdef HAVE_GSSAPI
 	case OAKLEY_ATTR_AUTH_METHOD_GSSAPI_KRB:
+		if (!gssapi_id_sent(iph1))
+			tlen += sizeof (*gen) + iph1->id->l;
 		if (iph1->hash != NULL) {
 			gsshash = gssapi_wraphash(iph1);
 			if (gsshash == NULL)
 				goto end;
+			tlen += sizeof (*gen) + gsshash->l;
 		} else {
 			gssapi_get_token_to_send(iph1, &gsstoken);
+			tlen += sizeof (*gen) + gsstoken->l;
+		}
+
+		buf = vmalloc(tlen);
+		if (buf == NULL) {
+			plog(PLOG_INTERR, PLOGLOC, NULL,
+				"failed to get buffer to send.\n");
+			goto end;
 		}
 
+		/* set isakmp header */
+		p = set_isakmp_header(buf, iph1);
+		if (p.buff == NULL)
+			goto end;
+
 		if (!gssapi_id_sent(iph1)) {
 			/* create isakmp ID payload */
-			plist = isakmp_plist_append(plist, iph1->id, ISAKMP_NPTYPE_ID);
+			p = set_isakmp_payload_c(p, iph1->id, ISAKMP_NPTYPE_ID);
+			if (p.buff == NULL)
+				goto end;
 			gssapi_set_id_sent(iph1);
 		}
 
 		if (iph1->hash != NULL)
 			/* create isakmp HASH payload */
-			plist = isakmp_plist_append(plist, gsshash, ISAKMP_NPTYPE_HASH);
+			p = set_isakmp_payload_c(p, gsshash, ISAKMP_NPTYPE_HASH);
 		else
-			plist = isakmp_plist_append(plist, gsstoken, ISAKMP_NPTYPE_GSS);
+			p = set_isakmp_payload_c(p, gsstoken, ISAKMP_NPTYPE_GSS);
 		break;
 #endif
 	case OAKLEY_ATTR_AUTH_METHOD_RSAENC:
 	case OAKLEY_ATTR_AUTH_METHOD_RSAREV:
-#ifdef ENABLE_HYBRID
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAENC_R:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_I:
-	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_R:
-#endif
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"not supported authentication type %d\n",
 			iph1->approval->authmethod);
 		goto end;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid authentication type %d\n",
 			iph1->approval->authmethod);
 		goto end;
 	}
 
-	buf = isakmp_plist_set_all (&plist, iph1);
-	
 #ifdef HAVE_PRINT_ISAKMP_C
 	isakmp_printpacket(buf, iph1->local, iph1->remote, 1);
 #endif
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_ident.h ./isakmp_ident.h
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_ident.h	Sat Jun 12 01:00:16 2004
+++ ./isakmp_ident.h	Mon Nov  7 19:06:48 2005
@@ -1,4 +1,4 @@
-/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/*	$KAME: isakmp_ident.h,v 1.4 2000/10/04 17:41:00 itojun Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -29,9 +29,6 @@
  * SUCH DAMAGE.
  */
 
-#ifndef _ISAKMP_IDENT_H
-#define _ISAKMP_IDENT_H
-
 extern int ident_i1send __P((struct ph1handle *, vchar_t *));
 extern int ident_i2recv __P((struct ph1handle *, vchar_t *));
 extern int ident_i2send __P((struct ph1handle *, vchar_t *));
@@ -46,5 +43,3 @@
 extern int ident_r2send __P((struct ph1handle *, vchar_t *));
 extern int ident_r3recv __P((struct ph1handle *, vchar_t *));
 extern int ident_r3send __P((struct ph1handle *, vchar_t *));
-
-#endif /* _ISAKMP_IDENT_H */
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_inf.c ./isakmp_inf.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_inf.c	Tue Nov  1 15:21:53 2005
+++ ./isakmp_inf.c	Thu Feb  2 17:02:07 2006
@@ -29,7 +29,7 @@
  * SUCH DAMAGE.
  */
 
-#include "config.h"
+#include <config.h>
 
 #include <sys/types.h>
 #include <sys/param.h>
@@ -38,11 +38,13 @@
 #include <net/pfkeyv2.h>
 #include <netinet/in.h>
 #include <sys/queue.h>
+#if 0
 #ifndef HAVE_NETINET6_IPSEC
 #include <netinet/ipsec.h>
 #else
 #include <netinet6/ipsec.h>
 #endif
+#endif
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -62,24 +64,23 @@
 #include <resolv.h>
 #endif
 
-#include "libpfkey.h"
+/* #include "libpfkey.h" */
 
 #include "var.h"
 #include "vmbuf.h"
-#include "schedule.h"
+/* #include "schedule.h" */
 #include "str2val.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "plog.h"
 #include "debug.h"
 
-#include "localconf.h"
+/* #include "localconf.h" */
 #include "remoteconf.h"
-#include "sockmisc.h"
-#include "handler.h"
 #include "proposal.h"
-#include "isakmp_var.h"
+#include "sockmisc.h"
 #include "evt.h"
 #include "isakmp.h"
+#include "isakmp_var.h"
 #ifdef ENABLE_HYBRID
 #include "isakmp_xauth.h"
 #include "isakmp_unity.h"
@@ -88,17 +89,20 @@
 #include "isakmp_inf.h"
 #include "oakley.h"
 #include "ipsec_doi.h"
-#include "crypto_openssl.h"
-#include "pfkey.h"
-#include "policy.h"
+#include "isakmp_impl.h"
+#include "handler.h"
+#include "crypto_impl.h"
+/* #include "pfkey.h" */
+/* #include "policy.h" */
 #include "algorithm.h"
-#include "proposal.h"
-#include "admin.h"
+/* #include "admin.h" */
 #include "strnames.h"
 #ifdef ENABLE_NATT
 #include "nattraversal.h"
 #endif
 
+#include "racoon.h"
+
 /* information exchange */
 static int isakmp_info_recv_n (struct ph1handle *, struct isakmp_pl_n *, u_int32_t, int);
 static int isakmp_info_recv_d (struct ph1handle *, struct isakmp_pl_d *, u_int32_t, int);
@@ -111,7 +115,7 @@
 static void isakmp_info_send_r_u __P((void *));
 #endif
 
-static void purge_isakmp_spi __P((int, isakmp_index *, size_t));
+static void purge_isakmp_spi __P((int, isakmp_index_t *, size_t));
 static void info_recv_initialcontact __P((struct ph1handle *));
 
 /* %%%
@@ -139,7 +143,7 @@
 	int encrypted;
 	int flag;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "receive Information.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "receive Information.\n");
 
 	encrypted = ISSET(((struct isakmp *)msg0->v)->flags, ISAKMP_FLAG_E);
 	msgid = ((struct isakmp *)msg0->v)->msgid;
@@ -149,7 +153,7 @@
 		struct isakmp_ivm *ivm;
 
 		if (iph1->ivm == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL, "iph1->ivm == NULL\n");
+			plog(PLOG_INTERR, PLOGLOC, NULL, "iph1->ivm == NULL\n");
 			return -1;
 		}
 
@@ -168,7 +172,7 @@
 
 	/* Safety check */
 	if (msg->l < sizeof(*isakmp) + sizeof(*gen)) {
-		plog(LLV_ERROR, LOCATION, NULL, 
+		plog(PLOG_PROTOERR, PLOGLOC, NULL, 
 			"ignore information because the "
 			"message is way too short\n");
 		goto end;
@@ -180,14 +184,14 @@
 
 	if (encrypted) {
 		if (isakmp->np != ISAKMP_NPTYPE_HASH) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			    "ignore information because the"
 			    "message has no hash payload.\n");
 			goto end;
 		}
 
 		if (iph1->status != PHASE1ST_ESTABLISHED) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			    "ignore information because ISAKMP-SA"
 			    "has not been established yet.\n");
 			goto end;
@@ -195,7 +199,7 @@
 		
 		/* Safety check */
 		if (msg->l < sizeof(*isakmp) + ntohs(gen->len) + sizeof(*nd)) {
-			plog(LLV_ERROR, LOCATION, NULL, 
+			plog(PLOG_PROTOERR, PLOGLOC, NULL, 
 				"ignore information because the "
 				"message is too short\n");
 			goto end;
@@ -207,20 +211,20 @@
 		/* nd length check */
 		if (ntohs(nd->len) > msg->l - (sizeof(struct isakmp) +
 		    ntohs(gen->len))) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				 "too long payload length (broken message?)\n");
 			goto end;
 		}
 
 		if (ntohs(nd->len) < sizeof(*nd)) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"too short payload length (broken message?)\n");
 			goto end;
 		}
 
 		payload = vmalloc(ntohs(nd->len));
 		if (payload == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 			    "cannot allocate memory\n");
 			goto end;
 		}
@@ -230,7 +234,7 @@
 		/* compute HASH */
 		hash = oakley_compute_hash1(iph1, isakmp->msgid, payload);
 		if (hash == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 			    "cannot compute hash\n");
 
 			vfree(payload);
@@ -238,7 +242,7 @@
 		}
 		
 		if (ntohs(gen->len) - sizeof(struct isakmp_gen) != hash->l) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			    "ignore information due to hash length mismatch\n");
 
 			vfree(hash);
@@ -247,7 +251,7 @@
 		}
 
 		if (memcmp(p, hash->v, hash->l) != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			    "ignore information due to hash mismatch\n");
 
 			vfree(hash);
@@ -255,7 +259,7 @@
 			goto end;
 		}
 
-		plog(LLV_DEBUG, LOCATION, NULL, "hash validated.\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "hash validated.\n");
 
 		vfree(hash);
 		vfree(payload);
@@ -271,7 +275,7 @@
 			}
 			/*FALLTHRU*/
 		default:
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"%s message must be encrypted\n",
 				s_isakmp_nptype(np));
 			error = 0;
@@ -303,13 +307,13 @@
 		case ISAKMP_NPTYPE_NONCE:
 			/* XXX to be 6.4.2 ike-01.txt */
 			/* XXX IV is to be synchronized. */
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"ignore Acknowledged Informational\n");
 			break;
 		default:
 			/* don't send information, see isakmp_ident_r1() */
 			error = 0;
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"reject the packet, "
 				"received unexpected payload type %s.\n",
 				s_isakmp_nptype(gen->np));
@@ -380,24 +384,24 @@
 		   type <= ISAKMP_NTYPE_MAXERROR) {
 			if (msgid == 0) {
 				/* don't think this realy deletes ph1 ? */
-				plog(LLV_ERROR, LOCATION, iph1->remote,
+				plog(PLOG_PROTOERR, PLOGLOC, 0,
 					"delete phase1 handle.\n");
 				return -1;
 			} else {
 				if (getph2bymsgid(iph1, msgid) == NULL) {
-					plog(LLV_ERROR, LOCATION, iph1->remote,
+					plog(PLOG_PROTOERR, PLOGLOC, 0,
 						"fatal %s notify messsage, "
 						"phase1 should be deleted.\n",
 						s_isakmp_notify_msg(type));
 				} else {
-					plog(LLV_ERROR, LOCATION, iph1->remote,
+					plog(PLOG_PROTOERR, PLOGLOC, 0,
 						"fatal %s notify messsage, "
 						"phase2 should be deleted.\n",
 						s_isakmp_notify_msg(type));
 				}
 			}
 		} else {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"unhandled notify message %s, "
 				"no phase2 handle found.\n",
 				s_isakmp_notify_msg(type));
@@ -409,13 +413,13 @@
 	/* get spi if specified and allocate */
 	if(notify->spi_size > 0) {
 		if (ntohs(notify->h.len) < sizeof(*notify) + notify->spi_size) {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"invalid spi_size in notification payload.\n");
 			return -1;
 		}
 		spi = val2str((char *)(notify + 1), notify->spi_size);
 
-		plog(LLV_DEBUG, LOCATION, iph1->remote,
+		plog(PLOG_DEBUG, PLOGLOC, 0,
 			"notification message %d:%s, "
 			"doi=%d proto_id=%d spi=%s(size=%d).\n",
 			type, s_isakmp_notify_msg(type),
@@ -433,7 +437,7 @@
 			nraw += sizeof(*notify) + notify->spi_size;
 			ndata = vmalloc(l);
 			memcpy(ndata->v, nraw, ndata->l);
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"Message: '%s'.\n", 
 				binsanitize(ndata->v, ndata->l));
 			vfree(ndata);
@@ -462,7 +466,7 @@
 	} spi;
 
 	if (ntohl(delete->doi) != IPSEC_DOI) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+		plog(PLOG_PROTOERR, PLOGLOC, 0,
 			"delete payload with invalid doi:%d.\n",
 			ntohl(delete->doi));
 #ifdef ENABLE_HYBRID
@@ -482,17 +486,17 @@
 	tlen = ntohs(delete->h.len) - sizeof(struct isakmp_pl_d);
 
 	if (tlen != num_spi * delete->spi_size) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+		plog(PLOG_PROTOERR, PLOGLOC, 0,
 			"deletion payload with invalid length.\n");
 		return 0;
 	}
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote,
+	plog(PLOG_DEBUG, PLOGLOC, 0,
 		"delete payload for protocol %s\n",
 		s_ipsecdoi_proto(delete->proto_id));
 
-	if(!iph1->rmconf->weak_phase1_check && !encrypted) {
-		plog(LLV_WARNING, LOCATION, iph1->remote,
+	if(!ikev1_weak_phase1_check(iph1->rmconf) && !encrypted) {
+		plog(PLOG_PROTOWARN, PLOGLOC, 0,
 			"Ignoring unencrypted delete payload "
 			"(check the weak_phase1_check option)\n");
 		return 0;
@@ -500,8 +504,8 @@
 
 	switch (delete->proto_id) {
 	case IPSECDOI_PROTO_ISAKMP:
-		if (delete->spi_size != sizeof(isakmp_index)) {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+		if (delete->spi_size != sizeof(isakmp_index_t)) {
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"delete payload with strange spi "
 				"size %d(proto_id:%d)\n",
 				delete->spi_size, delete->proto_id);
@@ -518,7 +522,7 @@
 	case IPSECDOI_PROTO_IPSEC_AH:
 	case IPSECDOI_PROTO_IPSEC_ESP:
 		if (delete->spi_size != sizeof(u_int32_t)) {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"delete payload with strange spi "
 				"size %d(proto_id:%d)\n",
 				delete->spi_size, delete->proto_id);
@@ -526,7 +530,7 @@
 		}
 		EVT_PUSH(iph1->local, iph1->remote, 
 		    EVTT_PEER_DELETE, NULL);
-		purge_ipsec_spi(iph1->remote, delete->proto_id,
+		purge_ipsec_spi(iph1, iph1->remote, delete->proto_id,
 		    (u_int32_t *)(delete + 1), num_spi);
 		break;
 
@@ -539,25 +543,25 @@
 		} else if (delete->spi_size == sizeof(spi.spi32))
 			memcpy(&spi.spi32, delete + 1, sizeof(spi.spi32));
 		else {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"delete payload with strange spi "
 				"size %d(proto_id:%d)\n",
 				delete->spi_size, delete->proto_id);
 			return 0;
 		}
-		purge_ipsec_spi(iph1->remote, delete->proto_id,
+		purge_ipsec_spi(iph1, iph1->remote, delete->proto_id,
 		    &spi.spi32, num_spi);
 		break;
 
 	default:
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+		plog(PLOG_PROTOERR, PLOGLOC, 0,
 			"deletion message received, "
 			"invalid proto_id: %d\n",
 			delete->proto_id);
 		return 0;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL, "purged SAs.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "purged SAs.\n");
 
 	return 0;
 }
@@ -581,10 +585,10 @@
 
 	/* send SPIs of inbound SAs. */
 	/* XXX should send outbound SAs's ? */
-	tlen = sizeof(*d) + sizeof(isakmp_index);
+	tlen = sizeof(*d) + sizeof(isakmp_index_t);
 	payload = vmalloc(tlen);
 	if (payload == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, 
+		plog(PLOG_INTERR, PLOGLOC, NULL, 
 			"failed to get buffer for payload.\n");
 		return errno;
 	}
@@ -594,9 +598,9 @@
 	d->h.len = htons(tlen);
 	d->doi = htonl(IPSEC_DOI);
 	d->proto_id = IPSECDOI_PROTO_ISAKMP;
-	d->spi_size = sizeof(isakmp_index);
+	d->spi_size = sizeof(isakmp_index_t);
 	d->num_spi = htons(1);
-	memcpy(d + 1, &iph1->index, sizeof(isakmp_index));
+	memcpy(d + 1, &iph1->index, sizeof(isakmp_index_t));
 
 	error = isakmp_info_send_common(iph1, payload,
 					ISAKMP_NPTYPE_D, 0);
@@ -645,7 +649,7 @@
 		tlen = sizeof(*d) + pr->spisize;
 		payload = vmalloc(tlen);
 		if (payload == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL, 
+			plog(PLOG_INTERR, PLOGLOC, NULL, 
 				"failed to get buffer for payload.\n");
 			return errno;
 		}
@@ -685,7 +689,7 @@
 	vchar_t *data;
 {
 	struct ph1handle *iph1 = NULL;
-	struct remoteconf *rmconf;
+	struct rcf_remote *rmconf;
 	vchar_t *payload = NULL;
 	int tlen;
 	int error = -1;
@@ -695,7 +699,7 @@
 	/* search appropreate configuration */
 	rmconf = getrmconf(remote);
 	if (rmconf == NULL) {
-		plog(LLV_ERROR, LOCATION, remote,
+		plog(PLOG_INTERR, PLOGLOC, 0,
 			"no configuration found for peer address.\n");
 		goto end;
 	}
@@ -705,7 +709,7 @@
 	if (iph1 == NULL)
 		return -1;
 
-	memcpy(&iph1->index.i_ck, &isakmp->i_ck, sizeof(cookie_t));
+	memcpy(&iph1->index.i_ck, &isakmp->i_ck, sizeof(isakmp_cookie_t));
 	isakmp_newcookie((char *)&iph1->index.r_ck, remote, local);
 	iph1->status = PHASE1ST_START;
 	iph1->rmconf = rmconf;
@@ -731,7 +735,7 @@
 		tlen += data->l;
 	payload = vmalloc(tlen);
 	if (payload == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		goto end;
 	}
@@ -784,7 +788,7 @@
 	 * RFC2407 4.6.3.3, INITIAL-CONTACT is required to set to 16.
 	 */
 	if (type == ISAKMP_NTYPE_INITIAL_CONTACT)
-		spisiz = sizeof(isakmp_index);
+		spisiz = sizeof(isakmp_index_t);
 	else
 		spisiz = 0;
 
@@ -793,7 +797,7 @@
 		tlen += data->l;
 	payload = vmalloc(tlen);
 	if (payload == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		return errno;
 	}
@@ -801,12 +805,12 @@
 	n = (struct isakmp_pl_n *)payload->v;
 	n->h.np = ISAKMP_NPTYPE_NONE;
 	n->h.len = htons(tlen);
-	n->doi = htonl(iph1->rmconf->doitype);
+	n->doi = htonl(ikev1_doitype(iph1->rmconf));
 	n->proto_id = IPSECDOI_PROTO_ISAKMP; /* XXX to be configurable ? */
 	n->spi_size = spisiz;
 	n->type = htons(type);
 	if (spisiz)
-		memcpy(n + 1, &iph1->index, sizeof(isakmp_index));
+		memcpy(n + 1, &iph1->index, sizeof(isakmp_index_t));
 	if (data)
 		memcpy((caddr_t)(n + 1) + spisiz, data->v, data->l);
 
@@ -843,7 +847,7 @@
 		tlen += data->l;
 	payload = vmalloc(tlen);
 	if (payload == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		return errno;
 	}
@@ -890,8 +894,8 @@
 	if (iph2 == NULL)
 		goto end;
 
-	iph2->dst = dupsaddr(iph1->remote);
-	iph2->src = dupsaddr(iph1->local);
+	iph2->dst = rcs_sadup(iph1->remote);
+	iph2->src = rcs_sadup(iph1->local);
 	switch (iph1->remote->sa_family) {
 	case AF_INET:
 #if (!defined(ENABLE_NATT)) || (defined(BROKEN_NATT))
@@ -908,7 +912,7 @@
 		break;
 #endif
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid family: %d\n", iph1->remote->sa_family);
 		delph2(iph2);
 		goto end;
@@ -956,15 +960,15 @@
 	/* create buffer for isakmp payload */
 	iph2->sendbuf = vmalloc(tlen);
 	if (iph2->sendbuf == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		goto err;
 	}
 
 	/* create isakmp header */
 	isakmp = (struct isakmp *)iph2->sendbuf->v;
-	memcpy(&isakmp->i_ck, &iph1->index.i_ck, sizeof(cookie_t));
-	memcpy(&isakmp->r_ck, &iph1->index.r_ck, sizeof(cookie_t));
+	memcpy(&isakmp->i_ck, &iph1->index.i_ck, sizeof(isakmp_cookie_t));
+	memcpy(&isakmp->r_ck, &iph1->index.r_ck, sizeof(isakmp_cookie_t));
 	isakmp->np = hash == NULL ? (np & 0xff) : ISAKMP_NPTYPE_HASH;
 	isakmp->v = iph1->version;
 	isakmp->etype = ISAKMP_ETYPE_INFO;
@@ -1009,7 +1013,7 @@
 		goto err;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"sendto Information %s.\n", s_isakmp_nptype(np));
 
 	/*
@@ -1066,7 +1070,7 @@
 	} else
 		buf = vmalloc(tlen);
 	if (!buf) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get a payload buffer.\n");
 		return NULL;
 	}
@@ -1091,7 +1095,7 @@
 static void
 purge_isakmp_spi(proto, spi, n)
 	int proto;
-	isakmp_index *spi;	/*network byteorder*/
+	isakmp_index_t *spi;	/*network byteorder*/
 	size_t n;
 {
 	struct ph1handle *iph1;
@@ -1102,7 +1106,7 @@
 		if (!iph1)
 			continue;
 
-		plog(LLV_INFO, LOCATION, NULL,
+		plog(PLOG_INFO, PLOGLOC, NULL,
 			"purged ISAKMP-SA proto_id=%s spi=%s.\n",
 			s_ipsecdoi_proto(proto),
 			isakmp_pindex(&spi[i], 0));
@@ -1117,7 +1121,8 @@
 
 
 void
-purge_ipsec_spi(dst0, proto, spi, n)
+purge_ipsec_spi(ph1, dst0, proto, spi, n)
+     struct ph1handle *ph1;
 	struct sockaddr *dst0;
 	int proto;
 	u_int32_t *spi;	/*network byteorder*/
@@ -1131,9 +1136,11 @@
 	size_t i;
 	caddr_t mhp[SADB_EXT_MAX + 1];
 
+	plog(PLOG_INTERR, PLOGLOC, 0, "unimplemented\n");
+#ifdef notyet
 	buf = pfkey_dump_sadb(ipsecdoi2pfkey_proto(proto));
 	if (buf == NULL) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"pfkey_dump_sadb returned nothing.\n");
 		return;
 	}
@@ -1151,7 +1158,7 @@
 		}
 
 		if (pfkey_align(msg, mhp) || pfkey_check(mhp)) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"pfkey_check (%s)\n", ipsec_strerror());
 			msg = next;
 			continue;
@@ -1183,16 +1190,27 @@
 		}
 
 		for (i = 0; i < n; i++) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"check spi(packet)=%u spi(db)=%u.\n",
 				ntohl(spi[i]), ntohl(sa->sadb_sa_spi));
 			if (spi[i] != sa->sadb_sa_spi)
 				continue;
 
+			{
+				struct rcpfk_msg param;
+				param.sa_src = src;
+				param.sa_dst = dst;
+
+				param.satype = sadb_satype2rc(msg->sadb_msg_satype);
+				param.spi = sa->sadb_sa_spi;
+				ph1->sadb_request.method->delete_sa(&param);
+			}
+#if 0
 			pfkey_send_delete(lcconf->sock_pfkey,
 				msg->sadb_msg_satype,
 				IPSEC_MODE_ANY,
 				src, dst, sa->sadb_sa_spi);
+#endif
 
 			/*
 			 * delete a relative phase 2 handler.
@@ -1207,7 +1225,7 @@
 				delph2(iph2);
 			}
 
-			plog(LLV_INFO, LOCATION, NULL,
+			plog(PLOG_INFO, PLOGLOC, NULL,
 				"purged IPsec-SA proto_id=%s spi=%u.\n",
 				s_ipsecdoi_proto(proto),
 				ntohl(spi[i]));
@@ -1218,6 +1236,8 @@
 
 	if (buf)
 		vfree(buf);
+
+#endif
 }
 
 /*
@@ -1231,6 +1251,7 @@
 info_recv_initialcontact(iph1)
 	struct ph1handle *iph1;
 {
+#ifdef notyet
 	vchar_t *buf = NULL;
 	struct sadb_msg *msg, *next, *end;
 	struct sadb_sa *sa;
@@ -1238,10 +1259,13 @@
 	caddr_t mhp[SADB_EXT_MAX + 1];
 	int proto_id, i;
 	struct ph2handle *iph2;
-#if 0
 	char *loc, *rem;
 #endif
 
+	plog(PLOG_INTERR, PLOGLOC, 0, "not implemented\n");
+
+#ifdef notyet
+
 	if (f_local)
 		return;
 
@@ -1257,13 +1281,13 @@
 	for (i = 0; i < pfkey_nsatypes; i++) {
 		proto_id = pfkey2ipsecdoi_proto(pfkey_satypes[i].ps_satype);
 
-		plog(LLV_INFO, LOCATION, NULL,
+		plog(PLOG_INFO, PLOGLOC, NULL,
 		    "purging %s SAs for %s -> %s\n",
 		    pfkey_satypes[i].ps_name, loc, rem);
 		if (pfkey_send_delete_all(lcconf->sock_pfkey,
 		    pfkey_satypes[i].ps_satype, IPSEC_MODE_ANY,
 		    iph1->local, iph1->remote) == -1) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 			    "delete_all %s -> %s failed for %s (%s)\n",
 			    loc, rem,
 			    pfkey_satypes[i].ps_name, ipsec_strerror());
@@ -1272,13 +1296,13 @@
 
 		deleteallph2(iph1->local, iph1->remote, proto_id);
 
-		plog(LLV_INFO, LOCATION, NULL,
+		plog(PLOG_INFO, PLOGLOC, NULL,
 		    "purging %s SAs for %s -> %s\n",
 		    pfkey_satypes[i].ps_name, rem, loc);
 		if (pfkey_send_delete_all(lcconf->sock_pfkey,
 		    pfkey_satypes[i].ps_satype, IPSEC_MODE_ANY,
 		    iph1->remote, iph1->local) == -1) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 			    "delete_all %s -> %s failed for %s (%s)\n",
 			    rem, loc,
 			    pfkey_satypes[i].ps_name, ipsec_strerror());
@@ -1299,7 +1323,7 @@
 
 	buf = pfkey_dump_sadb(SADB_SATYPE_UNSPEC);
 	if (buf == NULL) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"pfkey_dump_sadb returned nothing.\n");
 		return;
 	}
@@ -1317,7 +1341,7 @@
 		}
 
 		if (pfkey_align(msg, mhp) || pfkey_check(mhp)) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"pfkey_check (%s)\n", ipsec_strerror());
 			msg = next;
 			continue;
@@ -1370,11 +1394,11 @@
 		 * NATed, but which NATs some other peers ?
 		 * Here, the INITIAl-CONTACT would also flush all those NATed peers !!
 		 */
-		if (cmpsaddrwop(iph1->local, src) == 0 &&
-		    cmpsaddrwop(iph1->remote, dst) == 0)
+		if (rcs_cmpsa_wop(iph1->local, src) == 0 &&
+		    rcs_cmpsa_wop(iph1->remote, dst) == 0)
 			;
-		else if (cmpsaddrwop(iph1->remote, src) == 0 &&
-		    cmpsaddrwop(iph1->local, dst) == 0)
+		else if (rcs_cmpsa_wop(iph1->remote, src) == 0 &&
+		    rcs_cmpsa_wop(iph1->local, dst) == 0)
 			;
 		else {
 			msg = next;
@@ -1396,7 +1420,7 @@
 			continue;
 		}
 
-		plog(LLV_INFO, LOCATION, NULL,
+		plog(PLOG_INFO, PLOGLOC, NULL,
 			"purging spi=%u.\n", ntohl(sa->sadb_sa_spi));
 		pfkey_send_delete(lcconf->sock_pfkey,
 			msg->sadb_msg_satype,
@@ -1420,6 +1444,8 @@
 	}
 
 	vfree(buf);
+
+#endif
 }
 
 void
@@ -1429,7 +1455,7 @@
 {
 	struct isakmp_pl_n *notify = (struct isakmp_pl_n *)gen;
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote,
+	plog(PLOG_DEBUG, PLOGLOC, 0,
 		"Notify Message received\n");
 
 	switch (ntohs(notify->type)) {
@@ -1440,18 +1466,18 @@
 #ifdef ENABLE_HYBRID
 	case ISAKMP_NTYPE_UNITY_HEARTBEAT:
 #endif
-		plog(LLV_WARNING, LOCATION, iph1->remote,
+		plog(PLOG_PROTOWARN, PLOGLOC, 0,
 			"ignore %s notification.\n",
 			s_isakmp_notify_msg(ntohs(notify->type)));
 		break;
 	case ISAKMP_NTYPE_INITIAL_CONTACT:
-		plog(LLV_WARNING, LOCATION, iph1->remote,
+		plog(PLOG_PROTOWARN, PLOGLOC, 0,
 			"ignore INITIAL-CONTACT notification, "
 			"because it is only accepted after phase1.\n");
 		break;
 	default:
 		isakmp_info_send_n1(iph1, ISAKMP_NTYPE_INVALID_PAYLOAD_TYPE, NULL);
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+		plog(PLOG_PROTOERR, PLOGLOC, 0,
 			"received unknown notification type %s.\n",
 			s_isakmp_notify_msg(ntohs(notify->type)));
 	}
@@ -1472,7 +1498,7 @@
 	int tlen;
 	int error = 0;
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote,
+	plog(PLOG_DEBUG, PLOGLOC, 0,
 		 "DPD R-U-There received\n");
 
 	/* XXX should compare cookies with iph1->index?
@@ -1480,7 +1506,7 @@
 	tlen = sizeof(*ru_ack);
 	payload = vmalloc(tlen);
 	if (payload == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		return errno;
 	}
@@ -1491,9 +1517,9 @@
 	ru_ack->doi = htonl(IPSEC_DOI);
 	ru_ack->type = htons(ISAKMP_NTYPE_R_U_THERE_ACK);
 	ru_ack->proto_id = IPSECDOI_PROTO_ISAKMP; /* XXX ? */
-	ru_ack->spi_size = sizeof(isakmp_index);
-	memcpy(ru_ack->i_ck, ru->i_ck, sizeof(cookie_t));
-	memcpy(ru_ack->r_ck, ru->r_ck, sizeof(cookie_t));	
+	ru_ack->spi_size = sizeof(isakmp_index_t);
+	memcpy(ru_ack->i_ck, ru->i_ck, sizeof(isakmp_cookie_t));
+	memcpy(ru_ack->r_ck, ru->r_ck, sizeof(isakmp_cookie_t));	
 	ru_ack->data = ru->data;
 
 	/* XXX Should we do FLAG_A ?  */
@@ -1501,7 +1527,7 @@
 					ISAKMP_FLAG_E);
 	vfree(payload);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "received a valid R-U-THERE, ACK sent\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "received a valid R-U-THERE, ACK sent\n");
 
 	/* Should we mark tunnel as active ? */
 	return error;
@@ -1514,22 +1540,22 @@
 	u_int32_t msgid;
 {
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote,
+	plog(PLOG_DEBUG, PLOGLOC, 0,
 		 "DPD R-U-There-Ack received\n");
 
 	/* XXX Maintain window of acceptable sequence numbers ?
 	 * => ru->data <= iph2->dpd_seq &&
 	 *    ru->data >= iph2->dpd_seq - iph2->dpd_fails ? */
 	if (ntohl(ru->data) != iph1->dpd_seq-1) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+		plog(PLOG_PROTOERR, PLOGLOC, 0,
 			 "Wrong DPD sequence number (%d, %d expected).\n", 
 			 ntohl(ru->data), iph1->dpd_seq-1);
 		return 0;
 	}
 
-	if (memcmp(ru->i_ck, iph1->index.i_ck, sizeof(cookie_t)) ||
-	    memcmp(ru->r_ck, iph1->index.r_ck, sizeof(cookie_t))) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+	if (memcmp(ru->i_ck, iph1->index.i_ck, sizeof(isakmp_cookie_t)) ||
+	    memcmp(ru->r_ck, iph1->index.r_ck, sizeof(isakmp_cookie_t))) {
+		plog(PLOG_PROTOERR, PLOGLOC, 0,
 			 "Cookie mismatch in DPD ACK!.\n");
 		return 0;
 	}
@@ -1544,7 +1570,7 @@
 
 	isakmp_sched_r_u(iph1, 0);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "received an R-U-THERE-ACK\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "received an R-U-THERE-ACK\n");
 
 	return 0;
 }
@@ -1567,12 +1593,12 @@
 	int tlen;
 	int error = 0;
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote, "DPD monitoring....\n");
+	plog(PLOG_DEBUG, PLOGLOC, 0, "DPD monitoring....\n");
 
 	if (iph1->dpd_fails >= iph1->rmconf->dpd_maxfails) {
 		EVT_PUSH(iph1->local, iph1->remote, EVTT_DPD_TIMEOUT, NULL);
 		purge_remote(iph1);
-		plog(LLV_DEBUG, LOCATION, iph1->remote,
+		plog(PLOG_DEBUG, PLOGLOC, 0,
 			 "DPD: remote seems to be dead\n");
 
 		/* Do not reschedule here: phase1 is deleted,
@@ -1592,7 +1618,7 @@
 		   XXX: reschedule when a new ph2 ?
 		 */
 		isakmp_sched_r_u(iph1, 0);
-		plog(LLV_DEBUG, LOCATION, iph1->remote,
+		plog(PLOG_DEBUG, PLOGLOC, 0,
 			 "no phase2 handler, rescheduling send_r_u (%d).\n", iph1->rmconf->dpd_interval);
 		return 0;
 	}
@@ -1601,7 +1627,7 @@
 	tlen = sizeof(*ru);
 	payload = vmalloc(tlen);
 	if (payload == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, 
+		plog(PLOG_INTERR, PLOGLOC, NULL, 
 			 "failed to get buffer for payload.\n");
 		return;
 	}
@@ -1611,10 +1637,10 @@
 	ru->doi = htonl(IPSEC_DOI);
 	ru->type = htons(ISAKMP_NTYPE_R_U_THERE);
 	ru->proto_id = IPSECDOI_PROTO_ISAKMP; /* XXX ?*/
-	ru->spi_size = sizeof(isakmp_index);
+	ru->spi_size = sizeof(isakmp_index_t);
 
-	memcpy(ru->i_ck, iph1->index.i_ck, sizeof(cookie_t));
-	memcpy(ru->r_ck, iph1->index.r_ck, sizeof(cookie_t));
+	memcpy(ru->i_ck, iph1->index.i_ck, sizeof(isakmp_cookie_t));
+	memcpy(ru->r_ck, iph1->index.r_ck, sizeof(isakmp_cookie_t));
 
 	if (iph1->dpd_seq == 0){
 		/* generate a random seq which is not too big */
@@ -1627,7 +1653,7 @@
 	error = isakmp_info_send_common(iph1, payload, ISAKMP_NPTYPE_N, 0);
 	vfree(payload);
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote,
+	plog(PLOG_DEBUG, PLOGLOC, 0,
 		 "DPD R-U-There sent (%d)\n", error);
 
 	/* will be decreased if ACK received... */
@@ -1640,7 +1666,7 @@
 	 * will be deleted/rescheduled if ACK received before */
 	isakmp_sched_r_u(iph1, 1);
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote,
+	plog(PLOG_DEBUG, PLOGLOC, 0,
 		 "rescheduling send_r_u (%d).\n", iph1->rmconf->dpd_retry);
 }
 
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_inf.h ./isakmp_inf.h
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_inf.h	Sat May  7 23:15:59 2005
+++ ./isakmp_inf.h	Thu Jan 12 19:16:40 2006
@@ -52,7 +52,7 @@
 extern int isakmp_sched_r_u __P((struct ph1handle *, int));
 #endif
 
-extern void purge_ipsec_spi __P((struct sockaddr *, int,	u_int32_t *, size_t));
+extern void purge_ipsec_spi __P((struct ph1handle *, struct sockaddr *, int,	u_int32_t *, size_t));
 extern int tunnel_mode_prop __P((struct saprop *));
 
 #endif /* _ISAKMP_INF_H */
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_newg.c ./isakmp_newg.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_newg.c	Tue Jan 13 06:38:10 2004
+++ ./isakmp_newg.c	Thu Feb  2 16:33:46 2006
@@ -39,24 +39,26 @@
 #include <string.h>
 #include <errno.h>
 
+#include "racoon.h"
+
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 #include "sockmisc.h"
 #include "debug.h"
 
 #include "schedule.h"
-#include "cfparse_proto.h"
-#include "isakmp_var.h"
+/* #include "cfparse_proto.h" */
 #include "isakmp.h"
+#include "isakmp_var.h"
 #include "isakmp_newg.h"
 #include "oakley.h"
 #include "ipsec_doi.h"
 #include "crypto_openssl.h"
 #include "handler.h"
-#include "pfkey.h"
-#include "admin.h"
+/* #include "pfkey.h"  */
+/* #include "admin.h" */
 #include "str2val.h"
 #include "vendorid.h"
 
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_quick.c ./isakmp_quick.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_quick.c	Wed Jul 20 17:01:37 2005
+++ ./isakmp_quick.c	Thu Feb  2 17:00:19 2006
@@ -1,4 +1,4 @@
-/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/*	$KAME: isakmp_quick.c,v 1.95 2003/10/21 07:18:03 itojun Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -29,12 +29,15 @@
  * SUCH DAMAGE.
  */
 
-#include "config.h"
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
 
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/socket.h>
 
+#include <netkey/key_var.h>
 #include <netinet/in.h>
 
 #include <stdlib.h>
@@ -51,47 +54,80 @@
 #  include <time.h>
 # endif
 #endif
-#ifdef ENABLE_HYBRID
-#include <resolv.h>
-#endif
 
-#ifndef HAVE_NETINET6_IPSEC
+#ifdef IPV6_INRIA_VERSION
 #include <netinet/ipsec.h>
 #else
 #include <netinet6/ipsec.h>
 #endif
 
+#include "racoon.h"
+
 #include "var.h"
 #include "vmbuf.h"
 #include "schedule.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "plog.h"
 #include "debug.h"
 
-#include "localconf.h"
+/* #include "localconf.h" */
 #include "remoteconf.h"
-#include "handler.h"
-#include "proposal.h"
-#include "isakmp_var.h"
 #include "isakmp.h"
+#include "isakmp_var.h"
 #include "isakmp_inf.h"
 #include "isakmp_quick.h"
 #include "oakley.h"
+#include "handler.h"
 #include "ipsec_doi.h"
-#include "crypto_openssl.h"
-#include "pfkey.h"
-#include "policy.h"
+#include "crypto_impl.h"
+/* #include "pfkey.h" */
+/* #include "policy.h" */
 #include "algorithm.h"
 #include "sockmisc.h"
 #include "proposal.h"
 #include "sainfo.h"
-#include "admin.h"
+/* #include "admin.h" */
 #include "strnames.h"
 
+#include "ike_conf.h"
+
 /* quick mode */
 static vchar_t *quick_ir1mx __P((struct ph2handle *, vchar_t *, vchar_t *));
 static int get_sainfo_r __P((struct ph2handle *));
 static int get_proposal_r __P((struct ph2handle *));
+#ifdef INET6
+static u_int32_t setscopeid __P((struct sockaddr *, struct sockaddr *));
+#endif
+
+/* called from scheduler */
+void
+pfkey_timeover_stub(p)
+	void *p;
+{
+	void pfkey_timeover();
+
+	pfkey_timeover((struct ph2handle *)p);
+}
+
+void
+pfkey_timeover(iph2)
+	struct ph2handle *iph2;
+{
+	plog(PLOG_PROTOERR, PLOGLOC, 0,
+		"%s give up to get IPsec-SA due to time up to wait.\n",
+		rcs_sa2str_wop(iph2->dst));
+	SCHED_KILL(iph2->sce);
+
+	/* If initiator side, send error to kernel by SADB_ACQUIRE. */
+	if (iph2->side == INITIATOR)
+		pk_sendeacquire(iph2);
+
+	unbindph12(iph2);
+	remph2(iph2);
+	delph2(iph2);
+
+	return;
+}
 
 /* %%%
  * Quick Mode
@@ -108,7 +144,7 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_STATUS2) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
@@ -120,19 +156,21 @@
 
 	iph2->status = PHASE2ST_GETSPISENT;
 
+#if 0
 	/* don't anything if local test mode. */
 	if (f_local) {
 		error = 0;
 		goto end;
 	}
+#endif
 
 	/* send getspi message */
 	if (pk_sendgetspi(iph2) < 0)
 		goto end;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "pfkey getspi sent.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pfkey getspi sent.\n");
 
-	iph2->sce = sched_new(lcconf->wait_ph2complete,
+	iph2->sce = sched_new(ikev1_ipsec_sa_nego_time_limit(iph2->ph1->rmconf),
 		pfkey_timeover_stub, iph2);
 
 	error = 0;
@@ -162,12 +200,12 @@
 
 	/* validity check */
 	if (msg != NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"msg has to be NULL in this function.\n");
 		goto end;
 	}
 	if (iph2->status != PHASE2ST_GETSPIDONE) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
@@ -177,7 +215,7 @@
 		goto end;
 
 	/* generate NONCE value */
-	iph2->nonce = eay_set_random(iph2->ph1->rmconf->nonce_size);
+	iph2->nonce = eay_set_random(ikev1_nonce_size(iph2->ph1->rmconf));
 	if (iph2->nonce == NULL)
 		goto end;
 
@@ -191,7 +229,7 @@
 	if (pfsgroup) {
 		/* DH group settting if PFS is required. */
 		if (oakley_setdhgroup(pfsgroup, &iph2->pfsgrp) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to set DH value.\n");
 			goto end;
 		}
@@ -203,14 +241,14 @@
 
 	/* generate ID value */
 	if (ipsecdoi_setid2(iph2) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get ID.\n");
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "IDci:\n");
-	plogdump(LLV_DEBUG, iph2->id->v, iph2->id->l);
-	plog(LLV_DEBUG, LOCATION, NULL, "IDcr:\n");
-	plogdump(LLV_DEBUG, iph2->id_p->v, iph2->id_p->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "IDci:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph2->id->v, iph2->id->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "IDcr:");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph2->id_p->v, iph2->id_p->l);
 
 	/*
 	 * we do not attach IDci nor IDcr, under the following condition:
@@ -223,7 +261,7 @@
 	id_p = (struct ipsecdoi_id_b *)iph2->id_p->v;
 	if (id->proto_id == 0
 	 && id_p->proto_id == 0
-	 && iph2->ph1->rmconf->support_proxy == 0
+	 && ikev1_support_proxy(iph2->ph1->rmconf) != RCT_BOOL_ON
 	 && ipsecdoi_transportmode(iph2->proposal)) {
 		idci = idcr = 0;
 	} else
@@ -241,7 +279,7 @@
 
 	body = vmalloc(tlen);
 	if (body == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		goto end;
 	}
@@ -285,7 +323,7 @@
 		goto end;
 
 	/* send the packet, add to the schedule to resend */
-	iph2->retry_counter = iph2->ph1->rmconf->retry_counter;
+	iph2->retry_counter = ikev1_max_retry_to_send(iph2->ph1->rmconf);
 	if (isakmp_ph2resend(iph2) == -1)
 		goto end;
 
@@ -325,15 +363,16 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_MSG1SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
 
 	/* decrypt packet */
 	if (!ISSET(((struct isakmp *)msg0->v)->flags, ISAKMP_FLAG_E)) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"Packet wasn't encrypted.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "Packet wasn't encrypted.\n");
 		goto end;
 	}
 	msg = oakley_do_decrypt(iph2->ph1, msg0, iph2->ivm->iv, iph2->ivm->ive);
@@ -354,10 +393,11 @@
 
 	/* HASH payload is fixed postion */
 	if (pa->type != ISAKMP_NPTYPE_HASH) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"received invalid next payload type %d, "
-			"expecting %d.\n",
-			pa->type, ISAKMP_NPTYPE_HASH);
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "received invalid next payload type %d, "
+			   "expecting %d.\n",
+			   pa->type, ISAKMP_NPTYPE_HASH);
 		goto end;
 	}
 	hash = (struct isakmp_pl_hash *)pa->ptr;
@@ -370,10 +410,11 @@
 	 */
 	/* HASH payload is fixed postion */
 	if (pa->type != ISAKMP_NPTYPE_SA) {
-		plog(LLV_WARNING, LOCATION, iph2->ph1->remote,
-			"received invalid next payload type %d, "
-			"expecting %d.\n",
-			pa->type, ISAKMP_NPTYPE_HASH);
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOWARN, PLOGLOC,
+			   "received invalid next payload type %d, "
+			   "expecting %d.\n",
+			   pa->type, ISAKMP_NPTYPE_HASH);
 	}
 
 	/* allocate buffer for computing HASH(2) */
@@ -381,7 +422,7 @@
 		+ ntohl(isakmp->len) - sizeof(*isakmp);
 	hbuf = vmalloc(tlen);
 	if (hbuf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer.\n");
 		goto end;
 	}
@@ -403,7 +444,7 @@
 		switch (pa->type) {
 		case ISAKMP_NPTYPE_SA:
 			if (iph2->sa_ret != NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"Ignored, multiple SA "
 					"isn't supported.\n");
 				break;
@@ -438,7 +479,7 @@
 
 			if (memcmp(vp->v, (caddr_t)pa->ptr + sizeof(struct isakmp_gen), vp->l)) {
 
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"mismatched ID was returned.\n");
 				error = ISAKMP_NTYPE_ATTRIBUTES_NOT_SUPPORTED;
 				goto end;
@@ -450,19 +491,13 @@
 			isakmp_check_notify(pa->ptr, iph2->ph1);
 			break;
 
-#ifdef ENABLE_NATT
-		case ISAKMP_NPTYPE_NATOA_DRAFT:
-		case ISAKMP_NPTYPE_NATOA_RFC:
-			/* Ignore original source/destination messages */
-			break;
-#endif
-
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph2->ph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 
@@ -474,15 +509,16 @@
 
 	/* payload existency check */
 	if (hash == NULL || iph2->sa_ret == NULL || iph2->nonce_p == NULL) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "few isakmp message received.\n");
 		goto end;
 	}
 
 	/* Fixed buffer for calculating HASH */
 	memcpy(hbuf->v, iph2->nonce->v, iph2->nonce->l);
-	plog(LLV_DEBUG, LOCATION, NULL,
-		"HASH allocated:hbuf->l=%zu actual:tlen=%zu\n",
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
+		"HASH allocated:hbuf->l=%d actual:tlen=%d\n",
 		hbuf->l, tlen + iph2->nonce->l);
 	/* adjust buffer length for HASH */
 	hbuf->l = iph2->nonce->l + tlen;
@@ -495,8 +531,8 @@
 
 	r_hash = (char *)hash + sizeof(*hash);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH(2) received:");
-	plogdump(LLV_DEBUG, r_hash, ntohs(hash->h.len) - sizeof(*hash));
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH(2) received:");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, r_hash, ntohs(hash->h.len) - sizeof(*hash));
 
 	my_hash = oakley_compute_hash1(iph2->ph1, iph2->msgid, hbuf);
 	if (my_hash == NULL)
@@ -506,8 +542,9 @@
 	vfree(my_hash);
 
 	if (result) {
-		plog(LLV_DEBUG, LOCATION, iph2->ph1->remote,
-			"HASH(2) mismatch.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "HASH(2) mismatch.\n");
 		error = ISAKMP_NTYPE_INVALID_HASH_INFORMATION;
 		goto end;
 	}
@@ -561,7 +598,7 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_STATUS6) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
@@ -570,11 +607,11 @@
     {
 	vchar_t *tmp = NULL;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH(3) generate\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH(3) generate\n");
 
 	tmp = vmalloc(iph2->nonce->l + iph2->nonce_p->l);
 	if (tmp == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer.\n");
 		goto end;
 	}
@@ -593,7 +630,7 @@
 		+ sizeof(struct isakmp_gen) + hash->l;
 	buf = vmalloc(tlen);
 	if (buf == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		goto end;
 	}
@@ -618,7 +655,7 @@
 	/* if there is commit bit, need resending */
 	if (ISSET(iph2->flags, ISAKMP_FLAG_C)) {
 		/* send the packet, add to the schedule to resend */
-		iph2->retry_counter = iph2->ph1->rmconf->retry_counter;
+		iph2->retry_counter = ikev1_max_retry_to_send(iph2->ph1->rmconf);
 		if (isakmp_ph2resend(iph2) == -1)
 			goto end;
 	} else {
@@ -630,7 +667,7 @@
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph2->ph1->remote, iph2->ph1->local,
 			iph2->sendbuf, msg0) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR , PLOGLOC, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -641,12 +678,14 @@
 
 	iph2->status = PHASE2ST_ADDSA;
 
+#if 0
 	/* don't anything if local test mode. */
 	if (f_local) {
 		error = 0;
 		goto end;
 	}
-
+#endif
+	
 	/* if there is commit bit don't set up SA now. */
 	if (ISSET(iph2->flags, ISAKMP_FLAG_C)) {
 		iph2->status = PHASE2ST_COMMIT;
@@ -655,19 +694,19 @@
 	}
 
 	/* Do UPDATE for initiator */
-	plog(LLV_DEBUG, LOCATION, NULL, "call pk_sendupdate\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "call pk_sendupdate\n");
 	if (pk_sendupdate(iph2) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL, "pfkey update failed.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "pfkey update failed.\n");
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "pfkey update sent.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pfkey update sent.\n");
 
 	/* Do ADD for responder */
 	if (pk_sendadd(iph2) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL, "pfkey add failed.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "pfkey add failed.\n");
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "pfkey add sent.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pfkey add sent.\n");
 
 	error = 0;
 
@@ -700,15 +739,16 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_COMMIT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
 
 	/* decrypt packet */
 	if (!ISSET(((struct isakmp *)msg0->v)->flags, ISAKMP_FLAG_E)) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"Packet wasn't encrypted.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "Packet wasn't encrypted.\n");
 		goto end;
 	}
 	msg = oakley_do_decrypt(iph2->ph1, msg0, iph2->ivm->iv, iph2->ivm->ive);
@@ -732,7 +772,7 @@
 			isakmp_check_notify(pa->ptr, iph2->ph1);
 			notify = vmalloc(pa->len);
 			if (notify == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to get notify buffer.\n");
 				goto end;
 			}
@@ -740,18 +780,20 @@
 			break;
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph2->ph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
 	/* payload existency check */
 	if (hash == NULL) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "few isakmp message received.\n");
 		goto end;
 	}
 
@@ -764,8 +806,8 @@
 
 	r_hash = (char *)hash + sizeof(*hash);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH(4) validate:");
-	plogdump(LLV_DEBUG, r_hash, ntohs(hash->h.len) - sizeof(*hash));
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH(4) validate:");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, r_hash, ntohs(hash->h.len) - sizeof(*hash));
 
 	my_hash = oakley_compute_hash1(iph2->ph1, iph2->msgid, notify);
 	vfree(tmp);
@@ -776,8 +818,9 @@
 	vfree(my_hash);
 
 	if (result) {
-		plog(LLV_DEBUG, LOCATION, iph2->ph1->remote,
-			"HASH(4) mismatch.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "HASH(4) mismatch.\n");
 		error = ISAKMP_NTYPE_INVALID_HASH_INFORMATION;
 		goto end;
 	}
@@ -786,26 +829,28 @@
 	iph2->status = PHASE2ST_ADDSA;
 	iph2->flags ^= ISAKMP_FLAG_C;	/* reset bit */
 
+#if 0
 	/* don't anything if local test mode. */
 	if (f_local) {
 		error = 0;
 		goto end;
 	}
+#endif
 
 	/* Do UPDATE for initiator */
-	plog(LLV_DEBUG, LOCATION, NULL, "call pk_sendupdate\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "call pk_sendupdate\n");
 	if (pk_sendupdate(iph2) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL, "pfkey update failed.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "pfkey update failed.\n");
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "pfkey update sent.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pfkey update sent.\n");
 
 	/* Do ADD for responder */
 	if (pk_sendadd(iph2) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL, "pfkey add failed.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "pfkey add failed.\n");
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "pfkey add sent.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pfkey add sent.\n");
 
 	error = 0;
 
@@ -842,15 +887,16 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_START) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
 
 	/* decrypting */
 	if (!ISSET(((struct isakmp *)msg0->v)->flags, ISAKMP_FLAG_E)) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"Packet wasn't encrypted.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "Packet wasn't encrypted.\n");
 		error = ISAKMP_NTYPE_PAYLOAD_MALFORMED;
 		goto end;
 	}
@@ -873,10 +919,11 @@
 
 	/* HASH payload is fixed postion */
 	if (pa->type != ISAKMP_NPTYPE_HASH) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"received invalid next payload type %d, "
-			"expecting %d.\n",
-			pa->type, ISAKMP_NPTYPE_HASH);
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "received invalid next payload type %d, "
+			   "expecting %d.\n",
+			   pa->type, ISAKMP_NPTYPE_HASH);
 		error = ISAKMP_NTYPE_BAD_PROPOSAL_SYNTAX;
 		goto end;
 	}
@@ -890,10 +937,11 @@
 	 */
 	/* HASH payload is fixed postion */
 	if (pa->type != ISAKMP_NPTYPE_SA) {
-		plog(LLV_WARNING, LOCATION, iph2->ph1->remote,
-			"received invalid next payload type %d, "
-			"expecting %d.\n",
-			pa->type, ISAKMP_NPTYPE_SA);
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "received invalid next payload type %d, "
+			   "expecting %d.\n",
+			   pa->type, ISAKMP_NPTYPE_HASH);
 		error = ISAKMP_NTYPE_BAD_PROPOSAL_SYNTAX;
 	}
 
@@ -901,7 +949,7 @@
 	tlen = ntohl(isakmp->len) - sizeof(*isakmp);
 	hbuf = vmalloc(tlen);
 	if (hbuf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer.\n");
 		goto end;
 	}
@@ -937,7 +985,7 @@
 		switch (pa->type) {
 		case ISAKMP_NPTYPE_SA:
 			if (iph2->sa != NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"Multi SAs isn't supported.\n");
 				goto end;
 			}
@@ -966,7 +1014,7 @@
 			} else if (iph2->id == NULL) {
 				/* for IDcr */
 				if (f_id_order == 0) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"IDr2 payload is not "
 						"immediatelly followed "
 						"by IDi2. We allowed.\n");
@@ -976,9 +1024,9 @@
 				if (isakmp_p2ph(&iph2->id, pa->ptr) < 0)
 					goto end;
 			} else {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"received too many ID payloads.\n");
-				plogdump(LLV_ERROR, iph2->id->v, iph2->id->l);
+				plogdump(PLOG_PROTOERR, PLOGLOC, 0, iph2->id->v, iph2->id->l);
 				error = ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 				goto end;
 			}
@@ -988,18 +1036,12 @@
 			isakmp_check_notify(pa->ptr, iph2->ph1);
 			break;
 
-#ifdef ENABLE_NATT
-		case ISAKMP_NPTYPE_NATOA_DRAFT:
-		case ISAKMP_NPTYPE_NATOA_RFC:
-			/* Ignore original source/destination messages */
-			break;
-#endif
-
 		default:
-			plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph2->ph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			error = ISAKMP_NTYPE_PAYLOAD_MALFORMED;
 			goto end;
 		}
@@ -1012,19 +1054,20 @@
 
 	/* payload existency check */
 	if (hash == NULL || iph2->sa == NULL || iph2->nonce_p == NULL) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "few isakmp message received.\n");
 		error = ISAKMP_NTYPE_PAYLOAD_MALFORMED;
 		goto end;
 	}
 
 	if (iph2->id_p) {
-		plog(LLV_DEBUG, LOCATION, NULL, "received IDci2:");
-		plogdump(LLV_DEBUG, iph2->id_p->v, iph2->id_p->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "received IDci2:");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, iph2->id_p->v, iph2->id_p->l);
 	}
 	if (iph2->id) {
-		plog(LLV_DEBUG, LOCATION, NULL, "received IDcr2:");
-		plogdump(LLV_DEBUG, iph2->id->v, iph2->id->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "received IDcr2:");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, iph2->id->v, iph2->id->l);
 	}
 
 	/* adjust buffer length for HASH */
@@ -1038,8 +1081,8 @@
 
 	r_hash = (caddr_t)hash + sizeof(*hash);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH(1) validate:");
-	plogdump(LLV_DEBUG, r_hash, ntohs(hash->h.len) - sizeof(*hash));
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH(1) validate:");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, r_hash, ntohs(hash->h.len) - sizeof(*hash));
 
 	my_hash = oakley_compute_hash1(iph2->ph1, iph2->msgid, hbuf);
 	if (my_hash == NULL)
@@ -1049,8 +1092,9 @@
 	vfree(my_hash);
 
 	if (result) {
-		plog(LLV_DEBUG, LOCATION, iph2->ph1->remote,
-			"HASH(1) mismatch.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_DEBUG, PLOGLOC,
+			   "HASH(1) mismatch.\n");
 		error = ISAKMP_NTYPE_INVALID_HASH_INFORMATION;
 		goto end;
 	}
@@ -1059,7 +1103,7 @@
 	/* get sainfo */
 	error = get_sainfo_r(iph2);
 	if (error) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to get sainfo.\n");
 		goto end;
 	}
@@ -1070,7 +1114,7 @@
 	case -2:
 		/* generate a policy template from peer's proposal */
 		if (set_proposal_from_proposal(iph2)) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to generate a proposal template "
 				"from client's proposal.\n");
 			return ISAKMP_INTERNAL_ERROR;
@@ -1084,20 +1128,20 @@
 		}
 		break;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get proposal for responder.\n");
 		goto end;
 	}
 
 	/* check KE and attribute of PFS */
 	if (iph2->dhpub_p != NULL && iph2->approval->pfs_group == 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"no PFS is specified, but peer sends KE.\n");
 		error = ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN;
 		goto end;
 	}
 	if (iph2->dhpub_p == NULL && iph2->approval->pfs_group != 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"PFS is specified, but peer doesn't sends KE.\n");
 		error = ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN;
 		goto end;
@@ -1145,7 +1189,7 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_STATUS2) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
@@ -1156,9 +1200,9 @@
 	if (pk_sendgetspi(iph2) < 0)
 		goto end;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "pfkey getspi sent.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pfkey getspi sent.\n");
 
-	iph2->sce = sched_new(lcconf->wait_ph2complete,
+	iph2->sce = sched_new(ikev1_ipsec_sa_nego_time_limit(iph2->ph1->rmconf),
 		pfkey_timeover_stub, iph2);
 
 	error = 0;
@@ -1187,24 +1231,24 @@
 
 	/* validity check */
 	if (msg != NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"msg has to be NULL in this function.\n");
 		goto end;
 	}
 	if (iph2->status != PHASE2ST_GETSPIDONE) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
 
 	/* update responders SPI */
 	if (ipsecdoi_updatespi(iph2) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL, "failed to update spi.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "failed to update spi.\n");
 		goto end;
 	}
 
 	/* generate NONCE value */
-	iph2->nonce = eay_set_random(iph2->ph1->rmconf->nonce_size);
+	iph2->nonce = eay_set_random(ikev1_nonce_size(iph2->ph1->rmconf));
 	if (iph2->nonce == NULL)
 		goto end;
 
@@ -1213,7 +1257,7 @@
 	if (iph2->dhpub_p != NULL && pfsgroup != 0) {
 		/* DH group settting if PFS is required. */
 		if (oakley_setdhgroup(pfsgroup, &iph2->pfsgrp) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to set DH value.\n");
 			goto end;
 		}
@@ -1235,7 +1279,7 @@
 
 	body = vmalloc(tlen);
 	if (body == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		goto end;
 	}
@@ -1323,7 +1367,7 @@
 
 	tmp = vmalloc(iph2->nonce_p->l + body->l);
 	if (tmp == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer.\n");
 		goto end;
 	}
@@ -1343,13 +1387,13 @@
 		goto end;
 
 	/* send the packet, add to the schedule to resend */
-	iph2->retry_counter = iph2->ph1->rmconf->retry_counter;
+	iph2->retry_counter = ikev1_max_retry_to_send(iph2->ph1->rmconf);
 	if (isakmp_ph2resend(iph2) == -1)
 		goto end;
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph2->ph1->remote, iph2->ph1->local, iph2->sendbuf, iph2->msg1) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR , PLOGLOC, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -1385,15 +1429,16 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_MSG1SENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
 
 	/* decrypt packet */
 	if (!ISSET(((struct isakmp *)msg0->v)->flags, ISAKMP_FLAG_E)) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"Packet wasn't encrypted.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "Packet wasn't encrypted.\n");
 		goto end;
 	}
 	msg = oakley_do_decrypt(iph2->ph1, msg0, iph2->ivm->iv, iph2->ivm->ive);
@@ -1418,18 +1463,20 @@
 			break;
 		default:
 			/* don't send information, see ident_r1recv() */
-			plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-				"ignore the packet, "
-				"received unexpecting payload type %d.\n",
-				pa->type);
+			isakmp_log(0, 0, iph2->ph1->remote, 0,
+				   PLOG_PROTOERR, PLOGLOC,
+				   "ignore the packet, "
+				   "received unexpecting payload type %d.\n",
+				   pa->type);
 			goto end;
 		}
 	}
 
 	/* payload existency check */
 	if (hash == NULL) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"few isakmp message received.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "few isakmp message received.\n");
 		goto end;
 	}
 
@@ -1443,12 +1490,12 @@
 
 	r_hash = (char *)hash + sizeof(*hash);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH(3) validate:");
-	plogdump(LLV_DEBUG, r_hash, ntohs(hash->h.len) - sizeof(*hash));
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH(3) validate:");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, r_hash, ntohs(hash->h.len) - sizeof(*hash));
 
 	tmp = vmalloc(iph2->nonce_p->l + iph2->nonce->l);
 	if (tmp == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer.\n");
 		goto end;
 	}
@@ -1464,8 +1511,9 @@
 	vfree(my_hash);
 
 	if (result) {
-		plog(LLV_ERROR, LOCATION, iph2->ph1->remote,
-			"HASH(3) mismatch.\n");
+		isakmp_log(0, 0, iph2->ph1->remote, 0,
+			   PLOG_PROTOERR, PLOGLOC,
+			   "HASH(3) mismatch.\n");
 		error = ISAKMP_NTYPE_INVALID_HASH_INFORMATION;
 		goto end;
 	}
@@ -1507,27 +1555,27 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_COMMIT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
 
 	/* generate HASH(4) */
 	/* XXX What can I do in the case of multiple different SA */
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH(4) generate\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH(4) generate\n");
 
 	/* XXX What should I do if there are multiple SAs ? */
 	tlen = sizeof(struct isakmp_pl_n) + iph2->approval->head->spisize;
 	notify = vmalloc(tlen);
 	if (notify == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get notify buffer.\n");
 		goto end;
 	}
 	n = (struct isakmp_pl_n *)notify->v;
 	n->h.np = ISAKMP_NPTYPE_NONE;
 	n->h.len = htons(tlen);
-	n->doi = htonl(IPSEC_DOI);
+	n->doi = IPSEC_DOI;
 	n->proto_id = iph2->approval->head->proto_id;
 	n->spi_size = sizeof(iph2->approval->head->spisize);
 	n->type = htons(ISAKMP_NTYPE_CONNECTED);
@@ -1543,7 +1591,7 @@
 		+ notify->l;
 	buf = vmalloc(tlen);
 	if (buf == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		goto end;
 	}
@@ -1574,7 +1622,7 @@
 
 	/* the sending message is added to the received-list. */
 	if (add_recvdpkt(iph2->ph1->remote, iph2->ph1->local, iph2->sendbuf, msg0) == -1) {
-		plog(LLV_ERROR , LOCATION, NULL,
+		plog(PLOG_INTERR , PLOGLOC, NULL,
 			"failed to add a response packet to the tree.\n");
 		goto end;
 	}
@@ -1594,17 +1642,6 @@
 	return error;
 }
 
-int
-tunnel_mode_prop(p)
-	struct saprop *p;
-{
-	struct saproto *pr;
-
-	for (pr = p->head; pr; pr = pr->next)
-		if (pr->encmode == IPSECDOI_ATTR_ENC_MODE_TUNNEL)
-			return 1;
-	return 0;
-}
 
 /*
  * set SA to kernel.
@@ -1619,7 +1656,7 @@
 
 	/* validity check */
 	if (iph2->status != PHASE2ST_STATUS6) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"status mismatched %d.\n", iph2->status);
 		goto end;
 	}
@@ -1631,33 +1668,36 @@
 	iph2->status = PHASE2ST_ADDSA;
 	iph2->flags ^= ISAKMP_FLAG_C;	/* reset bit */
 
+#if 0
 	/* don't anything if local test mode. */
 	if (f_local) {
 		error = 0;
 		goto end;
 	}
+#endif
 
 	/* Do UPDATE as responder */
-	plog(LLV_DEBUG, LOCATION, NULL, "call pk_sendupdate\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "call pk_sendupdate\n");
 	if (pk_sendupdate(iph2) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL, "pfkey update failed.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "pfkey update failed.\n");
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "pfkey update sent.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pfkey update sent.\n");
 
 	/* Do ADD for responder */
 	if (pk_sendadd(iph2) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL, "pfkey add failed.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "pfkey add failed.\n");
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "pfkey add sent.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pfkey add sent.\n");
 
 	/*
 	 * set policies into SPD if the policy is generated
 	 * from peer's policy.
 	 */
 	if (iph2->spidx_gen) {
-
+		TRACE((PLOGLOC, "not implemented\n"));
+#ifdef notyet
 		struct policyindex *spidx;
 		struct sockaddr_storage addr;
 		u_int8_t pref;
@@ -1668,31 +1708,17 @@
 		iph2->src = dst;
 		iph2->dst = src;
 		if (pk_sendspdupdate2(iph2) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"pfkey spdupdate2(inbound) failed.\n");
 			goto end;
 		}
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"pfkey spdupdate2(inbound) sent.\n");
 
-		spidx = (struct policyindex *)iph2->spidx_gen;
-#ifdef HAVE_POLICY_FWD
-		/* make forward policy if required */
-		if (tunnel_mode_prop(iph2->approval)) {
-			spidx->dir = IPSEC_DIR_FWD;
-			if (pk_sendspdupdate2(iph2) < 0) {
-				plog(LLV_ERROR, LOCATION, NULL,
-					"pfkey spdupdate2(forward) failed.\n");
-				goto end;
-			}
-			plog(LLV_DEBUG, LOCATION, NULL,
-				"pfkey spdupdate2(forward) sent.\n");
-		}
-#endif
-
 		/* make outbound policy */
 		iph2->src = src;
 		iph2->dst = dst;
+		spidx = (struct policyindex *)iph2->spidx_gen;
 		spidx->dir = IPSEC_DIR_OUTBOUND;
 		addr = spidx->src;
 		spidx->src = spidx->dst;
@@ -1702,18 +1728,18 @@
 		spidx->prefd = pref;
 
 		if (pk_sendspdupdate2(iph2) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"pfkey spdupdate2(outbound) failed.\n");
 			goto end;
 		}
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"pfkey spdupdate2(outbound) sent.\n");
 
 		/* spidx_gen is unnecessary any more */
 		delsp_bothdir((struct policyindex *)iph2->spidx_gen);
 		racoon_free(iph2->spidx_gen);
 		iph2->spidx_gen = NULL;
-		iph2->generated_spidx=1;
+#endif
 	}
 
 	error = 0;
@@ -1725,6 +1751,7 @@
 	return error;
 }
 
+
 /*
  * create HASH, body (SA, NONCE) payload with isakmp header.
  */
@@ -1746,7 +1773,7 @@
 		+ body->l;
 	buf = vmalloc(tlen);
 	if (buf == NULL) { 
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to send.\n");
 		goto end;
 	}
@@ -1772,7 +1799,6 @@
 
 	/* encoding */
 	new = oakley_do_encrypt(iph2->ph1, buf, iph2->ivm->ive, iph2->ivm->iv);
-	
 	if (new == NULL)
 		goto end;
 
@@ -1812,7 +1838,7 @@
 			prefixlen = sizeof(struct in6_addr) << 3;
 			break;
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid family: %d\n", iph2->src->sa_family);
 			goto end;
 		}
@@ -1822,7 +1848,7 @@
 		idsrc = vdup(iph2->id);
 	}
 	if (idsrc == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to set ID for source.\n");
 		goto end;
 	}
@@ -1836,7 +1862,7 @@
 			prefixlen = sizeof(struct in6_addr) << 3;
 			break;
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid family: %d\n", iph2->dst->sa_family);
 			goto end;
 		}
@@ -1846,19 +1872,19 @@
 		iddst = vdup(iph2->id_p);
 	}
 	if (iddst == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"failed to set ID for destination.\n");
 		goto end;
 	}
 
 	iph2->sainfo = getsainfo(idsrc, iddst, iph2->ph1->id_p);
 	if (iph2->sainfo == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get sainfo.\n");
 		goto end;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"get sa info: %s\n", sainfo2str(iph2->sainfo));
 
 	error = 0;
@@ -1871,6 +1897,7 @@
 	return error;
 }
 
+
 /*
  * Copy both IP addresses in ID payloads into [src,dst]_id if both ID types
  * are IP address and same address family.
@@ -1885,6 +1912,47 @@
 get_proposal_r(iph2)
 	struct ph2handle *iph2;
 {
+	vchar_t	* sl_index;
+	struct rcf_selector *selector;
+	struct rcf_policy *p;
+
+	/* check the existence of ID payload */
+	if ((iph2->id_p != NULL && iph2->id == NULL)
+	 || (iph2->id_p == NULL && iph2->id != NULL)) {
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
+			"Both IDs wasn't found in payload.\n");
+		return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
+	}
+
+	if (iph2->src_id || iph2->dst_id) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "ph2handle has ID[src, dst] already\n");
+		return ISAKMP_INTERNAL_ERROR;
+	}
+
+	sl_index = iph2->ph1->rmconf->sl_index;
+	if (rcf_get_selector(vmem2str(sl_index), &selector)) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "can't find selector (index %s)\n",
+		     sl_index);
+		return ISAKMP_INTERNAL_ERROR;
+	}
+	p = selector->pl;
+	if (!p) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "selector (index %s) does not have policy\n",
+		     sl_index);
+		return ISAKMP_INTERNAL_ERROR;
+	}
+
+	if (set_proposal_from_policy(iph2, p, 0)) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "failed to create saprop.\n");
+		return ISAKMP_INTERNAL_ERROR;
+	}
+
+	return 0;
+#if 0
 	struct policyindex spidx;
 	struct secpolicy *sp_in, *sp_out;
 	int idi2type = 0;	/* switch whether copy IDs into id[src,dst]. */
@@ -1893,14 +1961,14 @@
 	/* check the existence of ID payload */
 	if ((iph2->id_p != NULL && iph2->id == NULL)
 	 || (iph2->id_p == NULL && iph2->id != NULL)) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"Both IDs wasn't found in payload.\n");
 		return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 	}
 
 	/* make sure if id[src,dst] is null. */
 	if (iph2->src_id || iph2->dst_id) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"Why do ID[src,dst] exist already.\n");
 		return ISAKMP_INTERNAL_ERROR;
 	}
@@ -1950,7 +2018,7 @@
 
 	} else {
 
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"get a destination address of SP index "
 			"from phase1 address "
 			"due to no ID payloads found "
@@ -1961,7 +2029,7 @@
 		 * of the key to search the SPD because the direction of policy
 		 * is inbound.
 		 */
-		memcpy(&spidx.dst, iph2->src, sysdep_sa_len(iph2->src));
+		memcpy(&spidx.dst, iph2->src, iph2->src->sa_len);
 		switch (spidx.dst.ss_family) {
 		case AF_INET:
 			spidx.prefd = sizeof(struct in_addr) << 3;
@@ -2006,19 +2074,19 @@
 		/* make id[src,dst] if both ID types are IP address and same */
 		if (_XIDT(iph2->id_p) == idi2type
 		 && spidx.dst.ss_family == spidx.src.ss_family) {
-			iph2->src_id = dupsaddr((struct sockaddr *)&spidx.dst);
-			iph2->dst_id = dupsaddr((struct sockaddr *)&spidx.src);
+			iph2->src_id = rcs_sadup((struct sockaddr *)&spidx.dst);
+			iph2->dst_id = rcs_sadup((struct sockaddr *)&spidx.src);
 		}
 
 	} else {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"get a source address of SP index "
 			"from phase1 address "
 			"due to no ID payloads found "
 			"OR because ID type is not address.\n");
 
 		/* see above comment. */
-		memcpy(&spidx.src, iph2->dst, sysdep_sa_len(iph2->dst));
+		memcpy(&spidx.src, iph2->dst, iph2->dst->sa_len);
 		switch (spidx.src.ss_family) {
 		case AF_INET:
 			spidx.prefs = sizeof(struct in_addr) << 3;
@@ -2036,15 +2104,15 @@
 
 #undef _XIDT
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"get a src address from ID payload "
 		"%s prefixlen=%u ul_proto=%u\n",
-		saddr2str((struct sockaddr *)&spidx.src),
+	     rcs_sa2str((struct sockaddr *)&spidx.src),
 		spidx.prefs, spidx.ul_proto);
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"get dst address from ID payload "
 		"%s prefixlen=%u ul_proto=%u\n",
-		saddr2str((struct sockaddr *)&spidx.dst),
+		rcs_sa2str((struct sockaddr *)&spidx.dst),
 		spidx.prefd, spidx.ul_proto);
 
 	/*
@@ -2058,37 +2126,23 @@
 	sp_in = getsp_r(&spidx);
 	if (sp_in == NULL) {
 		if (iph2->ph1->rmconf->gen_policy) {
-			plog(LLV_INFO, LOCATION, NULL,
+			plog(PLOG_INFO, PLOGLOC, NULL,
 				"no policy found, "
 				"try to generate the policy : %s\n",
 				spidx2str(&spidx));
 			iph2->spidx_gen = racoon_malloc(sizeof(spidx));
 			if (!iph2->spidx_gen) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"buffer allocation failed.\n");
 				return ISAKMP_INTERNAL_ERROR;
 			}
 			memcpy(iph2->spidx_gen, &spidx, sizeof(spidx));
 			return -2;	/* special value */
 		}
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"no policy found: %s\n", spidx2str(&spidx));
 		return ISAKMP_INTERNAL_ERROR;
 	}
-	/* Refresh existing generated policies
-	 */
-	if (iph2->ph1->rmconf->gen_policy) {
-		plog(LLV_INFO, LOCATION, NULL,
-			 "Update the generated policy : %s\n",
-			 spidx2str(&spidx));
-		iph2->spidx_gen = racoon_malloc(sizeof(spidx));
-		if (!iph2->spidx_gen) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				 "buffer allocation failed.\n");
-			return ISAKMP_INTERNAL_ERROR;
-		}
-		memcpy(iph2->spidx_gen, &spidx, sizeof(spidx));
-	}
 
 	/* get outbound policy */
     {
@@ -2105,13 +2159,13 @@
 
 	sp_out = getsp_r(&spidx);
 	if (!sp_out) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_INTWARN, PLOGLOC, NULL,
 			"no outbound policy found: %s\n",
 			spidx2str(&spidx));
 	}
     }
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"suitable SP found:%s\n", spidx2str(&spidx));
 
 	/*
@@ -2119,7 +2173,7 @@
 	 * outbound policy is not checked currently.
 	 */
 	if (sp_in->policy != IPSEC_POLICY_IPSEC) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"policy found, but no IPsec required: %s\n",
 			spidx2str(&spidx));
 		return ISAKMP_INTERNAL_ERROR;
@@ -2127,11 +2181,45 @@
 
 	/* set new proposal derived from a policy into the iph2->proposal. */
 	if (set_proposal_from_policy(iph2, sp_in, sp_out) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to create saprop.\n");
 		return ISAKMP_INTERNAL_ERROR;
 	}
 
 	return 0;
+#endif
 }
 
+#ifdef INET6
+static u_int32_t
+setscopeid(sp_addr0, sa_addr0)
+	struct sockaddr *sp_addr0, *sa_addr0;
+{
+	struct sockaddr_in6 *sp_addr, *sa_addr;
+    
+	sp_addr = (struct sockaddr_in6 *)sp_addr0;
+	sa_addr = (struct sockaddr_in6 *)sa_addr0;
+
+	if (!IN6_IS_ADDR_LINKLOCAL(&sp_addr->sin6_addr)
+	 && !IN6_IS_ADDR_SITELOCAL(&sp_addr->sin6_addr)
+	 && !IN6_IS_ADDR_MULTICAST(&sp_addr->sin6_addr))
+		return 0;
+
+	/* this check should not be here ? */
+	if (sa_addr->sin6_family != AF_INET6) {
+		plog(PLOG_INTERR, PLOGLOC, NULL,
+			"can't get scope ID: family mismatch\n");
+		return -1;
+	}
+
+	if (!IN6_IS_ADDR_LINKLOCAL(&sa_addr->sin6_addr)) {
+		plog(PLOG_INTERR, PLOGLOC, NULL,
+			"scope ID is not supported except of lladdr.\n");
+		return -1;
+	}
+
+	sp_addr->sin6_scope_id = sa_addr->sin6_scope_id;
+
+	return 0;
+}
+#endif
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_quick.h ./isakmp_quick.h
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/isakmp_quick.h	Sat Jun 12 01:00:16 2004
+++ ./isakmp_quick.h	Mon Nov  7 19:06:50 2005
@@ -1,4 +1,4 @@
-/* $Id: diff.ipsec-tools,v 1.2 2006/07/20 10:04:07 fukumoto Exp $ */
+/*	$KAME: isakmp_quick.h,v 1.5 2000/10/04 17:41:01 itojun Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -29,9 +29,6 @@
  * SUCH DAMAGE.
  */
 
-#ifndef _ISAKMP_QUICK_H
-#define _ISAKMP_QUICK_H
-
 extern int quick_i1prep __P((struct ph2handle *, vchar_t *));
 extern int quick_i1send __P((struct ph2handle *, vchar_t *));
 extern int quick_i2recv __P((struct ph2handle *, vchar_t *));
@@ -44,5 +41,3 @@
 extern int quick_r3recv __P((struct ph2handle *, vchar_t *));
 extern int quick_r3send __P((struct ph2handle *, vchar_t *));
 extern int quick_r3prep __P((struct ph2handle *, vchar_t *));
-
-#endif /* _ISAKMP_QUICK_H */
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_unity.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_unity.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_var.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_xauth.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: isakmp_xauth.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: kmpstat.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: localconf.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: localconf.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: logger.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: logger.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: main.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: misc.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: misc.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: missing
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: nattraversal.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: nattraversal.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: netdb_dnssec.h
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/oakley.c ./oakley.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/oakley.c	Thu Oct  6 01:55:41 2005
+++ ./oakley.c	Thu Feb  2 17:04:11 2006
@@ -35,6 +35,7 @@
 #include <sys/param.h>
 #include <sys/socket.h>	/* XXX for subjectaltname */
 #include <netinet/in.h>	/* XXX for subjectaltname */
+#include <netdb.h>
 
 #include <openssl/pkcs7.h>
 #include <openssl/x509.h>
@@ -58,37 +59,40 @@
 #include <resolv.h>
 #endif
 
+#include "racoon.h"
+
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "str2val.h"
 #include "plog.h"
 #include "debug.h"
 
-#include "isakmp_var.h"
 #include "isakmp.h"
+#include "isakmp_var.h"
 #ifdef ENABLE_HYBRID
 #include "isakmp_xauth.h"
 #include "isakmp_cfg.h" 
 #endif                
 #include "oakley.h"
-#include "admin.h"
-#include "privsep.h"
-#include "localconf.h"
+/* #include "admin.h" */
+/* #include "privsep.h" */
+/* #include "localconf.h" */
 #include "remoteconf.h"
-#include "policy.h"
+/* #include "policy.h" */
+#include "isakmp_impl.h"
 #include "handler.h"
 #include "ipsec_doi.h"
 #include "algorithm.h"
 #include "dhgroup.h"
 #include "sainfo.h"
 #include "proposal.h"
-#include "crypto_openssl.h"
-#include "dnssec.h"
+#include "crypto_impl.h"
+/* #include "dnssec.h" */
 #include "sockmisc.h"
 #include "strnames.h"
 #include "gcmalloc.h"
-#include "rsalist.h"
+/* #include "rsalist.h" */
 
 #ifdef HAVE_GSSAPI
 #include "gssapi.h"
@@ -97,27 +101,6 @@
 #define OUTBOUND_SA	0
 #define INBOUND_SA	1
 
-#define INITDHVAL(a, s, d, t)                                                  \
-do {                                                                           \
-	vchar_t buf;                                                           \
-	buf.v = str2val((s), 16, &buf.l);                                      \
-	memset(&a, 0, sizeof(struct dhgroup));                                 \
-	a.type = (t);                                                          \
-	a.prime = vdup(&buf);                                                  \
-	a.gen1 = 2;                                                            \
-	a.gen2 = 0;                                                            \
-	racoon_free(buf.v);                                                    \
-} while(0);
-
-struct dhgroup dh_modp768;
-struct dhgroup dh_modp1024;
-struct dhgroup dh_modp1536;
-struct dhgroup dh_modp2048;
-struct dhgroup dh_modp3072;
-struct dhgroup dh_modp4096;
-struct dhgroup dh_modp6144;
-struct dhgroup dh_modp8192;
-
 
 static int oakley_check_dh_pub __P((vchar_t *, vchar_t **));
 static int oakley_compute_keymat_x __P((struct ph2handle *, int, int));
@@ -135,29 +118,6 @@
 	return OAKLEY_ATTR_SA_LD_SEC_DEFAULT;
 }
 
-int
-oakley_dhinit()
-{
-	/* set DH MODP */
-	INITDHVAL(dh_modp768, OAKLEY_PRIME_MODP768,
-		OAKLEY_ATTR_GRP_DESC_MODP768, OAKLEY_ATTR_GRP_TYPE_MODP);
-	INITDHVAL(dh_modp1024, OAKLEY_PRIME_MODP1024,
-		OAKLEY_ATTR_GRP_DESC_MODP1024, OAKLEY_ATTR_GRP_TYPE_MODP);
-	INITDHVAL(dh_modp1536, OAKLEY_PRIME_MODP1536,
-		OAKLEY_ATTR_GRP_DESC_MODP1536, OAKLEY_ATTR_GRP_TYPE_MODP);
-	INITDHVAL(dh_modp2048, OAKLEY_PRIME_MODP2048,
-		OAKLEY_ATTR_GRP_DESC_MODP2048, OAKLEY_ATTR_GRP_TYPE_MODP);
-	INITDHVAL(dh_modp3072, OAKLEY_PRIME_MODP3072,
-		OAKLEY_ATTR_GRP_DESC_MODP3072, OAKLEY_ATTR_GRP_TYPE_MODP);
-	INITDHVAL(dh_modp4096, OAKLEY_PRIME_MODP4096,
-		OAKLEY_ATTR_GRP_DESC_MODP4096, OAKLEY_ATTR_GRP_TYPE_MODP);
-	INITDHVAL(dh_modp6144, OAKLEY_PRIME_MODP6144,
-		OAKLEY_ATTR_GRP_DESC_MODP6144, OAKLEY_ATTR_GRP_TYPE_MODP);
-	INITDHVAL(dh_modp8192, OAKLEY_PRIME_MODP8192,
-		OAKLEY_ATTR_GRP_DESC_MODP8192, OAKLEY_ATTR_GRP_TYPE_MODP);
-
-	return 0;
-}
 
 void
 oakley_dhgrp_free(dhgrp)
@@ -192,7 +152,7 @@
 
 	if (prime->l < pub->l) {
 		/* what should i do ? */
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"invalid public information was generated.\n");
 		return -1;
 	}
@@ -200,7 +160,7 @@
 	/* prime->l > pub->l */
 	tmp = vmalloc(prime->l);
 	if (tmp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get DH buffer.\n");
 		return -1;
 	}
@@ -212,111 +172,6 @@
 	return 0;
 }
 
-/*
- * compute sharing secret of DH
- * IN:	*dh, *pub, *priv, *pub_p
- * OUT: **gxy
- */
-int
-oakley_dh_compute(dh, pub, priv, pub_p, gxy)
-	const struct dhgroup *dh;
-	vchar_t *pub, *priv, *pub_p, **gxy;
-{
-#ifdef ENABLE_STATS
-	struct timeval start, end;
-#endif
-	if ((*gxy = vmalloc(dh->prime->l)) == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"failed to get DH buffer.\n");
-		return -1;
-	}
-
-#ifdef ENABLE_STATS
-	gettimeofday(&start, NULL);
-#endif
-	switch (dh->type) {
-	case OAKLEY_ATTR_GRP_TYPE_MODP:
-		if (eay_dh_compute(dh->prime, dh->gen1, pub, priv, pub_p, gxy) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"failed to compute dh value.\n");
-			return -1;
-		}
-		break;
-	case OAKLEY_ATTR_GRP_TYPE_ECP:
-	case OAKLEY_ATTR_GRP_TYPE_EC2N:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"dh type %d isn't supported.\n", dh->type);
-		return -1;
-	default:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"invalid dh type %d.\n", dh->type);
-		return -1;
-	}
-
-#ifdef ENABLE_STATS
-	gettimeofday(&end, NULL);
-	syslog(LOG_NOTICE, "%s(%s%d): %8.6f", __func__,
-		s_attr_isakmp_group(dh->type), dh->prime->l << 3,
-		timedelta(&start, &end));
-#endif
-
-	plog(LLV_DEBUG, LOCATION, NULL, "compute DH's shared.\n");
-	plogdump(LLV_DEBUG, (*gxy)->v, (*gxy)->l);
-
-	return 0;
-}
-
-/*
- * generate values of DH
- * IN:	*dh
- * OUT: **pub, **priv
- */
-int
-oakley_dh_generate(dh, pub, priv)
-	const struct dhgroup *dh;
-	vchar_t **pub, **priv;
-{
-#ifdef ENABLE_STATS
-	struct timeval start, end;
-	gettimeofday(&start, NULL);
-#endif
-	switch (dh->type) {
-	case OAKLEY_ATTR_GRP_TYPE_MODP:
-		if (eay_dh_generate(dh->prime, dh->gen1, dh->gen2, pub, priv) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"failed to compute dh value.\n");
-			return -1;
-		}
-		break;
-
-	case OAKLEY_ATTR_GRP_TYPE_ECP:
-	case OAKLEY_ATTR_GRP_TYPE_EC2N:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"dh type %d isn't supported.\n", dh->type);
-		return -1;
-	default:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"invalid dh type %d.\n", dh->type);
-		return -1;
-	}
-
-#ifdef ENABLE_STATS
-	gettimeofday(&end, NULL);
-	syslog(LOG_NOTICE, "%s(%s%d): %8.6f", __func__,
-		s_attr_isakmp_group(dh->type), dh->prime->l << 3,
-		timedelta(&start, &end));
-#endif
-
-	if (oakley_check_dh_pub(dh->prime, pub) != 0)
-		return -1;
-
-	plog(LLV_DEBUG, LOCATION, NULL, "compute DH's private.\n");
-	plogdump(LLV_DEBUG, (*priv)->v, (*priv)->l);
-	plog(LLV_DEBUG, LOCATION, NULL, "compute DH's public.\n");
-	plogdump(LLV_DEBUG, (*pub)->v, (*pub)->l);
-
-	return 0;
-}
 
 /*
  * copy pre-defined dhgroup values.
@@ -332,21 +187,21 @@
 
 	g = alg_oakley_dhdef_group(group);
 	if (g == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid DH parameter grp=%d.\n", group);
 		return -1;
 	}
 
 	if (!g->type || !g->prime || !g->gen1) {
 		/* unsuported */
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"unsupported DH parameters grp=%d.\n", group);
 		return -1;
 	}
 
 	*dhgrp = racoon_calloc(1, sizeof(struct dhgroup));
 	if (*dhgrp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get DH buffer.\n");
 		return 0;
 	}
@@ -385,7 +240,7 @@
 
 	res = alg_oakley_hmacdef_one(type, key, buf);
 	if (res == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid hmac algorithm %d.\n", type);
 		return NULL;
 	}
@@ -415,7 +270,7 @@
 
 	res = alg_oakley_hashdef_one(type, buf);
 	if (res == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid hash algoriym %d.\n", type);
 		return NULL;
 	}
@@ -446,7 +301,7 @@
 	 || oakley_compute_keymat_x(iph2, side, OUTBOUND_SA) < 0)
 		goto end;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "KEYMAT computed.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "KEYMAT computed.\n");
 
 	error = 0;
 
@@ -488,7 +343,7 @@
 		+ iph2->nonce_p->l);
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get keymat buffer.\n");
 		goto end;
 	}
@@ -518,8 +373,8 @@
 		p += bp->l;
 
 		/* compute IV */
-		plog(LLV_DEBUG, LOCATION, NULL, "KEYMAT compute with\n");
-		plogdump(LLV_DEBUG, buf->v, buf->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "KEYMAT compute with\n");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 		/* res = K1 */
 		res = oakley_prf(iph2->ph1->skeyid_d, buf, iph2->ph1);
@@ -551,14 +406,14 @@
 		default:
 			break;
 		}
-		plog(LLV_DEBUG, LOCATION, NULL, "encklen=%d authklen=%d\n",
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "encklen=%d authklen=%d\n",
 			encklen, authklen);
 
 		dupkeymat = (encklen + authklen) / 8 / res->l;
 		dupkeymat += 2;	/* safety mergin */
 		if (dupkeymat < 3)
 			dupkeymat = 3;
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"generating %zu bits of key (dupkeymat=%d)\n",
 			dupkeymat * 8 * res->l, dupkeymat);
 		if (0 < --dupkeymat) {
@@ -576,13 +431,13 @@
 			 *   K3 = prf(SKEYID_d, K2 | src)
 			 *   Kn = prf(SKEYID_d, K(n-1) | src)
 			 */
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"generating K1...K%d for KEYMAT.\n",
 				dupkeymat + 1);
 
 			seed = vmalloc(prev->l + buf->l);
 			if (seed == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to get keymat buffer.\n");
 				if (prev && prev != res)
 					vfree(prev);
@@ -597,7 +452,7 @@
 				this = oakley_prf(iph2->ph1->skeyid_d, seed,
 							iph2->ph1);
 				if (!this) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_PROTOERR, PLOGLOC, NULL,
 						"oakley_prf memory overflow\n");
 					if (prev && prev != res)
 						vfree(prev);
@@ -609,7 +464,7 @@
 				l = res->l;
 				res = vrealloc(res, l + this->l);
 				if (res == NULL) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_INTERR, PLOGLOC, NULL,
 						"failed to get keymat buffer.\n");
 					if (prev && prev != res)
 						vfree(prev);
@@ -630,7 +485,7 @@
 			vfree(seed);
 		}
 
-		plogdump(LLV_DEBUG, res->v, res->l);
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, res->v, res->l);
 
 		if (sa_dir == INBOUND_SA)
 			pr->keymat = res;
@@ -687,7 +542,7 @@
 
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer\n");
 		return NULL;
 	}
@@ -701,8 +556,8 @@
 	}
 	va_end(ap);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH with: \n");
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH with: \n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	/* compute HASH */
 	res = oakley_prf(iph1->skeyid_a, buf, iph1);
@@ -710,8 +565,8 @@
 	if (res == NULL)
 		return NULL;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH computed:\n");
-	plogdump(LLV_DEBUG, res->v, res->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, res->v, res->l);
 
 	return res;
 }
@@ -735,7 +590,7 @@
 	len = 1 + sizeof(u_int32_t) + body->l;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"failed to get hash buffer\n");
 		goto end;
 	}
@@ -746,8 +601,8 @@
 
 	memcpy(buf->v + 1 + sizeof(u_int32_t), body->v, body->l);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH with: \n");
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH with: \n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	/* compute HASH */
 	res = oakley_prf(iph1->skeyid_a, buf, iph1);
@@ -756,8 +611,8 @@
 
 	error = 0;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH computed:\n");
-	plogdump(LLV_DEBUG, res->v, res->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, res->v, res->l);
 
 end:
 	if (buf != NULL)
@@ -790,7 +645,7 @@
 	len = sizeof(u_int32_t) + body->l;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"failed to get hash buffer\n");
 		goto end;
 	}
@@ -802,8 +657,8 @@
 
 	memcpy(p, body->v, body->l);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH with:\n");
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH with:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	/* compute HASH */
 	res = oakley_prf(iph1->skeyid_a, buf, iph1);
@@ -812,8 +667,8 @@
 
 	error = 0;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH computed:\n");
-	plogdump(LLV_DEBUG, res->v, res->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, res->v, res->l);
 
 end:
 	if (buf != NULL)
@@ -844,7 +699,7 @@
 	/* create buffer */
 	len = iph1->dhpub->l
 		+ iph1->dhpub_p->l
-		+ sizeof(cookie_t) * 2
+		+ sizeof(isakmp_cookie_t) * 2
 		+ iph1->sa->l
 		+ (sw == GENERATE ? iph1->id->l : iph1->id_p->l);
 
@@ -866,7 +721,7 @@
 
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer\n");
 		goto end;
 	}
@@ -887,7 +742,7 @@
 	else
 		bp2 = (sw == GENERATE ?
 		      (char *)&iph1->index.r_ck : (char *)&iph1->index.i_ck);
-	bl = sizeof(cookie_t);
+	bl = sizeof(isakmp_cookie_t);
 	memcpy(p, bp2, bl);
 	p += bl;
 
@@ -897,7 +752,7 @@
 	else
 		bp2 = (sw == GENERATE ?
 		      (char *)&iph1->index.i_ck : (char *)&iph1->index.r_ck);
-	bl = sizeof(cookie_t);
+	bl = sizeof(isakmp_cookie_t);
 	memcpy(p, bp2, bl);
 	p += bl;
 
@@ -921,8 +776,8 @@
 	}
 #endif
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH with:\n");
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH with:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	/* compute HASH */
 	res = oakley_prf(iph1->skeyid, buf, iph1);
@@ -931,9 +786,9 @@
 
 	error = 0;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH (%s) computed:\n",
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH (%s) computed:\n",
 		iph1->side == INITIATOR ? "init" : "resp");
-	plogdump(LLV_DEBUG, res->v, res->l);
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, res->v, res->l);
 
 end:
 	if (buf != NULL)
@@ -966,7 +821,7 @@
 
 	/* sanity check */
 	if (iph1->etype != ISAKMP_ETYPE_BASE) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid etype for this hash function\n");
 		return NULL;
 	}
@@ -984,7 +839,7 @@
 	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_R:
 #endif
 		if (iph1->skeyid == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL, "no SKEYID found.\n");
+			plog(PLOG_PROTOERR, PLOGLOC, NULL, "no SKEYID found.\n");
 			return NULL;
 		}
 		hashkey = iph1->skeyid;
@@ -1009,7 +864,7 @@
 		len = iph1->nonce->l + iph1->nonce_p->l;
 		buf = vmalloc(len);
 		if (buf == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to get hash buffer\n");
 			goto end;
 		}
@@ -1033,7 +888,7 @@
 		break;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"not supported authentication method %d\n",
 			iph1->approval->authmethod);
 		return NULL;
@@ -1041,12 +896,12 @@
 	}
 
 	len = (sw == GENERATE ? iph1->dhpub->l : iph1->dhpub_p->l)
-		+ sizeof(cookie_t) * 2
+		+ sizeof(isakmp_cookie_t) * 2
 		+ iph1->sa->l
 		+ (sw == GENERATE ? iph1->id->l : iph1->id_p->l);
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer\n");
 		goto end;
 	}
@@ -1056,10 +911,10 @@
 	memcpy(p, bp->v, bp->l);
 	p += bp->l;
 
-	memcpy(p, &iph1->index.i_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
-	memcpy(p, &iph1->index.r_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
+	memcpy(p, &iph1->index.i_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
+	memcpy(p, &iph1->index.r_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
 
 	memcpy(p, iph1->sa->v, iph1->sa->l);
 	p += iph1->sa->l;
@@ -1068,8 +923,8 @@
 	memcpy(p, bp->v, bp->l);
 	p += bp->l;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH_I with:\n");
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH_I with:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	/* compute HASH */
 	res = oakley_prf(hashkey, buf, iph1);
@@ -1078,8 +933,8 @@
 
 	error = 0;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH_I computed:\n");
-	plogdump(LLV_DEBUG, res->v, res->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH_I computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, res->v, res->l);
 
 end:
 	if (hash != NULL)
@@ -1107,7 +962,7 @@
 
 	/* sanity check */
 	if (iph1->etype != ISAKMP_ETYPE_BASE) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid etype for this hash function\n");
 		return NULL;
 	}
@@ -1128,7 +983,7 @@
 #endif
 		break;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"not supported authentication method %d\n",
 			iph1->approval->authmethod);
 		return NULL;
@@ -1139,7 +994,7 @@
 	len = iph1->nonce->l + iph1->nonce_p->l;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer\n");
 		goto end;
 	}
@@ -1162,12 +1017,12 @@
 	/* make really hash */
 	len = (sw == GENERATE ? iph1->dhpub_p->l : iph1->dhpub->l)
 		+ (sw == GENERATE ? iph1->dhpub->l : iph1->dhpub_p->l)
-		+ sizeof(cookie_t) * 2
+		+ sizeof(isakmp_cookie_t) * 2
 		+ iph1->sa->l
 		+ (sw == GENERATE ? iph1->id_p->l : iph1->id->l);
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get hash buffer\n");
 		goto end;
 	}
@@ -1182,10 +1037,10 @@
 	memcpy(p, bp->v, bp->l);
 	p += bp->l;
 
-	memcpy(p, &iph1->index.i_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
-	memcpy(p, &iph1->index.r_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
+	memcpy(p, &iph1->index.i_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
+	memcpy(p, &iph1->index.r_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
 
 	memcpy(p, iph1->sa->v, iph1->sa->l);
 	p += iph1->sa->l;
@@ -1194,8 +1049,8 @@
 	memcpy(p, bp->v, bp->l);
 	p += bp->l;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH with:\n");
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH with:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	/* compute HASH */
 	res = oakley_prf(hash, buf, iph1);
@@ -1204,8 +1059,8 @@
 
 	error = 0;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "HASH computed:\n");
-	plogdump(LLV_DEBUG, res->v, res->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, res->v, res->l);
 
 end:
 	if (buf != NULL)
@@ -1251,7 +1106,7 @@
 		char *r_hash;
 
 		if (iph1->id_p == NULL || iph1->pl_hash == NULL) {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"few isakmp message received.\n");
 			return ISAKMP_NTYPE_PAYLOAD_MALFORMED;
 		}
@@ -1259,7 +1114,7 @@
 		if (AUTHMETHOD(iph1) == FICTIVE_AUTH_METHOD_XAUTH_PSKEY_I &&
 		    ((iph1->mode_cfg->flags & ISAKMP_CFG_VENDORID_XAUTH) == 0))
 		{
-			plog(LLV_ERROR, LOCATION, NULL, "No SIG was passed, "
+			plog(PLOG_PROTOERR, PLOGLOC, NULL, "No SIG was passed, "
 			    "hybrid auth is enabled, "
 			    "but peer is no Xauth compliant\n");
 			return ISAKMP_NTYPE_SITUATION_NOT_SUPPORTED;
@@ -1268,8 +1123,8 @@
 #endif
 		r_hash = (caddr_t)(iph1->pl_hash + 1);
 
-		plog(LLV_DEBUG, LOCATION, NULL, "HASH received:\n");
-		plogdump(LLV_DEBUG, r_hash,
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH received:\n");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, r_hash,
 			ntohs(iph1->pl_hash->h.len) - sizeof(*iph1->pl_hash));
 
 		switch (iph1->etype) {
@@ -1284,7 +1139,7 @@
 				my_hash = oakley_ph1hash_base_i(iph1, VALIDATE);
 			break;
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid etype %d\n", iph1->etype);
 			return ISAKMP_NTYPE_INVALID_EXCHANGE_TYPE;
 		}
@@ -1295,11 +1150,11 @@
 		vfree(my_hash);
 
 		if (result) {
-			plog(LLV_ERROR, LOCATION, NULL, "HASH mismatched\n");
+			plog(PLOG_PROTOERR, PLOGLOC, NULL, "HASH mismatched\n");
 			return ISAKMP_NTYPE_INVALID_HASH_INFORMATION;
 		}
 
-		plog(LLV_DEBUG, LOCATION, NULL, "HASH for PSK validated.\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "HASH for PSK validated.\n");
 	    }
 		break;
 	case OAKLEY_ATTR_AUTH_METHOD_DSSSIG:
@@ -1318,33 +1173,33 @@
 
 		/* validation */
 		if (iph1->id_p == NULL) {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"no ID payload was passed.\n");
 			return ISAKMP_NTYPE_PAYLOAD_MALFORMED;
 		}
 		if (iph1->sig_p == NULL) {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"no SIG payload was passed.\n");
 			return ISAKMP_NTYPE_PAYLOAD_MALFORMED;
 		}
 
-		plog(LLV_DEBUG, LOCATION, NULL, "SIGN passed:\n");
-		plogdump(LLV_DEBUG, iph1->sig_p->v, iph1->sig_p->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "SIGN passed:\n");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->sig_p->v, iph1->sig_p->l);
 
 		/* get peer's cert */
-		switch (iph1->rmconf->getcert_method) {
+		switch (ikev1_getcert_method(iph1->rmconf)) {
 		case ISAKMP_GETCERT_PAYLOAD:
 			if (iph1->cert_p == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"no peer's CERT payload found.\n");
 				return ISAKMP_INTERNAL_ERROR;
 			}
 			break;
 		case ISAKMP_GETCERT_LOCALFILE:
-			switch (iph1->rmconf->certtype) {
+			switch (ikev1_certtype(iph1->rmconf)) {
 				case ISAKMP_CERT_X509SIGN:
-					if (iph1->rmconf->peerscertfile == NULL) {
-						plog(LLV_ERROR, LOCATION, NULL,
+					if (ikev1_peerscertfile(iph1->rmconf) == NULL) {
+						plog(PLOG_PROTOERR, PLOGLOC, NULL,
 							"no peer's CERT file found.\n");
 						return ISAKMP_INTERNAL_ERROR;
 					}
@@ -1358,16 +1213,18 @@
 					error = get_cert_fromlocal(iph1, 0);
 					break;
 
+#ifdef notyet
 				case ISAKMP_CERT_PLAINRSA:
 					error = get_plainrsa_fromlocal(iph1, 0);
 					break;
+#endif
 			}
 			if (error)
 				return ISAKMP_INTERNAL_ERROR;
 			break;
 		case ISAKMP_GETCERT_DNS:
-			if (iph1->rmconf->peerscertfile != NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+			if (ikev1_peerscertfile(iph1->rmconf) != NULL) {
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"why peer's CERT file is defined "
 					"though getcert method is dns ?\n");
 				return ISAKMP_INTERNAL_ERROR;
@@ -1381,27 +1238,27 @@
 
 			iph1->cert_p = dnssec_getcert(iph1->id_p);
 			if (iph1->cert_p == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"no CERT RR found.\n");
 				return ISAKMP_INTERNAL_ERROR;
 			}
 			break;
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid getcert_mothod: %d\n",
-				iph1->rmconf->getcert_method);
+			     ikev1_getcert_method(iph1->rmconf));
 			return ISAKMP_INTERNAL_ERROR;
 		}
 
 		/* compare ID payload and certificate name */
-		if (iph1->rmconf->verify_cert &&
+		if (ikev1_verify_cert(iph1->rmconf) &&
 		    (error = oakley_check_certid(iph1)) != 0)
 			return error;
 
 		/* verify certificate */
-		if (iph1->rmconf->verify_cert
-		 && iph1->rmconf->getcert_method == ISAKMP_GETCERT_PAYLOAD) {
-			certtype = iph1->rmconf->certtype;
+		if (ikev1_verify_cert(iph1->rmconf)
+		 && ikev1_getcert_method(iph1->rmconf) == ISAKMP_GETCERT_PAYLOAD) {
+			certtype = ikev1_certtype(iph1->rmconf);
 #ifdef ENABLE_HYBRID
 			switch (AUTHMETHOD(iph1)) {
 			case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
@@ -1417,7 +1274,8 @@
 				char path[MAXPATHLEN];
 				char *ca;
 
-				if (iph1->rmconf->cacertfile != NULL) {
+#ifdef notyet
+				if (ikev1_certtype(iph1->rmconf) != NULL) {
 					getpathname(path, sizeof(path), 
 					    LC_PATHTYPE_CERT, 
 					    iph1->rmconf->cacertfile);
@@ -1425,26 +1283,29 @@
 				} else {
 					ca = NULL;
 				}
-
 				error = eay_check_x509cert(&iph1->cert_p->cert,
 					lcconf->pathinfo[LC_PATHTYPE_CERT], 
 					ca, 0);
+#else
+				error = eay_check_x509cert(&iph1->cert_p->cert,
+							   0);
+#endif
 				break;
 			}
 			
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"no supported certtype %d\n", certtype);
 				return ISAKMP_INTERNAL_ERROR;
 			}
 			if (error != 0) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 					"the peer's certificate is not verified.\n");
 				return ISAKMP_NTYPE_INVALID_CERT_AUTHORITY;
 			}
 		}
 
-		plog(LLV_DEBUG, LOCATION, NULL, "CERT validated\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "CERT validated\n");
 
 		/* compute hash */
 		switch (iph1->etype) {
@@ -1459,7 +1320,7 @@
 				my_hash = oakley_ph1hash_base_i(iph1, VALIDATE);
 			break;
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid etype %d\n", iph1->etype);
 			return ISAKMP_NTYPE_INVALID_EXCHANGE_TYPE;
 		}
@@ -1467,7 +1328,7 @@
 			return ISAKMP_INTERNAL_ERROR;
 
 
-		certtype = iph1->rmconf->certtype;
+		certtype = ikev1_certtype(iph1->rmconf);
 #ifdef ENABLE_HYBRID
 		switch (AUTHMETHOD(iph1)) {
 		case OAKLEY_ATTR_AUTH_METHOD_HYBRID_RSA_I:
@@ -1486,14 +1347,16 @@
 					iph1->sig_p,
 					&iph1->cert_p->cert);
 			break;
+#ifdef notyet
 		case ISAKMP_CERT_PLAINRSA:
 			iph1->rsa_p = rsa_try_check_rsasign(my_hash,
 					iph1->sig_p, iph1->rsa_candidates);
 			error = iph1->rsa_p ? 0 : -1;
 
 			break;
+#endif
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"no supported certtype %d\n",
 				certtype);
 			vfree(my_hash);
@@ -1502,11 +1365,11 @@
 
 		vfree(my_hash);
 		if (error != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"Invalid SIG.\n");
 			return ISAKMP_NTYPE_INVALID_SIGNATURE;
 		}
-		plog(LLV_DEBUG, LOCATION, NULL, "SIG authenticated\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "SIG authenticated\n");
 	    }
 		break;
 #ifdef ENABLE_HYBRID
@@ -1514,13 +1377,13 @@
 	case OAKLEY_ATTR_AUTH_METHOD_HYBRID_DSS_R:
 	    {
 		if ((iph1->mode_cfg->flags & ISAKMP_CFG_VENDORID_XAUTH) == 0) {
-			plog(LLV_ERROR, LOCATION, NULL, "No SIG was passed, "
+			plog(PLOG_PROTOERR, PLOGLOC, NULL, "No SIG was passed, "
 			    "hybrid auth is enabled, "
 			    "but peer is no Xauth compliant\n");
 			return ISAKMP_NTYPE_SITUATION_NOT_SUPPORTED;
 			break;
 		}
-		plog(LLV_INFO, LOCATION, NULL, "No SIG was passed, "
+		plog(PLOG_INFO, PLOGLOC, NULL, "No SIG was passed, "
 		    "but hybrid auth is enabled\n");
 
 		return 0;
@@ -1540,7 +1403,7 @@
 			my_hash = oakley_ph1hash_common(iph1, VALIDATE);
 			break;
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid etype %d\n", iph1->etype);
 			return ISAKMP_NTYPE_INVALID_EXCHANGE_TYPE;
 		}
@@ -1563,10 +1426,10 @@
 		vfree(gsshash);
 
 		if (result) {
-			plog(LLV_ERROR, LOCATION, NULL, "HASH mismatched\n");
+			plog(PLOG_PROTOERR, PLOGLOC, NULL, "HASH mismatched\n");
 			return ISAKMP_NTYPE_INVALID_HASH_INFORMATION;
 		}
-		plog(LLV_DEBUG, LOCATION, NULL, "hash compared OK\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "hash compared OK\n");
 		break;
 #endif
 	case OAKLEY_ATTR_AUTH_METHOD_RSAENC:
@@ -1578,16 +1441,16 @@
 	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_R:
 #endif
 		if (iph1->id_p == NULL || iph1->pl_hash == NULL) {
-			plog(LLV_ERROR, LOCATION, iph1->remote,
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"few isakmp message received.\n");
 			return ISAKMP_NTYPE_PAYLOAD_MALFORMED;
 		}
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+		plog(PLOG_PROTOERR, PLOGLOC, 0,
 			"not supported authmethod type %s\n",
 			s_oakley_attr_method(iph1->approval->authmethod));
 		return ISAKMP_INTERNAL_ERROR;
 	default:
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+		plog(PLOG_PROTOERR, PLOGLOC, 0,
 			"invalid authmethod %d why ?\n",
 			iph1->approval->authmethod);
 		return ISAKMP_INTERNAL_ERROR;
@@ -1609,21 +1472,23 @@
 oakley_getmycert(iph1)
 	struct ph1handle *iph1;
 {
-	switch (iph1->rmconf->certtype) {
+	switch (ikev1_certtype(iph1->rmconf)) {
 		case ISAKMP_CERT_X509SIGN:
 			if (iph1->cert)
 				return 0;
 			return get_cert_fromlocal(iph1, 1);
 
+#ifdef notyet
 		case ISAKMP_CERT_PLAINRSA:
 			if (iph1->rsa)
 				return 0;
 			return get_plainrsa_fromlocal(iph1, 1);
+#endif
 
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			     "Unknown certtype #%d\n",
-			     iph1->rmconf->certtype);
+			     ikev1_certtype(iph1->rmconf));
 			return -1;
 	}
 
@@ -1647,40 +1512,44 @@
 	int error = -1;
 
 	if (my) {
-		certfile = iph1->rmconf->mycertfile;
+		certfile = ikev1_mycertfile(iph1->rmconf);
 		certpl = &iph1->cert;
 	} else {
-		certfile = iph1->rmconf->peerscertfile;
+		certfile = ikev1_peerscertfile(iph1->rmconf);
 		certpl = &iph1->cert_p;
 	}
 	if (!certfile) {
-		plog(LLV_ERROR, LOCATION, NULL, "no CERT defined.\n");
+		plog(PLOG_PROTOERR, PLOGLOC, NULL, "no CERT defined.\n");
 		return 0;
 	}
 
-	switch (iph1->rmconf->certtype) {
+	switch (ikev1_certtype(iph1->rmconf)) {
 	case ISAKMP_CERT_X509SIGN:
 	case ISAKMP_CERT_DNS:
 		/* make public file name */
+#if 0
 		getpathname(path, sizeof(path), LC_PATHTYPE_CERT, certfile);
 		cert = eay_get_x509cert(path);
+#else
+		cert = eay_get_x509cert(certfile);
+#endif
 		if (cert) {
 			char *p = NULL;
 			p = eay_get_x509text(cert);
-			plog(LLV_DEBUG, LOCATION, NULL, "%s", p ? p : "\n");
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "%s", p ? p : "\n");
 			racoon_free(p);
 		};
 		break;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"not supported certtype %d\n",
-			iph1->rmconf->certtype);
+			ikev1_certtype(iph1->rmconf));
 		goto end;
 	}
 
 	if (!cert) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get %s CERT.\n",
 			my ? "my" : "peers");
 		goto end;
@@ -1688,26 +1557,26 @@
 
 	*certpl = oakley_newcert();
 	if (!*certpl) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get cert buffer.\n");
 		goto end;
 	}
 	(*certpl)->pl = vmalloc(cert->l + 1);
 	if ((*certpl)->pl == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get cert buffer\n");
 		oakley_delcert(*certpl);
 		*certpl = NULL;
 		goto end;
 	}
 	memcpy((*certpl)->pl->v + 1, cert->v, cert->l);
-	(*certpl)->pl->v[0] = iph1->rmconf->certtype;
-	(*certpl)->type = iph1->rmconf->certtype;
+	(*certpl)->pl->v[0] = ikev1_certtype(iph1->rmconf);
+	(*certpl)->type = ikev1_certtype(iph1->rmconf);
 	(*certpl)->cert.v = (*certpl)->pl->v + 1;
 	(*certpl)->cert.l = (*certpl)->pl->l - 1;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "created CERT payload:\n");
-	plogdump(LLV_DEBUG, (*certpl)->pl->v, (*certpl)->pl->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "created CERT payload:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, (*certpl)->pl->v, (*certpl)->pl->l);
 
 	error = 0;
 
@@ -1728,9 +1597,10 @@
 	char *certfile;
 	int error = -1;
 
+#ifdef notyet
 	iph1->rsa_candidates = rsa_lookup_keys(iph1, my);
 	if (!iph1->rsa_candidates || rsa_list_count(iph1->rsa_candidates) == 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"%s RSA key not found for %s\n",
 			my ? "Private" : "Public",
 			saddr2str_fromto("%s <-> %s", iph1->local, iph1->remote));
@@ -1738,13 +1608,13 @@
 	}
 
 	if (my && rsa_list_count(iph1->rsa_candidates) > 1) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_INTWARN, PLOGLOC, NULL,
 			"More than one (=%lu) private PlainRSA key found for %s\n",
 			rsa_list_count(iph1->rsa_candidates),
 			saddr2str_fromto("%s <-> %s", iph1->local, iph1->remote));
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_INTWARN, PLOGLOC, NULL,
 			"This may have unpredictable results, i.e. wrong key could be used!\n");
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_INTWARN, PLOGLOC, NULL,
 			"Consider using only one single private key for all peers...\n");
 	}
 	if (my) {
@@ -1754,7 +1624,7 @@
 	}
 
 	error = 0;
-
+#endif
 end:
 	return error;
 }
@@ -1768,46 +1638,52 @@
 	vchar_t *privkey = NULL;
 	int error = -1;
 
-	switch (iph1->rmconf->certtype) {
+	switch (ikev1_certtype(iph1->rmconf)) {
 	case ISAKMP_CERT_X509SIGN:
 	case ISAKMP_CERT_DNS:
-		if (iph1->rmconf->myprivfile == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL, "no cert defined.\n");
+		if (ikev1_myprivfile(iph1->rmconf) == NULL) {
+			plog(PLOG_INTERR, PLOGLOC, NULL, "no cert defined.\n");
 			goto end;
 		}
 
 		/* make private file name */
+#if 0
 		getpathname(path, sizeof(path),
 			LC_PATHTYPE_CERT,
 			iph1->rmconf->myprivfile);
 		privkey = privsep_eay_get_pkcs1privkey(path);
+#else
+		privkey = eay_get_pkcs1privkey(ikev1_myprivfile(iph1->rmconf));
+#endif
 		if (privkey == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to get private key.\n");
 			goto end;
 		}
-		plog(LLV_DEBUG2, LOCATION, NULL, "private key:\n");
-		plogdump(LLV_DEBUG2, privkey->v, privkey->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "private key:\n");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, privkey->v, privkey->l);
 
-		iph1->sig = eay_get_x509sign(iph1->hash, privkey);
+		iph1->sig = eay_get_x509sign(iph1->hash, privkey, 0); /* ??? */
 		break;
+#ifdef notyet
 	case ISAKMP_CERT_PLAINRSA:
 		iph1->sig = eay_get_rsasign(iph1->hash, iph1->rsa);
 		break;
+#endif
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 		     "Unknown certtype #%d\n",
-		     iph1->rmconf->certtype);
+		     ikev1_certtype(iph1->rmconf));
 		goto end;
 	}
 
 	if (iph1->sig == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, "failed to sign.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "failed to sign.\n");
 		goto end;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL, "SIGN computed:\n");
-	plogdump(LLV_DEBUG, iph1->sig->v, iph1->sig->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "SIGN computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->sig->v, iph1->sig->l);
 
 	error = 0;
 
@@ -1832,7 +1708,7 @@
 	int error;
 
 	if (iph1->id_p == NULL || iph1->cert_p == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, "no ID nor CERT found.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "no ID nor CERT found.\n");
 		return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 	}
 
@@ -1843,12 +1719,12 @@
 	case IPSECDOI_ID_DER_ASN1_DN:
 		name = eay_get_x509asn1subjectname(&iph1->cert_p->cert);
 		if (!name) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to get subjectName\n");
 			return ISAKMP_NTYPE_INVALID_CERTIFICATE;
 		}
 		if (idlen != name->l) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"Invalid ID length in phase 1.\n");
 			vfree(name);
 			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
@@ -1856,7 +1732,7 @@
 		error = memcmp(id_b + 1, name->v, idlen);
 		vfree(name);
 		if (error != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"ID mismatched with subjectAltName.\n");
 			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 		}
@@ -1876,14 +1752,14 @@
 		for (pos = 1; ; pos++) {
 			if (eay_get_x509subjectaltname(&iph1->cert_p->cert,
 					&altname, &type, pos) !=0) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to get subjectAltName\n");
 				return ISAKMP_NTYPE_INVALID_CERTIFICATE;
 			}
 
 			/* it's the end condition of the loop. */
 			if (!altname) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"no proper subjectAltName.\n");
 				return ISAKMP_NTYPE_INVALID_CERTIFICATE;
 			}
@@ -1901,7 +1777,7 @@
 		hints.ai_flags = AI_NUMERICHOST;
 		error = getaddrinfo(altname, NULL, &hints, &res);
 		if (error != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"no proper subjectAltName.\n");
 			racoon_free(altname);
 			return ISAKMP_NTYPE_INVALID_CERTIFICATE;
@@ -1916,7 +1792,7 @@
 			break;
 #endif
 		default:
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"family not supported: %d.\n", res->ai_family);
 			racoon_free(altname);
 			freeaddrinfo(res);
@@ -1926,7 +1802,7 @@
 		freeaddrinfo(res);
 		vfree(name);
 		if (error != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"ID mismatched with subjectAltName.\n");
 			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 		}
@@ -1940,14 +1816,14 @@
 		for (pos = 1; ; pos++) {
 			if (eay_get_x509subjectaltname(&iph1->cert_p->cert,
 					&altname, &type, pos) != 0){
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to get subjectAltName\n");
 				return ISAKMP_NTYPE_INVALID_CERTIFICATE;
 			}
 
 			/* it's the end condition of the loop. */
 			if (!altname) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"no proper subjectAltName.\n");
 				return ISAKMP_NTYPE_INVALID_CERTIFICATE;
 			}
@@ -1960,13 +1836,13 @@
 			altname = NULL;
 		}
 		if (idlen != strlen(altname)) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"Invalid ID length in phase 1.\n");
 			racoon_free(altname);
 			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 		}
 		if (check_typeofcertname(id_b->type, type) != 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"ID type mismatched. ID: %s CERT: %s.\n",
 				s_ipsecdoi_ident(id_b->type),
 				s_ipsecdoi_ident(type));
@@ -1975,7 +1851,7 @@
 		}
 		error = memcmp(id_b + 1, altname, idlen);
 		if (error) {
-			plog(LLV_ERROR, LOCATION, NULL, "ID mismatched.\n");
+			plog(PLOG_PROTOERR, PLOGLOC, NULL, "ID mismatched.\n");
 			racoon_free(altname);
 			return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
 		}
@@ -1983,7 +1859,7 @@
 		return 0;
 	}
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"Inpropper ID type passed: %s.\n",
 			s_ipsecdoi_ident(id_b->type));
 		return ISAKMP_NTYPE_INVALID_ID_INFORMATION;
@@ -2039,7 +1915,7 @@
 
 	switch (type) {
 	case ISAKMP_CERT_DNS:
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"CERT payload is unnecessary in DNSSEC. "
 			"ignore this CERT payload.\n");
 		return 0;
@@ -2056,11 +1932,11 @@
 	case ISAKMP_CERT_X509KE:
 	case ISAKMP_CERT_X509ATTR:
 	case ISAKMP_CERT_ARL:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"No supported such CERT type %d\n", type);
 		return -1;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"Invalid CERT type %d\n", type);
 		return -1;
 	}
@@ -2068,7 +1944,7 @@
 	/* XXX choice the 1th cert, ignore after the cert. */ 
 	/* XXX should be processed. */
 	if (*c) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"ignore 2nd CERT payload.\n");
 		return 0;
 	}
@@ -2087,7 +1963,7 @@
 		    ntohs(gen->len) - sizeof(*gen) - 1);
 
 		if (!p7) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			     "Failed to parse PKCS#7 CERT.\n");
 			return -1;
 		}
@@ -2110,7 +1986,7 @@
 		}
 
 		if (!certs) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			     "CERT PKCS#7 bundle contains no certs.\n");
 			PKCS7_free(p7);
 			return -1;
@@ -2121,14 +1997,14 @@
 			u_char *bp;
 			X509 *cert = sk_X509_value(certs,i);
 
-			plog(LLV_DEBUG, LOCATION, NULL, 
+			plog(PLOG_DEBUG, PLOGLOC, NULL, 
 			     "Trying PKCS#7 cert %d.\n", i);
 
 			/* We'll just try each cert in turn */
 			*c = save_certx509(cert);
 
 			if (!*c) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 				     "Failed to get CERT buffer.\n");
 				continue;
 			}
@@ -2137,9 +2013,9 @@
 			 * XXX If verify cert is disabled, we still just take
 			 * the first certificate....
 			 */
-			if(iph1->rmconf->verify_cert &&
+			if(ikev1_verify_cert(iph1->rmconf) &&
 			   oakley_check_certid(iph1)) {
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 				     "Discarding CERT: does not match ID.\n");
 				oakley_delcert((*c));
 				*c = NULL;
@@ -2148,9 +2024,9 @@
 
 			{
 				char *p = eay_get_x509text(&(*c)->cert);
-				plog(LLV_DEBUG, LOCATION, NULL, "CERT saved:\n");
-				plogdump(LLV_DEBUG, (*c)->cert.v, (*c)->cert.l);
-				plog(LLV_DEBUG, LOCATION, NULL, "%s", 
+				plog(PLOG_DEBUG, PLOGLOC, NULL, "CERT saved:\n");
+				plogdump(PLOG_DEBUG, PLOGLOC, 0, (*c)->cert.v, (*c)->cert.l);
+				plog(PLOG_DEBUG, PLOGLOC, NULL, "%s", 
 				     p ? p : "\n");
 				racoon_free(p);
 			}
@@ -2161,14 +2037,14 @@
 	} else {
 		*c = save_certbuf(gen);
 		if (!*c) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 			     "Failed to get CERT buffer.\n");
 			return -1;
 		}
 
 		switch ((*c)->type) {
 		case ISAKMP_CERT_DNS:
-			plog(LLV_WARNING, LOCATION, NULL,
+			plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			     "CERT payload is unnecessary in DNSSEC. "
 			     "ignore it.\n");
 			return 0;
@@ -2180,9 +2056,9 @@
 			 * XXX If verify cert is disabled, we still just take
 			 * the first certificate....
 			 */
-			if(iph1->rmconf->verify_cert &&
+			if(ikev1_verify_cert(iph1->rmconf) &&
 			   oakley_check_certid(iph1)){
-				plog(LLV_DEBUG, LOCATION, NULL,
+				plog(PLOG_DEBUG, PLOGLOC, NULL,
 				     "Discarding CERT: does not match ID.\n");
 				oakley_delcert((*c));
 				*c = NULL;
@@ -2191,15 +2067,15 @@
 
 			{
 				char *p = eay_get_x509text(&(*c)->cert);
-				plog(LLV_DEBUG, LOCATION, NULL, "CERT saved:\n");
-				plogdump(LLV_DEBUG, (*c)->cert.v, (*c)->cert.l);
-				plog(LLV_DEBUG, LOCATION, NULL, "%s", p ? p : "\n");
+				plog(PLOG_DEBUG, PLOGLOC, NULL, "CERT saved:\n");
+				plogdump(PLOG_DEBUG, PLOGLOC, 0, (*c)->cert.v, (*c)->cert.l);
+				plog(PLOG_DEBUG, PLOGLOC, NULL, "%s", p ? p : "\n");
 				racoon_free(p);
 			}
 			break;
 		case ISAKMP_CERT_CRL:
-			plog(LLV_DEBUG, LOCATION, NULL, "CRL saved:\n");
-			plogdump(LLV_DEBUG, (*c)->cert.v, (*c)->cert.l);
+			plog(PLOG_DEBUG, PLOGLOC, NULL, "CRL saved:\n");
+			plogdump(PLOG_DEBUG, PLOGLOC, 0, (*c)->cert.v, (*c)->cert.l);
 			break;
 		case ISAKMP_CERT_X509KE:
 		case ISAKMP_CERT_X509ATTR:
@@ -2230,7 +2106,7 @@
 
 	switch (type) {
 	case ISAKMP_CERT_DNS:
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"CERT payload is unnecessary in DNSSEC\n");
 		/*FALLTHRU*/
 	case ISAKMP_CERT_PKCS7:
@@ -2243,25 +2119,25 @@
 	case ISAKMP_CERT_X509KE:
 	case ISAKMP_CERT_X509ATTR:
 	case ISAKMP_CERT_ARL:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"No supported such CR type %d\n", type);
 		return -1;
 	case ISAKMP_CERT_CRL:
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"Invalid CR type %d\n", type);
 		return -1;
 	}
 
 	*c = save_certbuf(gen);
 	if (!*c) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"Failed to get CR buffer.\n");
 		return -1;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL, "CR saved:\n");
-	plogdump(LLV_DEBUG, (*c)->cert.v, (*c)->cert.l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "CR saved:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, (*c)->cert.v, (*c)->cert.l);
 
 	return 0;
 }
@@ -2273,21 +2149,21 @@
 	cert_t *new;
 
 	if(ntohs(gen->len) <= sizeof(*gen)){
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			 "Len is too small !!.\n");
 		return NULL;
 	}
 
 	new = oakley_newcert();
 	if (!new) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"Failed to get CERT buffer.\n");
 		return NULL;
 	}
 
 	new->pl = vmalloc(ntohs(gen->len) - sizeof(*gen));
 	if (new->pl == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"Failed to copy CERT from packet.\n");
 		oakley_delcert(new);
 		new = NULL;
@@ -2311,7 +2187,7 @@
 
 	new = oakley_newcert();
 	if (!new) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"Failed to get CERT buffer.\n");
 		return NULL;
 	}
@@ -2319,7 +2195,7 @@
         len = i2d_X509(cert, NULL);
 	new->pl = vmalloc(len);
 	if (new->pl == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"Failed to copy CERT from packet.\n");
 		oakley_delcert(new);
 		new = NULL;
@@ -2349,21 +2225,21 @@
 
 	buf = vmalloc(1);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get cr buffer\n");
 		return NULL;
 	}
-	if(iph1->rmconf->certtype == ISAKMP_CERT_NONE) {
-		buf->v[0] = iph1->rmconf->cacerttype;
-		plog(LLV_DEBUG, LOCATION, NULL, "create my CR: NONE, using %s instead\n",
-		s_isakmp_certtype(iph1->rmconf->cacerttype));
+	if(ikev1_certtype(iph1->rmconf) == ISAKMP_CERT_NONE) {
+		buf->v[0] = ikev1_cacerttype(iph1->rmconf);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "create my CR: NONE, using %s instead\n",
+		     s_isakmp_certtype(ikev1_cacerttype(iph1->rmconf)));
 	} else {
-		buf->v[0] = iph1->rmconf->certtype;
-		plog(LLV_DEBUG, LOCATION, NULL, "create my CR: %s\n",
-		s_isakmp_certtype(iph1->rmconf->certtype));
+		buf->v[0] = ikev1_certtype(iph1->rmconf);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "create my CR: %s\n",
+		     s_isakmp_certtype(ikev1_certtype(iph1->rmconf)));
 	}
 	if (buf->l > 1)
-		plogdump(LLV_DEBUG, buf->v, buf->l);
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	return buf;
 }
@@ -2378,12 +2254,12 @@
 	if (iph1->cr_p == NULL)
 		return 0;
 
-	plog(LLV_DEBUG, LOCATION, iph1->remote,
+	plog(PLOG_DEBUG, PLOGLOC, 0,/*iph1->remote,*/
 		"peer transmitted CR: %s\n",
 		s_isakmp_certtype(iph1->cr_p->type));
 
-	if (iph1->cr_p->type != iph1->rmconf->certtype) {
-		plog(LLV_ERROR, LOCATION, iph1->remote,
+	if (iph1->cr_p->type != ikev1_certtype(iph1->rmconf)) {
+		plog(PLOG_PROTOERR, PLOGLOC, 0 /*iph1->remote*/,
 			"such a cert type isn't supported: %d\n",
 			(char)iph1->cr_p->type);
 		return -1;
@@ -2441,14 +2317,14 @@
 	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_PSKEY_R:
 #endif
 		if (iph1->etype != ISAKMP_ETYPE_IDENT) {
-			iph1->authstr = getpskbyname(iph1->id_p);
+			iph1->authstr = ikev1_pre_shared_key(iph1);
 			if (iph1->authstr == NULL) {
-				if (iph1->rmconf->verify_identifier) {
-					plog(LLV_ERROR, LOCATION, iph1->remote,
+				if (ikev1_verify_id(iph1->rmconf) == RCT_BOOL_ON) {
+					plog(PLOG_PROTOERR, PLOGLOC, 0 /*iph1->remote*/,
 						"couldn't find the pskey.\n");
 					goto end;
 				}
-				plog(LLV_NOTIFY, LOCATION, iph1->remote,
+				plog(PLOG_INFO, PLOGLOC, 0 /*iph1->remote*/,
 					"couldn't find the proper pskey, "
 					"try to get one by the peer's address.\n");
 			}
@@ -2462,35 +2338,35 @@
 			 */
 			iph1->authstr = getpskbyaddr(iph1->remote);
 			if (iph1->authstr == NULL) {
-				plog(LLV_ERROR, LOCATION, iph1->remote,
+				plog(PLOG_PROTOERR, PLOGLOC, 0,
 					"couldn't find the pskey for %s.\n",
-					saddrwop2str(iph1->remote));
+				     rcs_sa2str_wop(iph1->remote));
 				goto end;
 			}
 		}
-		plog(LLV_DEBUG, LOCATION, NULL, "the psk found.\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "the psk found.\n");
 		/* should be secret PSK */
-		plog(LLV_DEBUG2, LOCATION, NULL, "psk: ");
-		plogdump(LLV_DEBUG2, iph1->authstr->v, iph1->authstr->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "psk: ");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->authstr->v, iph1->authstr->l);
 
 		len = iph1->nonce->l + iph1->nonce_p->l;
 		buf = vmalloc(len);
 		if (buf == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to get skeyid buffer\n");
 			goto end;
 		}
 		p = buf->v;
 
 		bp = (iph1->side == INITIATOR ? iph1->nonce : iph1->nonce_p);
-		plog(LLV_DEBUG, LOCATION, NULL, "nonce 1: ");
-		plogdump(LLV_DEBUG, bp->v, bp->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "nonce 1: ");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, bp->v, bp->l);
 		memcpy(p, bp->v, bp->l);
 		p += bp->l;
 
 		bp = (iph1->side == INITIATOR ? iph1->nonce_p : iph1->nonce);
-		plog(LLV_DEBUG, LOCATION, NULL, "nonce 2: ");
-		plogdump(LLV_DEBUG, bp->v, bp->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "nonce 2: ");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, bp->v, bp->l);
 		memcpy(p, bp->v, bp->l);
 		p += bp->l;
 
@@ -2517,21 +2393,21 @@
 		len = iph1->nonce->l + iph1->nonce_p->l;
 		buf = vmalloc(len);
 		if (buf == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to get nonce buffer\n");
 			goto end;
 		}
 		p = buf->v;
 
 		bp = (iph1->side == INITIATOR ? iph1->nonce : iph1->nonce_p);
-		plog(LLV_DEBUG, LOCATION, NULL, "nonce1: ");
-		plogdump(LLV_DEBUG, bp->v, bp->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "nonce1: ");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, bp->v, bp->l);
 		memcpy(p, bp->v, bp->l);
 		p += bp->l;
 
 		bp = (iph1->side == INITIATOR ? iph1->nonce_p : iph1->nonce);
-		plog(LLV_DEBUG, LOCATION, NULL, "nonce2: ");
-		plogdump(LLV_DEBUG, bp->v, bp->l);
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "nonce2: ");
+		plogdump(PLOG_DEBUG, PLOGLOC, 0, bp->v, bp->l);
 		memcpy(p, bp->v, bp->l);
 		p += bp->l;
 
@@ -2547,19 +2423,19 @@
 	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_I:
 	case OAKLEY_ATTR_AUTH_METHOD_XAUTH_RSAREV_R:
 #endif
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"not supported authentication method %s\n",
 			s_oakley_attr_method(iph1->approval->authmethod));
 		goto end;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid authentication method %d\n",
 			iph1->approval->authmethod);
 		goto end;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL, "SKEYID computed:\n");
-	plogdump(LLV_DEBUG, iph1->skeyid->v, iph1->skeyid->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "SKEYID computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->skeyid->v, iph1->skeyid->l);
 
 	error = 0;
 
@@ -2586,16 +2462,16 @@
 	int error = -1;
 
 	if (iph1->skeyid == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, "no SKEYID found.\n");
+		plog(PLOG_INTERR, PLOGLOC, NULL, "no SKEYID found.\n");
 		goto end;
 	}
 
 	/* SKEYID D */
 	/* SKEYID_d = prf(SKEYID, g^xy | CKY-I | CKY-R | 0) */
-	len = iph1->dhgxy->l + sizeof(cookie_t) * 2 + 1;
+	len = iph1->dhgxy->l + sizeof(isakmp_cookie_t) * 2 + 1;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get skeyid buffer\n");
 		goto end;
 	}
@@ -2603,10 +2479,10 @@
 
 	memcpy(p, iph1->dhgxy->v, iph1->dhgxy->l);
 	p += iph1->dhgxy->l;
-	memcpy(p, (caddr_t)&iph1->index.i_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
-	memcpy(p, (caddr_t)&iph1->index.r_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
+	memcpy(p, (caddr_t)&iph1->index.i_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
+	memcpy(p, (caddr_t)&iph1->index.r_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
 	*p = 0;
 	iph1->skeyid_d = oakley_prf(iph1->skeyid, buf, iph1);
 	if (iph1->skeyid_d == NULL)
@@ -2615,15 +2491,15 @@
 	vfree(buf);
 	buf = NULL;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "SKEYID_d computed:\n");
-	plogdump(LLV_DEBUG, iph1->skeyid_d->v, iph1->skeyid->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "SKEYID_d computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->skeyid_d->v, iph1->skeyid->l);
 
 	/* SKEYID A */
 	/* SKEYID_a = prf(SKEYID, SKEYID_d | g^xy | CKY-I | CKY-R | 1) */
-	len = iph1->skeyid_d->l + iph1->dhgxy->l + sizeof(cookie_t) * 2 + 1;
+	len = iph1->skeyid_d->l + iph1->dhgxy->l + sizeof(isakmp_cookie_t) * 2 + 1;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get skeyid buffer\n");
 		goto end;
 	}
@@ -2632,10 +2508,10 @@
 	p += iph1->skeyid_d->l;
 	memcpy(p, iph1->dhgxy->v, iph1->dhgxy->l);
 	p += iph1->dhgxy->l;
-	memcpy(p, (caddr_t)&iph1->index.i_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
-	memcpy(p, (caddr_t)&iph1->index.r_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
+	memcpy(p, (caddr_t)&iph1->index.i_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
+	memcpy(p, (caddr_t)&iph1->index.r_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
 	*p = 1;
 	iph1->skeyid_a = oakley_prf(iph1->skeyid, buf, iph1);
 	if (iph1->skeyid_a == NULL)
@@ -2644,15 +2520,15 @@
 	vfree(buf);
 	buf = NULL;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "SKEYID_a computed:\n");
-	plogdump(LLV_DEBUG, iph1->skeyid_a->v, iph1->skeyid_a->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "SKEYID_a computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->skeyid_a->v, iph1->skeyid_a->l);
 
 	/* SKEYID E */
 	/* SKEYID_e = prf(SKEYID, SKEYID_a | g^xy | CKY-I | CKY-R | 2) */
-	len = iph1->skeyid_a->l + iph1->dhgxy->l + sizeof(cookie_t) * 2 + 1;
+	len = iph1->skeyid_a->l + iph1->dhgxy->l + sizeof(isakmp_cookie_t) * 2 + 1;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get skeyid buffer\n");
 		goto end;
 	}
@@ -2661,10 +2537,10 @@
 	p += iph1->skeyid_a->l;
 	memcpy(p, iph1->dhgxy->v, iph1->dhgxy->l);
 	p += iph1->dhgxy->l;
-	memcpy(p, (caddr_t)&iph1->index.i_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
-	memcpy(p, (caddr_t)&iph1->index.r_ck, sizeof(cookie_t));
-	p += sizeof(cookie_t);
+	memcpy(p, (caddr_t)&iph1->index.i_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
+	memcpy(p, (caddr_t)&iph1->index.r_ck, sizeof(isakmp_cookie_t));
+	p += sizeof(isakmp_cookie_t);
 	*p = 2;
 	iph1->skeyid_e = oakley_prf(iph1->skeyid, buf, iph1);
 	if (iph1->skeyid_e == NULL)
@@ -2673,8 +2549,8 @@
 	vfree(buf);
 	buf = NULL;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "SKEYID_e computed:\n");
-	plogdump(LLV_DEBUG, iph1->skeyid_e->v, iph1->skeyid_e->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "SKEYID_e computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->skeyid_e->v, iph1->skeyid_e->l);
 
 	error = 0;
 
@@ -2699,7 +2575,7 @@
 	keylen = alg_oakley_encdef_keylen(iph1->approval->enctype,
 					iph1->approval->encklen);
 	if (keylen == -1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid encryption algoritym %d, "
 			"or invalid key length %d.\n",
 			iph1->approval->enctype,
@@ -2708,7 +2584,7 @@
 	}
 	iph1->key = vmalloc(keylen >> 3);
 	if (iph1->key == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get key buffer\n");
 		goto end;
 	}
@@ -2716,7 +2592,7 @@
 	/* set prf length */
 	prflen = alg_oakley_hashdef_hashlen(iph1->approval->hashtype);
 	if (prflen == -1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid hash type %d.\n", iph1->approval->hashtype);
 		goto end;
 	}
@@ -2742,13 +2618,13 @@
 		 *	K2 = prf(SKEYID_e, K1)
 		 *	K3 = prf(SKEYID_e, K2)
 		 */
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"len(SKEYID_e) < len(Ka) (%zu < %zu), "
 			"generating long key (Ka = K1 | K2 | ...)\n",
 			iph1->skeyid_e->l, iph1->key->l);
 
 		if ((buf = vmalloc(prflen >> 3)) == 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to get key buffer\n");
 			goto end;
 		}
@@ -2767,11 +2643,11 @@
 				vfree(buf);
 				goto end;
 			}
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"compute intermediate encryption key K%d\n",
 				subkey);
-			plogdump(LLV_DEBUG, buf->v, buf->l);
-			plogdump(LLV_DEBUG, res->v, res->l);
+			plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
+			plogdump(PLOG_DEBUG, PLOGLOC, 0, res->v, res->l);
 
 			cplen = (res->l < ep - p) ? res->l : ep - p;
 			memcpy(p, res->v, cplen);
@@ -2779,7 +2655,7 @@
 
 			buf->l = prflen >> 3;	/* to cancel K1 speciality */
 			if (res->l != buf->l) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"internal error: res->l=%zu buf->l=%zu\n",
 					res->l, buf->l);
 				vfree(res);
@@ -2803,20 +2679,20 @@
 	/* weakkey check */
 	if (iph1->approval->enctype > ARRAYLEN(oakley_encdef)
 	 || oakley_encdef[iph1->approval->enctype].weakkey == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"encryption algoritym %d isn't supported.\n",
 			iph1->approval->enctype);
 		goto end;
 	}
 	if ((oakley_encdef[iph1->approval->enctype].weakkey)(iph1->key)) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"weakkey was generated.\n");
 		goto end;
 	}
 #endif
 
-	plog(LLV_DEBUG, LOCATION, NULL, "final encryption key computed:\n");
-	plogdump(LLV_DEBUG, iph1->key->v, iph1->key->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "final encryption key computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->key->v, iph1->key->l);
 
 	error = 0;
 
@@ -2832,7 +2708,7 @@
 
 	new = racoon_calloc(1, sizeof(*new));
 	if (new == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get cert's buffer\n");
 		return NULL;
 	}
@@ -2872,7 +2748,7 @@
 	len = iph1->dhpub->l + iph1->dhpub_p->l;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get iv buffer\n");
 		return -1;
 	}
@@ -2890,7 +2766,7 @@
 	/* allocate IVm */
 	newivm = racoon_calloc(1, sizeof(struct isakmp_ivm));
 	if (newivm == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get iv buffer\n");
 		vfree(buf);
 		return -1;
@@ -2907,7 +2783,7 @@
 	/* adjust length of iv */
 	newivm->iv->l = alg_oakley_encdef_blocklen(iph1->approval->enctype);
 	if (newivm->iv->l == -1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid encryption algoriym %d.\n",
 			iph1->approval->enctype);
 		vfree(buf);
@@ -2917,7 +2793,7 @@
 
 	/* create buffer to save iv */
 	if ((newivm->ive = vdup(newivm->iv)) == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"vdup (%s)\n", strerror(errno));
 		vfree(buf);
 		oakley_delivm(newivm);
@@ -2926,8 +2802,8 @@
 
 	vfree(buf);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "IV computed:\n");
-	plogdump(LLV_DEBUG, newivm->iv->v, newivm->iv->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "IV computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, newivm->iv->v, newivm->iv->l);
 
 	iph1->ivm = newivm;
 
@@ -2958,7 +2834,7 @@
 	len = iph1->ivm->iv->l + sizeof(msgid_t);
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get iv buffer\n");
 		goto end;
 	}
@@ -2970,14 +2846,14 @@
 
 	memcpy(p, &msgid, sizeof(msgid));
 
-	plog(LLV_DEBUG, LOCATION, NULL, "compute IV for phase2\n");
-	plog(LLV_DEBUG, LOCATION, NULL, "phase1 last IV:\n");
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "compute IV for phase2\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "phase1 last IV:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	/* allocate IVm */
 	newivm = racoon_calloc(1, sizeof(struct isakmp_ivm));
 	if (newivm == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get iv buffer\n");
 		goto end;
 	}
@@ -2989,7 +2865,7 @@
 	/* adjust length of iv */
 	newivm->iv->l = alg_oakley_encdef_blocklen(iph1->approval->enctype);
 	if (newivm->iv->l == -1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid encryption algoriym %d.\n",
 			iph1->approval->enctype);
 		goto end;
@@ -2997,14 +2873,14 @@
 
 	/* create buffer to save new iv */
 	if ((newivm->ive = vdup(newivm->iv)) == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, "vdup (%s)\n", strerror(errno));
+		plog(PLOG_INTERR, PLOGLOC, NULL, "vdup (%s)\n", strerror(errno));
 		goto end;
 	}
 
 	error = 0;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "phase2 IV computed:\n");
-	plogdump(LLV_DEBUG, newivm->iv->v, newivm->iv->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "phase2 IV computed:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, newivm->iv->v, newivm->iv->l);
 
 end:
 	if (error && newivm != NULL){
@@ -3028,7 +2904,7 @@
 	if (ivm->ive != NULL)
 		vfree(ivm->ive);
 	racoon_free(ivm);
-	plog(LLV_DEBUG, LOCATION, NULL, "IV freed\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "IV freed\n");
 
 	return;
 }
@@ -3049,11 +2925,11 @@
 	int blen;
 	int error = -1;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "begin decryption.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "begin decryption.\n");
 
 	blen = alg_oakley_encdef_blocklen(iph1->approval->enctype);
 	if (blen == -1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid encryption algoriym %d.\n",
 			iph1->approval->enctype);
 		goto end;
@@ -3063,9 +2939,9 @@
 	memset(ivep->v, 0, ivep->l);
 	memcpy(ivep->v, (caddr_t)&msg->v[msg->l - blen], blen);
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"IV was saved for next processing:\n");
-	plogdump(LLV_DEBUG, ivep->v, ivep->l);
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, ivep->v, ivep->l);
 
 	pl = msg->v + sizeof(struct isakmp);
 
@@ -3074,7 +2950,7 @@
 	/* create buffer */
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to decrypt.\n");
 		goto end;
 	}
@@ -3084,52 +2960,56 @@
 	new = alg_oakley_encdef_decrypt(iph1->approval->enctype,
 					buf, iph1->key, ivdp);
 	if (new == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"decryption %d failed.\n", iph1->approval->enctype);
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "with key:\n");
-	plogdump(LLV_DEBUG, iph1->key->v, iph1->key->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "with key:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->key->v, iph1->key->l);
 
 	vfree(buf);
 	buf = NULL;
 	if (new == NULL)
 		goto end;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "decrypted payload by IV:\n");
-	plogdump(LLV_DEBUG, ivdp->v, ivdp->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "decrypted payload by IV:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, ivdp->v, ivdp->l);
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"decrypted payload, but not trimed.\n");
-	plogdump(LLV_DEBUG, new->v, new->l);
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, new->v, new->l);
 
 	/* get padding length */
+#if 0
 	if (lcconf->pad_excltail)
 		padlen = new->v[new->l - 1] + 1;
 	else
+#endif
 		padlen = new->v[new->l - 1];
-	plog(LLV_DEBUG, LOCATION, NULL, "padding len=%u\n", padlen);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "padding len=%u\n", padlen);
 
 	/* trim padding */
+#if 0
 	if (lcconf->pad_strict) {
 		if (padlen > new->l) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalied padding len=%u, buflen=%zu.\n",
 				padlen, new->l);
-			plogdump(LLV_ERROR, new->v, new->l);
+			plogdump(PLOG_PROTOERR, PLOGLOC, 0, new->v, new->l);
 			goto end;
 		}
 		new->l -= padlen;
-		plog(LLV_DEBUG, LOCATION, NULL, "trimmed padding\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "trimmed padding\n");
 	} else {
-		plog(LLV_DEBUG, LOCATION, NULL, "skip to trim padding.\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "skip to trim padding.\n");
 	}
+#endif
 
 	/* create new buffer */
 	len = sizeof(struct isakmp) + new->l;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to decrypt.\n");
 		goto end;
 	}
@@ -3137,8 +3017,8 @@
 	memcpy(buf->v + sizeof(struct isakmp), new->v, new->l);
 	((struct isakmp *)buf->v)->len = htonl(buf->l);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "decrypted.\n");
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "decrypted.\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 #ifdef HAVE_PRINT_ISAKMP_C
 	isakmp_printpacket(buf, iph1->remote, iph1->local, 1);
@@ -3172,12 +3052,12 @@
 	int blen;
 	int error = -1;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "begin encryption.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "begin encryption.\n");
 
 	/* set cbc block length */
 	blen = alg_oakley_encdef_blocklen(iph1->approval->enctype);
 	if (blen == -1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"invalid encryption algoriym %d.\n",
 			iph1->approval->enctype);
 		goto end;
@@ -3188,64 +3068,69 @@
 
 	/* add padding */
 	padlen = oakley_padlen(len, blen);
-	plog(LLV_DEBUG, LOCATION, NULL, "pad length = %u\n", padlen);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "pad length = %u\n", padlen);
 
 	/* create buffer */
 	buf = vmalloc(len + padlen);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to encrypt.\n");
 		goto end;
 	}
         if (padlen) {
-                int i;
+		int i;
 		char *p = &buf->v[len];
-		if (lcconf->pad_random) {
+		if (ikev1_random_pad_content(iph1->rmconf) == RCT_BOOL_ON) {
 			for (i = 0; i < padlen; i++)
-				*p++ = eay_random() & 0xff;
+				*p++ = eay_random_uint32() & 0xff;
+		} else {
+			for (i = 0; i < padlen; ++i)
+				p[i] = 0;
 		}
         }
         memcpy(buf->v, pl, len);
 
 	/* make pad into tail */
+#ifdef notyet
 	if (lcconf->pad_excltail)
 		buf->v[len + padlen - 1] = padlen - 1;
 	else
+#endif
 		buf->v[len + padlen - 1] = padlen;
 
-	plogdump(LLV_DEBUG, buf->v, buf->l);
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, buf->v, buf->l);
 
 	/* do encrypt */
 	new = alg_oakley_encdef_encrypt(iph1->approval->enctype,
 					buf, iph1->key, ivep);
 	if (new == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"encryption %d failed.\n", iph1->approval->enctype);
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "with key:\n");
-	plogdump(LLV_DEBUG, iph1->key->v, iph1->key->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "with key:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, iph1->key->v, iph1->key->l);
 
 	vfree(buf);
 	buf = NULL;
 	if (new == NULL)
 		goto end;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "encrypted payload by IV:\n");
-	plogdump(LLV_DEBUG, ivep->v, ivep->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "encrypted payload by IV:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, ivep->v, ivep->l);
 
 	/* save IV for next */
 	memset(ivp->v, 0, ivp->l);
 	memcpy(ivp->v, (caddr_t)&new->v[new->l - blen], blen);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "save IV for next:\n");
-	plogdump(LLV_DEBUG, ivp->v, ivp->l);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "save IV for next:\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, ivp->v, ivp->l);
 
 	/* create new buffer */
 	len = sizeof(struct isakmp) + new->l;
 	buf = vmalloc(len);
 	if (buf == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get buffer to encrypt.\n");
 		goto end;
 	}
@@ -3255,7 +3140,7 @@
 
 	error = 0;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "encrypted.\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "encrypted.\n");
 
 end:
 	if (error && buf != NULL) {
@@ -3277,9 +3162,11 @@
 
 	padlen = base - len % base;
 
+#ifdef notyet
 	if (lcconf->pad_randomlen)
 		padlen += ((eay_random() % (lcconf->pad_maxsize + 1) + 1) *
 		    base);
+#endif
 
 	return padlen;
 }
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: oakley.h
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/pfkey.c ./pfkey.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/pfkey.c	Mon Oct  3 23:49:42 2005
+++ ./pfkey.c	Thu Feb  2 17:05:48 2006
@@ -70,214 +70,74 @@
 #endif
 #include <fcntl.h>
 
-#include "libpfkey.h"
+/* #include "libpfkey.h" */
 
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 #include "sockmisc.h"
 #include "debug.h"
 
-#include "schedule.h"
-#include "localconf.h"
+#include "racoon.h"
+#include "isakmp_impl.h"
+#include "ike_conf.h"
+#include "crypto_impl.h"
+
+/* #include "schedule.h" */
+/* #include "localconf.h" */
 #include "remoteconf.h"
-#include "handler.h"
-#include "proposal.h"
-#include "isakmp_var.h"
 #include "isakmp.h"
+#include "isakmp_var.h"
+#include "proposal.h"
+#include "ike_pfkey.h"
+#include "oakley.h"
+#include "handler.h"
 #include "isakmp_inf.h"
 #include "ipsec_doi.h"
-#include "oakley.h"
-#include "pfkey.h"
-#include "policy.h"
+/* #include "pfkey.h" */
+/* #include "policy.h" */
 #include "algorithm.h"
 #include "sainfo.h"
-#include "admin.h"
-#include "privsep.h"
+/* #include "admin.h" */
+/* #include "privsep.h" */
 #include "strnames.h"
-#include "backupsa.h"
+/* #include "backupsa.h" */
 #include "gcmalloc.h"
-#include "nattraversal.h"
+/* #include "nattraversal.h" */
 #include "crypto_openssl.h"
-#include "grabmyaddr.h"
+/* #include "grabmyaddr.h" */
 
 #if defined(SADB_X_EALG_RIJNDAELCBC) && !defined(SADB_X_EALG_AESCBC)
 #define SADB_X_EALG_AESCBC  SADB_X_EALG_RIJNDAELCBC
 #endif
 
 /* prototype */
-static u_int ipsecdoi2pfkey_aalg __P((u_int));
-static u_int ipsecdoi2pfkey_ealg __P((u_int));
-static u_int ipsecdoi2pfkey_calg __P((u_int));
-static u_int ipsecdoi2pfkey_alg __P((u_int, u_int));
+static int ipsecdoi2rc_aalg __P((u_int));
+static int ipsecdoi2rc_ealg __P((u_int));
+static int ipsecdoi2rc_calg __P((u_int));
+static int ipsecdoi2rc_alg __P((u_int, u_int));
 static u_int keylen_aalg __P((u_int));
 static u_int keylen_ealg __P((u_int, int));
 
-static int pk_recvgetspi __P((caddr_t *));
-static int pk_recvupdate __P((caddr_t *));
-static int pk_recvadd __P((caddr_t *));
-static int pk_recvdelete __P((caddr_t *));
-static int pk_recvacquire __P((caddr_t *));
-static int pk_recvexpire __P((caddr_t *));
-static int pk_recvflush __P((caddr_t *));
-static int getsadbpolicy __P((caddr_t *, int *, int, struct ph2handle *));
-static int pk_recvspdupdate __P((caddr_t *));
-static int pk_recvspdadd __P((caddr_t *));
-static int pk_recvspddelete __P((caddr_t *));
-static int pk_recvspdexpire __P((caddr_t *));
-static int pk_recvspdget __P((caddr_t *));
-static int pk_recvspddump __P((caddr_t *));
-static int pk_recvspdflush __P((caddr_t *));
-static struct sadb_msg *pk_recv __P((int, int *));
-
-static int (*pkrecvf[]) __P((caddr_t *)) = {
-NULL,
-pk_recvgetspi,
-pk_recvupdate,
-pk_recvadd,
-pk_recvdelete,
-NULL,	/* SADB_GET */
-pk_recvacquire,
-NULL,	/* SABD_REGISTER */
-pk_recvexpire,
-pk_recvflush,
-NULL,	/* SADB_DUMP */
-NULL,	/* SADB_X_PROMISC */
-NULL,	/* SADB_X_PCHANGE */
-pk_recvspdupdate,
-pk_recvspdadd,
-pk_recvspddelete,
-pk_recvspdget,
-NULL,	/* SADB_X_SPDACQUIRE */
-pk_recvspddump,
-pk_recvspdflush,
-NULL,	/* SADB_X_SPDSETIDX */
-pk_recvspdexpire,
-NULL,	/* SADB_X_SPDDELETE2 */
-NULL,	/* SADB_X_NAT_T_NEW_MAPPING */
-NULL,	/* SADB_X_MIGRATE */
-#if (SADB_MAX > 24)
-#error "SADB extra message?"
-#endif
-};
-
-static int addnewsp __P((caddr_t *));
-
-/* cope with old kame headers - ugly */
-#ifndef SADB_X_AALG_MD5
-#define SADB_X_AALG_MD5		SADB_AALG_MD5	
-#endif
-#ifndef SADB_X_AALG_SHA
-#define SADB_X_AALG_SHA		SADB_AALG_SHA
-#endif
-#ifndef SADB_X_AALG_NULL
-#define SADB_X_AALG_NULL	SADB_AALG_NULL
-#endif
-
-#ifndef SADB_X_EALG_BLOWFISHCBC
-#define SADB_X_EALG_BLOWFISHCBC	SADB_EALG_BLOWFISHCBC
-#endif
-#ifndef SADB_X_EALG_CAST128CBC
-#define SADB_X_EALG_CAST128CBC	SADB_EALG_CAST128CBC
-#endif
-#ifndef SADB_X_EALG_RC5CBC
-#ifdef SADB_EALG_RC5CBC
-#define SADB_X_EALG_RC5CBC	SADB_EALG_RC5CBC
-#endif
-#endif
-
-/*
- * PF_KEY packet handler
- *	0: success
- *	-1: fail
- */
-int
-pfkey_handler()
-{
-	struct sadb_msg *msg;
-	int len;
-	caddr_t mhp[SADB_EXT_MAX + 1];
-	int error = -1;
-
-	/* receive pfkey message. */
-	len = 0;
-	msg = (struct sadb_msg *)pk_recv(lcconf->sock_pfkey, &len);
-	if (msg == NULL) {
-		if (len < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"failed to recv from pfkey (%s)\n",
-				strerror(errno));
-			goto end;
-		} else {
-			/* short message - msg not ready */
-			return 0;
-		}
-	}
-
-	plog(LLV_DEBUG, LOCATION, NULL, "get pfkey %s message\n",
-		s_pfkey_type(msg->sadb_msg_type));
-	plogdump(LLV_DEBUG2, msg, msg->sadb_msg_len << 3);
-
-	/* validity check */
-	if (msg->sadb_msg_errno) {
-		int pri;
-
-		/* when SPD is empty, treat the state as no error. */
-		if (msg->sadb_msg_type == SADB_X_SPDDUMP &&
-		    msg->sadb_msg_errno == ENOENT)
-			pri = LLV_DEBUG;
-		else
-			pri = LLV_ERROR;
-
-		plog(pri, LOCATION, NULL,
-			"pfkey %s failed: %s\n",
-			s_pfkey_type(msg->sadb_msg_type),
-			strerror(msg->sadb_msg_errno));
-
-		goto end;
-	}
-
-	/* check pfkey message. */
-	if (pfkey_align(msg, mhp)) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"libipsec failed pfkey align (%s)\n",
-			ipsec_strerror());
-		goto end;
-	}
-	if (pfkey_check(mhp)) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"libipsec failed pfkey check (%s)\n",
-			ipsec_strerror());
-		goto end;
-	}
-	msg = (struct sadb_msg *)mhp[0];
-
-	/* safety check */
-	if (msg->sadb_msg_type >= ARRAYLEN(pkrecvf)) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"unknown PF_KEY message type=%u\n",
-			msg->sadb_msg_type);
-		goto end;
-	}
-
-	if (pkrecvf[msg->sadb_msg_type] == NULL) {
-		plog(LLV_INFO, LOCATION, NULL,
-			"unsupported PF_KEY message %s\n",
-			s_pfkey_type(msg->sadb_msg_type));
-		goto end;
-	}
-
-	if ((pkrecvf[msg->sadb_msg_type])(mhp) < 0)
-		goto end;
+/* static int addnewsp __P((caddr_t *));  */
 
-	error = 0;
-end:
-	if (msg)
-		racoon_free(msg);
-	return(error);
-}
+/* callback methods */
+static int ikev1_getspi_response(struct sadb_request *,
+				 struct sockaddr *, struct sockaddr *, 
+				 u_int, u_int, u_int32_t);
+static int ikev1_update_response(struct sadb_request *, 
+				 struct sockaddr *, struct sockaddr *,
+				 u_int, u_int, u_int32_t);
+static int ikev1_expired(struct sadb_request *, struct rcpfk_msg *);
+
+struct sadb_response_method ikev1_sadb_callback = {
+	ikev1_getspi_response,
+	ikev1_update_response,
+	ikev1_expired
+};
 
+#ifdef notyet
 /*
  * dump SADB
  */
@@ -293,15 +153,15 @@
 	int len;
 
 	if ((s = privsep_pfkey_open()) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"libipsec failed pfkey open: %s\n",
 			ipsec_strerror());
 		return NULL;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_dump\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_dump\n");
 	if (pfkey_send_dump(s, satype) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"libipsec failed dump: %s\n", ipsec_strerror());
 		goto fail;
 	}
@@ -324,7 +184,7 @@
 		bl = buf ? buf->l : 0;
 		buf = vrealloc(buf, bl + ml);
 		if (buf == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to reallocate buffer to dump.\n");
 			goto fail;
 		}
@@ -346,6 +206,7 @@
 		privsep_pfkey_close(s);
 	return buf;
 }
+#endif
 
 #ifdef ENABLE_ADMINPORT
 /*
@@ -361,9 +222,9 @@
 	if ((satype = admin2pfkey_proto(proto)) < 0)
 		return;
 
-	plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_flush\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_flush\n");
 	if (pfkey_send_flush(lcconf->sock_pfkey, satype) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"libipsec failed send flush (%s)\n", ipsec_strerror());
 		return;
 	}
@@ -372,233 +233,148 @@
 }
 #endif
 
-/*
- * These are the SATYPEs that we manage.  We register to get
- * PF_KEY messages related to these SATYPEs, and we also use
- * this list to determine which SATYPEs to delete SAs for when
- * we receive an INITIAL-CONTACT.
- */
-const struct pfkey_satype pfkey_satypes[] = {
-	{ SADB_SATYPE_AH,	"AH" },
-	{ SADB_SATYPE_ESP,	"ESP" },
-	{ SADB_X_SATYPE_IPCOMP,	"IPCOMP" },
-};
-const int pfkey_nsatypes =
-    sizeof(pfkey_satypes) / sizeof(pfkey_satypes[0]);
-
-/*
- * PF_KEY initialization
- */
-int
-pfkey_init()
-{
-	int i, reg_fail;
-
-	if ((lcconf->sock_pfkey = privsep_pfkey_open()) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"libipsec failed pfkey open (%s)\n", ipsec_strerror());
-		return -1;
-	}
-	if (fcntl(lcconf->sock_pfkey, F_SETFL, O_NONBLOCK) == -1)
-		plog(LLV_WARNING, LOCATION, NULL,
-		    "failed to set the pfkey socket to NONBLOCK\n");
-
-	for (i = 0, reg_fail = 0; i < pfkey_nsatypes; i++) {
-		plog(LLV_DEBUG, LOCATION, NULL,
-		    "call pfkey_send_register for %s\n",
-		    pfkey_satypes[i].ps_name);
-		if (pfkey_send_register(lcconf->sock_pfkey,
-					pfkey_satypes[i].ps_satype) < 0 ||
-		    pfkey_recv_register(lcconf->sock_pfkey) < 0) {
-			plog(LLV_WARNING, LOCATION, NULL,
-			    "failed to register %s (%s)\n",
-			    pfkey_satypes[i].ps_name,
-			    ipsec_strerror());
-			reg_fail++;
-		}
-	}
-
-	if (reg_fail == pfkey_nsatypes) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"failed to regist any protocol.\n");
-		pfkey_close(lcconf->sock_pfkey);
-		return -1;
-	}
-
-	initsp();
-
-	if (pfkey_send_spddump(lcconf->sock_pfkey) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"libipsec sending spddump failed: %s\n",
-			ipsec_strerror());
-		pfkey_close(lcconf->sock_pfkey);
-		return -1;
-	}
-#if 0
-	if (pfkey_promisc_toggle(1) < 0) {
-		pfkey_close(lcconf->sock_pfkey);
-		return -1;
-	}
-#endif
-	return 0;
-}
-
 /* %%% for conversion */
 /* IPSECDOI_ATTR_AUTH -> SADB_AALG */
-static u_int
-ipsecdoi2pfkey_aalg(hashtype)
+static int
+ipsecdoi2rc_aalg(hashtype)
 	u_int hashtype;
 {
 	switch (hashtype) {
 	case IPSECDOI_ATTR_AUTH_HMAC_MD5:
-		return SADB_AALG_MD5HMAC;
+		return RCT_ALG_HMAC_MD5;
 	case IPSECDOI_ATTR_AUTH_HMAC_SHA1:
-		return SADB_AALG_SHA1HMAC;
+		return RCT_ALG_HMAC_SHA1;
 	case IPSECDOI_ATTR_AUTH_HMAC_SHA2_256:
-#if (defined SADB_X_AALG_SHA2_256) && !defined(SADB_X_AALG_SHA2_256HMAC)
-		return SADB_X_AALG_SHA2_256;
-#else
-		return SADB_X_AALG_SHA2_256HMAC;
-#endif
+		return RCT_ALG_HMAC_SHA2_256;
 	case IPSECDOI_ATTR_AUTH_HMAC_SHA2_384:
-#if (defined SADB_X_AALG_SHA2_384) && !defined(SADB_X_AALG_SHA2_384HMAC)
-		return SADB_X_AALG_SHA2_384;
-#else
-		return SADB_X_AALG_SHA2_384HMAC;
-#endif
+		return RCT_ALG_HMAC_SHA2_384;
 	case IPSECDOI_ATTR_AUTH_HMAC_SHA2_512:
-#if (defined SADB_X_AALG_SHA2_512) && !defined(SADB_X_AALG_SHA2_512HMAC)
-		return SADB_X_AALG_SHA2_512;
-#else
-		return SADB_X_AALG_SHA2_512HMAC;
-#endif
+		return RCT_ALG_HMAC_SHA2_512;
 	case IPSECDOI_ATTR_AUTH_KPDK:		/* need special care */
-		return SADB_AALG_NONE;
+		return RCT_ALG_KPDK_MD5;
 
 	/* not supported */
 	case IPSECDOI_ATTR_AUTH_DES_MAC:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"Not supported hash type: %u\n", hashtype);
-		return ~0;
+		return -1;
 
 	case 0: /* reserved */
-	default:
-		return SADB_AALG_NONE;
+		return RCT_ALG_NON_AUTH;
 
-		plog(LLV_ERROR, LOCATION, NULL,
-			"Invalid hash type: %u\n", hashtype);
-		return ~0;
+	default:
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "Invalid hash type: %u\n", hashtype);
+		return -1;
 	}
 	/*NOTREACHED*/
 }
 
 /* IPSECDOI_ESP -> SADB_EALG */
-static u_int
-ipsecdoi2pfkey_ealg(t_id)
+static int
+ipsecdoi2rc_ealg(t_id)
 	u_int t_id;
 {
 	switch (t_id) {
+#ifdef notyet
 	case IPSECDOI_ESP_DES_IV64:		/* sa_flags |= SADB_X_EXT_OLD */
-		return SADB_EALG_DESCBC;
+		return RCT_ALG_DES_CBC_IV64;
+#endif
 	case IPSECDOI_ESP_DES:
-		return SADB_EALG_DESCBC;
+		return RCT_ALG_DES_CBC;
 	case IPSECDOI_ESP_3DES:
-		return SADB_EALG_3DESCBC;
-#ifdef SADB_X_EALG_RC5CBC
+		return RCT_ALG_DES3_CBC;
 	case IPSECDOI_ESP_RC5:
-		return SADB_X_EALG_RC5CBC;
-#endif
+		return RCT_ALG_RC5_CBC;
 	case IPSECDOI_ESP_CAST:
-		return SADB_X_EALG_CAST128CBC;
+		return RCT_ALG_CAST128_CBC;
 	case IPSECDOI_ESP_BLOWFISH:
-		return SADB_X_EALG_BLOWFISHCBC;
+		return RCT_ALG_BLOWFISH_CBC;
+#ifdef notyet
 	case IPSECDOI_ESP_DES_IV32:	/* flags |= (SADB_X_EXT_OLD|
 							SADB_X_EXT_IV4B)*/
 		return SADB_EALG_DESCBC;
-	case IPSECDOI_ESP_NULL:
-		return SADB_EALG_NULL;
-#ifdef SADB_X_EALG_AESCBC
-	case IPSECDOI_ESP_AES:
-		return SADB_X_EALG_AESCBC;
 #endif
-#ifdef SADB_X_EALG_TWOFISHCBC
+	case IPSECDOI_ESP_NULL:
+		return RCT_ALG_NULL_ENC;
+	case IPSECDOI_ESP_AES:	/* need keylen */
+		return RCT_ALG_AES256_CBC;
 	case IPSECDOI_ESP_TWOFISH:
-		return SADB_X_EALG_TWOFISHCBC;
-#endif
+		return RCT_ALG_TWOFISH_CBC;
 
 	/* not supported */
 	case IPSECDOI_ESP_3IDEA:
 	case IPSECDOI_ESP_IDEA:
 	case IPSECDOI_ESP_RC4:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"Not supported transform: %u\n", t_id);
-		return ~0;
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "Not supported transform: %u\n", t_id);
+		return -1;
 
 	case 0: /* reserved */
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"Invalid transform id: %u\n", t_id);
-		return ~0;
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "Invalid transform id: %u\n", t_id);
+		return -1;
 	}
 	/*NOTREACHED*/
 }
 
 /* IPCOMP -> SADB_CALG */
-static u_int
-ipsecdoi2pfkey_calg(t_id)
+static int
+ipsecdoi2rc_calg(t_id)
 	u_int t_id;
 {
 	switch (t_id) {
 	case IPSECDOI_IPCOMP_OUI:
-		return SADB_X_CALG_OUI;
+		return RCT_ALG_OUI;
 	case IPSECDOI_IPCOMP_DEFLATE:
-		return SADB_X_CALG_DEFLATE;
+		return RCT_ALG_DEFLATE;
 	case IPSECDOI_IPCOMP_LZS:
-		return SADB_X_CALG_LZS;
+		return RCT_ALG_LZS;
 
 	case 0: /* reserved */
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, 0,
 			"Invalid transform id: %u\n", t_id);
-		return ~0;
+		return -1;
 	}
 	/*NOTREACHED*/
 }
 
 /* IPSECDOI_PROTO -> SADB_SATYPE */
-u_int
-ipsecdoi2pfkey_proto(proto)
+static int
+ipsecdoi2rc_proto(proto)
 	u_int proto;
 {
 	switch (proto) {
 	case IPSECDOI_PROTO_IPSEC_AH:
-		return SADB_SATYPE_AH;
+		return RCT_SATYPE_AH;
 	case IPSECDOI_PROTO_IPSEC_ESP:
-		return SADB_SATYPE_ESP;
+		return RCT_SATYPE_ESP;
 	case IPSECDOI_PROTO_IPCOMP:
-		return SADB_X_SATYPE_IPCOMP;
+		return RCT_SATYPE_IPCOMP;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"Invalid ipsec_doi proto: %u\n", proto);
-		return ~0;
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "Invalid ipsec_doi proto: %u\n", proto);
+		return -1;
 	}
 	/*NOTREACHED*/
 }
 
-static u_int
-ipsecdoi2pfkey_alg(algclass, type)
+static int
+ipsecdoi2rc_alg(algclass, type)
 	u_int algclass, type;
 {
 	switch (algclass) {
 	case IPSECDOI_ATTR_AUTH:
-		return ipsecdoi2pfkey_aalg(type);
+		return ipsecdoi2rc_aalg(type);
 	case IPSECDOI_PROTO_IPSEC_ESP:
-		return ipsecdoi2pfkey_ealg(type);
+		return ipsecdoi2rc_ealg(type);
 	case IPSECDOI_PROTO_IPCOMP:
-		return ipsecdoi2pfkey_calg(type);
+		return ipsecdoi2rc_calg(type);
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"Invalid ipsec_doi algclass: %u\n", algclass);
 		return ~0;
 	}
@@ -606,29 +382,29 @@
 }
 
 /* SADB_SATYPE -> IPSECDOI_PROTO */
-u_int
-pfkey2ipsecdoi_proto(satype)
+static u_int
+rc2ipsecdoi_proto(satype)
 	u_int satype;
 {
 	switch (satype) {
-	case SADB_SATYPE_AH:
+	case RCT_SATYPE_AH:
 		return IPSECDOI_PROTO_IPSEC_AH;
-	case SADB_SATYPE_ESP:
+	case RCT_SATYPE_ESP:
 		return IPSECDOI_PROTO_IPSEC_ESP;
-	case SADB_X_SATYPE_IPCOMP:
+	case RCT_SATYPE_IPCOMP:
 		return IPSECDOI_PROTO_IPCOMP;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
-			"Invalid pfkey proto: %u\n", satype);
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "Invalid satype %u\n", satype);
 		return ~0;
 	}
 	/*NOTREACHED*/
 }
 
 /* IPSECDOI_ATTR_ENC_MODE -> IPSEC_MODE */
-u_int
-ipsecdoi2pfkey_mode(mode)
+int
+ipsecdoi2rc_mode(mode)
 	u_int mode;
 {
 	switch (mode) {
@@ -637,34 +413,32 @@
 	case IPSECDOI_ATTR_ENC_MODE_UDPTUNNEL_RFC:
 	case IPSECDOI_ATTR_ENC_MODE_UDPTUNNEL_DRAFT:
 #endif
-		return IPSEC_MODE_TUNNEL;
+		return RCT_IPSM_TUNNEL;
 	case IPSECDOI_ATTR_ENC_MODE_TRNS:
 #ifdef ENABLE_NATT
 	case IPSECDOI_ATTR_ENC_MODE_UDPTRNS_RFC:
 	case IPSECDOI_ATTR_ENC_MODE_UDPTRNS_DRAFT:
 #endif
-		return IPSEC_MODE_TRANSPORT;
+		return RCT_IPSM_TRANSPORT;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL, "Invalid mode type: %u\n", mode);
-		return ~0;
+		plog(PLOG_INTERR, PLOGLOC, NULL, "Invalid mode type: %u\n", mode);
+		return -1;
 	}
 	/*NOTREACHED*/
 }
 
 /* IPSECDOI_ATTR_ENC_MODE -> IPSEC_MODE */
 u_int
-pfkey2ipsecdoi_mode(mode)
-	u_int mode;
+rc2ipsecdoi_mode(mode)
+	int mode;
 {
 	switch (mode) {
-	case IPSEC_MODE_TUNNEL:
+	case RCT_IPSM_TUNNEL:
 		return IPSECDOI_ATTR_ENC_MODE_TUNNEL;
-	case IPSEC_MODE_TRANSPORT:
+	case RCT_IPSM_TRANSPORT:
 		return IPSECDOI_ATTR_ENC_MODE_TRNS;
-	case IPSEC_MODE_ANY:
-		return IPSECDOI_ATTR_ENC_MODE_ANY;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL, "Invalid mode type: %u\n", mode);
+		plog(PLOG_INTERR, PLOGLOC, NULL, "Invalid mode type: %u\n", mode);
 		return ~0;
 	}
 	/*NOTREACHED*/
@@ -682,7 +456,7 @@
 
 	res = alg_ipsec_hmacdef_hashlen(hashtype);
 	if (res == -1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"invalid hmac algorithm %u.\n", hashtype);
 		return ~0;
 	}
@@ -699,15 +473,15 @@
 
 	res = alg_ipsec_encdef_keylen(enctype, encklen);
 	if (res == -1) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"invalid encryption algorithm %u.\n", enctype);
 		return ~0;
 	}
 	return res;
 }
 
-int
-pfkey_convertfromipsecdoi(proto_id, t_id, hashtype,
+static int
+rc_convertfromipsecdoi(proto_id, t_id, hashtype,
 		e_type, e_keylen, a_type, a_keylen, flags)
 	u_int proto_id;
 	u_int t_id;
@@ -721,47 +495,58 @@
 	*flags = 0;
 	switch (proto_id) {
 	case IPSECDOI_PROTO_IPSEC_ESP:
-		if ((*e_type = ipsecdoi2pfkey_ealg(t_id)) == ~0)
+		if ((*e_type = ipsecdoi2rc_ealg(t_id)) == -1)
 			goto bad;
 		if ((*e_keylen = keylen_ealg(t_id, *e_keylen)) == ~0)
 			goto bad;
 		*e_keylen >>= 3;
 
-		if ((*a_type = ipsecdoi2pfkey_aalg(hashtype)) == ~0)
+		if ((*a_type = ipsecdoi2rc_aalg(hashtype)) == ~0)
 			goto bad;
 		if ((*a_keylen = keylen_aalg(hashtype)) == ~0)
 			goto bad;
 		*a_keylen >>= 3;
 
 		if (*e_type == SADB_EALG_NONE) {
-			plog(LLV_ERROR, LOCATION, NULL, "no ESP algorithm.\n");
+			plog(PLOG_INTERR, PLOGLOC, NULL, "no ESP algorithm.\n");
 			goto bad;
 		}
 		break;
 
 	case IPSECDOI_PROTO_IPSEC_AH:
-		if ((*a_type = ipsecdoi2pfkey_aalg(hashtype)) == ~0)
+		if ((*a_type = ipsecdoi2rc_aalg(hashtype)) == ~0)
 			goto bad;
 		if ((*a_keylen = keylen_aalg(hashtype)) == ~0)
 			goto bad;
 		*a_keylen >>= 3;
 
+		if (hashtype == IPSECDOI_ATTR_AUTH_KPDK) {
+			if (t_id != IPSECDOI_AH_MD5) {
+				plog(PLOG_INTERR, PLOGLOC, 0,
+				     "transform id %d when AH MD5 is expected\n",
+				     t_id);
+				goto bad;
+			}
+		}
+#if 0
 		if (t_id == IPSECDOI_ATTR_AUTH_HMAC_MD5 
 		 && hashtype == IPSECDOI_ATTR_AUTH_KPDK) {
 			/* AH_MD5 + Auth(KPDK) = RFC1826 keyed-MD5 */
+			*a_type = RCT_ALG_KPDK_MD5;
 			*a_type = SADB_X_AALG_MD5;
 			*flags |= SADB_X_EXT_OLD;
 		}
+#endif
 		*e_type = SADB_EALG_NONE;
 		*e_keylen = 0;
 		if (*a_type == SADB_AALG_NONE) {
-			plog(LLV_ERROR, LOCATION, NULL, "no AH algorithm.\n");
+			plog(PLOG_INTERR, PLOGLOC, NULL, "no AH algorithm.\n");
 			goto bad;
 		}
 		break;
 
 	case IPSECDOI_PROTO_IPCOMP:
-		if ((*e_type = ipsecdoi2pfkey_calg(t_id)) == ~0)
+		if ((*e_type = ipsecdoi2rc_calg(t_id)) == ~0)
 			goto bad;
 		*e_keylen = 0;
 
@@ -770,13 +555,15 @@
 		*a_type = SADB_AALG_NONE;
 		*a_keylen = 0;
 		if (*e_type == SADB_X_CALG_NONE) {
-			plog(LLV_ERROR, LOCATION, NULL, "no IPCOMP algorithm.\n");
+			plog(PLOG_INTERR, PLOGLOC, NULL, "no IPCOMP algorithm.\n");
 			goto bad;
 		}
 		break;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL, "unknown IPsec protocol.\n");
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "unknown IPsec protocol %d.\n",
+		     proto_id);
 		goto bad;
 	}
 
@@ -787,35 +574,6 @@
 	return -1;
 }
 
-/* called from scheduler */
-void
-pfkey_timeover_stub(p)
-	void *p;
-{
-
-	pfkey_timeover((struct ph2handle *)p);
-}
-
-void
-pfkey_timeover(iph2)
-	struct ph2handle *iph2;
-{
-	plog(LLV_ERROR, LOCATION, NULL,
-		"%s give up to get IPsec-SA due to time up to wait.\n",
-		saddrwop2str(iph2->dst));
-	SCHED_KILL(iph2->sce);
-
-	/* If initiator side, send error to kernel by SADB_ACQUIRE. */
-	if (iph2->side == INITIATOR)
-		pk_sendeacquire(iph2);
-
-	unbindph12(iph2);
-	remph2(iph2);
-	delph2(iph2);
-
-	return;
-}
-
 /*%%%*/
 /* send getspi message per ipsec protocol per remote address */
 /*
@@ -833,10 +591,11 @@
 	struct saproto *pr;
 	u_int32_t minspi, maxspi;
 	int proxy = 0;
+	struct rcpfk_msg param;
 
 	if (iph2->side == INITIATOR) {
 		pp = iph2->proposal;
-		proxy = iph2->ph1->rmconf->support_proxy;
+		proxy = ikev1_support_proxy(iph2->ph1->rmconf);
 	} else {
 		pp = iph2->approval;
 		if (iph2->sainfo && iph2->sainfo->id_i)
@@ -856,9 +615,9 @@
 	for (pr = pp->head; pr != NULL; pr = pr->next) {
 
 		/* validity check */
-		satype = ipsecdoi2pfkey_proto(pr->proto_id);
+		satype = ipsecdoi2rc_proto(pr->proto_id);
 		if (satype == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"invalid proto_id %d\n", pr->proto_id);
 			return -1;
 		}
@@ -872,14 +631,28 @@
 			minspi = 0;
 			maxspi = 0;
 		}
-		mode = ipsecdoi2pfkey_mode(pr->encmode);
+		mode = ipsecdoi2rc_mode(pr->encmode);
 		if (mode == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"invalid encmode %d\n", pr->encmode);
 			return -1;
 		}
 
-		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_getspi\n");
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_getspi\n");
+
+		param.sa_src = dst; /* src of SA */
+		param.sa_dst = src; /* dst of SA */
+		param.satype = satype;
+		param.samode = mode;
+		/* param.minspi = minspi; */
+		/* param.maxspi = maxspi; */
+		param.reqid = pr->reqid_in;
+		param.seq = iph2->seq;
+		if (iph2->sadb_request.method->getspi(&param)) {
+			/* (*getspi)() logs error message */
+			return -1;
+		}
+#if 0
 		if (pfkey_send_getspi(
 				lcconf->sock_pfkey,
 				satype,
@@ -888,12 +661,13 @@
 				src,			/* dst of SA */
 				minspi, maxspi,
 				pr->reqid_in, iph2->seq) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"ipseclib failed send getspi (%s)\n",
 				ipsec_strerror());
 			return -1;
 		}
-		plog(LLV_DEBUG, LOCATION, NULL,
+#endif
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"pfkey GETSPI sent: %s\n",
 			sadbsecas2str(dst, src, satype, 0, mode));
 	}
@@ -905,80 +679,54 @@
  * receive GETSPI from kernel.
  */
 static int
-pk_recvgetspi(mhp) 
-	caddr_t *mhp;
+ikev1_getspi_response(struct sadb_request *req,
+		      struct sockaddr *src, struct sockaddr *dst, 
+		      u_int satype, u_int samode, u_int32_t spi)
 {
-	struct sadb_msg *msg;
-	struct sadb_sa *sa;
+	u_int proto_id;
+	int allspiok;
+	int notfound;
 	struct ph2handle *iph2;
-	struct sockaddr *dst;
-	int proto_id;
-	int allspiok, notfound;
 	struct saprop *pp;
 	struct saproto *pr;
 
-	/* validity check */
-	if (mhp[SADB_EXT_SA] == NULL
-	 || mhp[SADB_EXT_ADDRESS_DST] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"inappropriate sadb getspi message passed.\n");
-		return -1;
-	}
-	msg = (struct sadb_msg *)mhp[0];
-	sa = (struct sadb_sa *)mhp[SADB_EXT_SA];
-	dst = PFKEY_ADDR_SADDR(mhp[SADB_EXT_ADDRESS_SRC]); /* note SA dir */
-
-	/* the message has to be processed or not ? */
-	if (msg->sadb_msg_pid != getpid()) {
-		plog(LLV_DEBUG, LOCATION, NULL,
-			"%s message is not interesting "
-			"because pid %d is not mine.\n",
-			s_pfkey_type(msg->sadb_msg_type),
-			msg->sadb_msg_pid);
-		return -1;
-	}
-
-	iph2 = getph2byseq(msg->sadb_msg_seq);
-	if (iph2 == NULL) {
-		plog(LLV_DEBUG, LOCATION, NULL,
-			"seq %d of %s message not interesting.\n",
-			msg->sadb_msg_seq,
-			s_pfkey_type(msg->sadb_msg_type));
-		return -1;
-	}
-
+	iph2 = req->sa;
+	/*assert(iph2 != 0);*/
 	if (iph2->status != PHASE2ST_GETSPISENT) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, 0, 
 			"status mismatch (db:%d msg:%d)\n",
 			iph2->status, PHASE2ST_GETSPISENT);
 		return -1;
 	}
 
+	proto_id = rc2ipsecdoi_proto(satype);
+	if (proto_id == ~0)
+		return -1;
+
 	/* set SPI, and check to get all spi whether or not */
-	allspiok = 1;
-	notfound = 1;
-	proto_id = pfkey2ipsecdoi_proto(msg->sadb_msg_satype);
+	allspiok = TRUE;
+	notfound = TRUE;
 	pp = iph2->side == INITIATOR ? iph2->proposal : iph2->approval;
 
 	for (pr = pp->head; pr != NULL; pr = pr->next) {
 		if (pr->proto_id == proto_id && pr->spi == 0) {
-			pr->spi = sa->sadb_sa_spi;
-			notfound = 0;
-			plog(LLV_DEBUG, LOCATION, NULL,
-				"pfkey GETSPI succeeded: %s\n",
-				sadbsecas2str(iph2->dst, iph2->src,
-				    msg->sadb_msg_satype,
-				    sa->sadb_sa_spi,
-				    ipsecdoi2pfkey_mode(pr->encmode)));
+			put_uint32((u_int32_t *)&pr->spi, spi);
+			notfound = FALSE;
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
+			     "pfkey GETSPI succeeded: %s\n",
+			     sadbsecas2str(iph2->dst, iph2->src,
+					   satype,
+					   htonl(spi),
+					   ipsecdoi2rc_mode(pr->encmode)));
 		}
 		if (pr->spi == 0)
-			allspiok = 0;	/* not get all spi */
+			allspiok = FALSE;	/* not get all spi */
 	}
 
 	if (notfound) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"get spi for unknown address %s\n",
-			saddrwop2str(iph2->dst));
+		plog(PLOG_INTERR, PLOGLOC, NULL,
+		     "get spi for unknown address %s\n",
+		     rcs_sa2str(iph2->dst));
 		return -1;
 	}
 
@@ -986,7 +734,7 @@
 		/* update status */
 		iph2->status = PHASE2ST_GETSPIDONE;
 		if (isakmp_post_getspi(iph2) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to start post getspi.\n");
 			unbindph12(iph2);
 			remph2(iph2);
@@ -1008,21 +756,27 @@
 {
 	struct saproto *pr;
 	struct sockaddr *src = NULL, *dst = NULL;
-	u_int e_type, e_keylen, a_type, a_keylen, flags;
-	u_int satype, mode;
+	int plen;
+	int e_type, e_keylen, a_type;
+	u_int a_keylen, flags;
+	int satype, mode;
 	u_int64_t lifebyte = 0;
 	u_int wsize = 4;  /* XXX static size of window */ 
 	int proxy = 0;
+#ifdef ENABLE_NATT
 	struct ph2natt natt;
+#endif
+	struct rcpfk_msg param;
 
 	/* sanity check */
 	if (iph2->approval == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"no approvaled SAs found.\n");
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "no approvaled SAs found.\n");
+		return -1;
 	}
 
 	if (iph2->side == INITIATOR)
-		proxy = iph2->ph1->rmconf->support_proxy;
+		proxy = (ikev1_support_proxy(iph2->ph1->rmconf) != RCT_BOOL_OFF);
 	else if (iph2->sainfo && iph2->sainfo->id_i)
 		proxy = 1;
 
@@ -1038,30 +792,33 @@
 
 	for (pr = iph2->approval->head; pr != NULL; pr = pr->next) {
 		/* validity check */
-		satype = ipsecdoi2pfkey_proto(pr->proto_id);
-		if (satype == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+		satype = ipsecdoi2rc_proto(pr->proto_id);
+		if (satype == -1) {
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"invalid proto_id %d\n", pr->proto_id);
 			return -1;
 		}
-		else if (satype == SADB_X_SATYPE_IPCOMP) {
+		else if (satype == RCT_SATYPE_IPCOMP) {
 			/* IPCOMP has no replay window */
 			wsize = 0;
 		}
 #ifdef ENABLE_SAMODE_UNSPECIFIED
+#error ENABLE_SAMODE_UNSPECIFIED unsupported
+#if 0
 		mode = IPSEC_MODE_ANY;
+#endif
 #else
-		mode = ipsecdoi2pfkey_mode(pr->encmode);
-		if (mode == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"invalid encmode %d\n", pr->encmode);
+		mode = ipsecdoi2rc_mode(pr->encmode);
+		if (mode == -1) {
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
+			     "invalid encmode %d\n", pr->encmode);
 			return -1;
 		}
 #endif
 
 		/* set algorithm type and key length */
 		e_keylen = pr->head->encklen;
-		if (pfkey_convertfromipsecdoi(
+		if (rc_convertfromipsecdoi(
 				pr->proto_id,
 				pr->head->trns_id,
 				pr->head->authtype,
@@ -1076,7 +833,8 @@
 #endif
 
 #ifdef ENABLE_NATT
-		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_update_nat\n");
+#error not implemented yet
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_update_nat\n");
 		if (pr->udp_encap) {
 			memset (&natt, 0, sizeof (natt));
 			natt.type = iph2->ph1->natt_options->encaps_type;
@@ -1103,13 +861,46 @@
 				iph2->seq,
 				natt.type, natt.sport, natt.dport, natt.oa,
 				natt.frag) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"libipsec failed send update_nat (%s)\n",
 				ipsec_strerror());
 			return -1;
 		}
 #else
-		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_update\n");
+		switch (SOCKADDR_FAMILY(src)) {
+		case AF_INET:	plen = 32; break;
+		case AF_INET6:	plen = 128; break;
+		default:	return -1;
+		}
+		param.satype = satype;
+		param.seq = iph2->seq;
+		param.spi = pr->spi;
+		param.wsize = wsize;
+		param.authtype = a_type;
+		param.enctype = e_type;
+		param.saflags = flags;
+		param.samode = mode;
+		param.reqid = pr->reqid_in;
+		param.lft_hard_time = iph2->approval->lifetime;
+		param.lft_hard_bytes = lifebyte;
+		param.lft_soft_time = iph2->approval->lifetime;	/* ??? */
+		param.lft_soft_bytes = lifebyte;
+		param.sa_src = dst; /* for inbound */
+		param.pref_src = plen;
+		param.sa_dst = src;
+		param.pref_dst = plen;
+		param.ul_proto = RC_PROTO_ANY; /* ??? */
+		param.enckey = pr->keymat->v;
+		param.enckeylen = e_keylen;
+		param.authkey = pr->keymat->v + e_keylen;
+		param.authkeylen = a_keylen;
+		if (iph2->sadb_request.method->update_inbound(&param)) {
+			/* (*update_inbound)() logs error message */
+			return -1;
+		}
+
+#if 0
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_update\n");
 		if (pfkey_send_update(
 				lcconf->sock_pfkey,
 				satype,
@@ -1123,13 +914,15 @@
 				e_type, e_keylen, a_type, a_keylen, flags,
 				0, lifebyte, iph2->approval->lifetime, 0,
 				iph2->seq) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"libipsec failed send update (%s)\n",
 				ipsec_strerror());
 			return -1;
 		}
+#endif
 #endif /* ENABLE_NATT */
 
+#ifdef notyet
 		if (!lcconf->pathinfo[LC_PATHTYPE_BACKUPSA])
 			continue;
 
@@ -1146,110 +939,92 @@
 				0, iph2->approval->lifebyte * 1024,
 				iph2->approval->lifetime, 0,
 				iph2->seq) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"backuped SA failed: %s\n",
 				sadbsecas2str(dst, src,
 				satype, pr->spi, mode));
 		}
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"backuped SA: %s\n",
 			sadbsecas2str(dst, src,
 			satype, pr->spi, mode));
+#endif
 	}
 
 	return 0;
 }
 
+/* called from scheduler.
+ * this function will call only isakmp_ph2delete().
+ * phase 2 handler remain forever if kernel doesn't cry a expire of phase 2 SA
+ * by something cause.  That's why this function is called after phase 2 SA
+ * expires in the userland.
+ */
+static void
+isakmp_ph2expire_stub(p)
+	void *p;
+{
+	isakmp_ph2expire((struct ph2handle *)p);
+}
+
 static int
-pk_recvupdate(mhp)
-	caddr_t *mhp;
+ikev1_update_response(struct sadb_request *req, 
+		      struct sockaddr *src, struct sockaddr *dst,
+		      u_int satype, u_int samode, 
+		      u_int32_t spi)
 {
-	struct sadb_msg *msg;
-	struct sadb_sa *sa;
-	struct sockaddr *src, *dst;
 	struct ph2handle *iph2;
-	u_int proto_id, encmode, sa_mode;
-	int incomplete = 0;
+	int incomplete = FALSE;
+	u_int proto_id;
 	struct saproto *pr;
+	int encmode;
+	
 
-	/* ignore this message because of local test mode. */
-	if (f_local)
-		return 0;
-
-	/* sanity check */
-	if (mhp[0] == NULL
-	 || mhp[SADB_EXT_SA] == NULL
-	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
-	 || mhp[SADB_EXT_ADDRESS_DST] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"inappropriate sadb update message passed.\n");
+	iph2 = req->sa;
+	if (!iph2) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "received SADB_UPDATE seq %d points to invalid sa\n");
 		return -1;
 	}
-	msg = (struct sadb_msg *)mhp[0];
-	src = PFKEY_ADDR_SADDR(mhp[SADB_EXT_ADDRESS_SRC]);
-	dst = PFKEY_ADDR_SADDR(mhp[SADB_EXT_ADDRESS_DST]);
-	sa = (struct sadb_sa *)mhp[SADB_EXT_SA];
-
-	sa_mode = mhp[SADB_X_EXT_SA2] == NULL
-		? IPSEC_MODE_ANY
-		: ((struct sadb_x_sa2 *)mhp[SADB_X_EXT_SA2])->sadb_x_sa2_mode;
 
-	/* the message has to be processed or not ? */
-	if (msg->sadb_msg_pid != getpid()) {
-		plog(LLV_DEBUG, LOCATION, NULL,
-			"%s message is not interesting "
-			"because pid %d is not mine.\n",
-			s_pfkey_type(msg->sadb_msg_type),
-			msg->sadb_msg_pid);
+	if (iph2->status != PHASE2ST_ADDSA) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "status mismatch (db:%d msg:%d)\n",
+		     iph2->status, PHASE2ST_ADDSA);
 		return -1;
 	}
 
-	iph2 = getph2byseq(msg->sadb_msg_seq);
-	if (iph2 == NULL) {
-		plog(LLV_DEBUG, LOCATION, NULL,
-			"seq %d of %s message not interesting.\n",
-			msg->sadb_msg_seq,
-			s_pfkey_type(msg->sadb_msg_type));
+	proto_id = rc2ipsecdoi_proto(satype);
+	if (proto_id == ~0) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "invalid satype %d\n", satype);
 		return -1;
 	}
-
-	if (iph2->status != PHASE2ST_ADDSA) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"status mismatch (db:%d msg:%d)\n",
-			iph2->status, PHASE2ST_ADDSA);
+	encmode = rc2ipsecdoi_mode(samode);
+	if (encmode == ~0) {
+		plog(PLOG_INTERR, PLOGLOC, NULL,
+		     "invalid encmode %d\n", samode);
 		return -1;
 	}
 
 	/* check to complete all keys ? */
 	for (pr = iph2->approval->head; pr != NULL; pr = pr->next) {
-		proto_id = pfkey2ipsecdoi_proto(msg->sadb_msg_satype);
-		if (proto_id == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"invalid proto_id %d\n", msg->sadb_msg_satype);
-			return -1;
-		}
-		encmode = pfkey2ipsecdoi_mode(sa_mode);
-		if (encmode == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"invalid encmode %d\n", sa_mode);
-			return -1;
-		}
-
 		if (pr->proto_id == proto_id
-		 && pr->spi == sa->sadb_sa_spi) {
+		 && get_uint32(&pr->spi) == spi) {
 			pr->ok = 1;
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"pfkey UPDATE succeeded: %s\n",
 				sadbsecas2str(iph2->dst, iph2->src,
-				    msg->sadb_msg_satype,
-				    sa->sadb_sa_spi,
-				    sa_mode));
+					      satype,
+					      htonl(spi),
+					      samode));
 
-			plog(LLV_INFO, LOCATION, NULL,
+			plog(PLOG_INFO, PLOGLOC, NULL,
 				"IPsec-SA established: %s\n",
 				sadbsecas2str(iph2->dst, iph2->src,
-					msg->sadb_msg_satype, sa->sadb_sa_spi,
-					sa_mode));
+					      satype,
+					      htonl(spi),
+					      samode));
 		}
 
 		if (pr->ok == 0)
@@ -1287,7 +1062,7 @@
 	iph2->sce = sched_new(iph2->approval->lifetime,
 	    isakmp_ph2expire_stub, iph2);
 
-	plog(LLV_DEBUG, LOCATION, NULL, "===\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "===\n");
 	return 0;
 }
 
@@ -1300,21 +1075,27 @@
 {
 	struct saproto *pr;
 	struct sockaddr *src = NULL, *dst = NULL;
-	u_int e_type, e_keylen, a_type, a_keylen, flags;
-	u_int satype, mode;
+	int plen;
+	int e_type, e_keylen, a_type;
+	u_int a_keylen, flags;
+	int satype, mode;
 	u_int64_t lifebyte = 0;
-	u_int wsize = 4; /* XXX static size of window */ 
+	u_int wsize = 4;  /* XXX static size of window */ 
 	int proxy = 0;
+#ifdef ENABLE_NATT
 	struct ph2natt natt;
+#endif
+	struct rcpfk_msg param;
 
 	/* sanity check */
 	if (iph2->approval == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"no approvaled SAs found.\n");
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "no approvaled SAs found.\n");
+		return -1;
 	}
 
 	if (iph2->side == INITIATOR)
-		proxy = iph2->ph1->rmconf->support_proxy;
+		proxy = (ikev1_support_proxy(iph2->ph1->rmconf) != RCT_BOOL_OFF);
 	else if (iph2->sainfo && iph2->sainfo->id_i)
 		proxy = 1;
 
@@ -1330,30 +1111,33 @@
 
 	for (pr = iph2->approval->head; pr != NULL; pr = pr->next) {
 		/* validity check */
-		satype = ipsecdoi2pfkey_proto(pr->proto_id);
-		if (satype == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+		satype = ipsecdoi2rc_proto(pr->proto_id);
+		if (satype == -1) {
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
 				"invalid proto_id %d\n", pr->proto_id);
 			return -1;
 		}
-		else if (satype == SADB_X_SATYPE_IPCOMP) {
-			/* no replay window for IPCOMP */
+		else if (satype == RCT_SATYPE_IPCOMP) {
+			/* IPCOMP has no replay window */
 			wsize = 0;
 		}
 #ifdef ENABLE_SAMODE_UNSPECIFIED
+#error ENABLE_SAMODE_UNSPECIFIED unsupported
+#if 0
 		mode = IPSEC_MODE_ANY;
+#endif
 #else
-		mode = ipsecdoi2pfkey_mode(pr->encmode);
-		if (mode == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
-				"invalid encmode %d\n", pr->encmode);
+		mode = ipsecdoi2rc_mode(pr->encmode);
+		if (mode == -1) {
+			plog(PLOG_PROTOERR, PLOGLOC, 0,
+			     "invalid encmode %d\n", pr->encmode);
 			return -1;
 		}
 #endif
 
 		/* set algorithm type and key length */
 		e_keylen = pr->head->encklen;
-		if (pfkey_convertfromipsecdoi(
+		if (rc_convertfromipsecdoi(
 				pr->proto_id,
 				pr->head->trns_id,
 				pr->head->authtype,
@@ -1368,100 +1152,128 @@
 #endif
 
 #ifdef ENABLE_NATT
-		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_add_nat\n");
-
+#error not implemented yet
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_add_nat\n");
 		if (pr->udp_encap) {
 			memset (&natt, 0, sizeof (natt));
-			natt.type = UDP_ENCAP_ESPINUDP;
-			natt.sport = extract_port (iph2->ph1->local);
-			natt.dport = extract_port (iph2->ph1->remote);
+			natt.type = iph2->ph1->natt_options->encaps_type;
+			natt.sport = extract_port (iph2->ph1->remote);
+			natt.dport = extract_port (iph2->ph1->local);
 			natt.oa = NULL;		// FIXME: Here comes OA!!!
 			natt.frag = iph2->ph1->rmconf->esp_frag;
 		} else {
 			memset (&natt, 0, sizeof (natt));
-
-			/* Remove port information, that SA doesn't use it */
-			set_port(src, 0);
-			set_port(dst, 0);
 		}
 
 		if (pfkey_send_add_nat(
 				lcconf->sock_pfkey,
 				satype,
 				mode,
-				src,
 				dst,
-				pr->spi_p,
-				pr->reqid_out,
+				src,
+				pr->spi,
+				pr->reqid_in,
 				wsize,	
-				pr->keymat_p->v,
+				pr->keymat->v,
 				e_type, e_keylen, a_type, a_keylen, flags,
 				0, lifebyte, iph2->approval->lifetime, 0,
 				iph2->seq,
 				natt.type, natt.sport, natt.dport, natt.oa,
 				natt.frag) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"libipsec failed send add_nat (%s)\n",
 				ipsec_strerror());
 			return -1;
 		}
 #else
-		plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_add\n");
-
-		/* Remove port information, it is not used without NAT-T */
-		set_port(src, 0);
-		set_port(dst, 0);
+		switch (SOCKADDR_FAMILY(src)) {
+		case AF_INET:	plen = 32; break;
+		case AF_INET6:	plen = 128; break;
+		default:	return -1;
+		}
+		param.satype = satype;
+		param.seq = iph2->seq;
+		param.spi = pr->spi;
+		param.wsize = wsize;
+		param.authtype = a_type;
+		param.enctype = e_type;
+		param.saflags = flags;
+		param.samode = mode;
+		param.reqid = pr->reqid_in;
+		param.lft_hard_time = iph2->approval->lifetime;
+		param.lft_hard_bytes = lifebyte;
+		param.lft_soft_time = iph2->approval->lifetime;	/* ??? */
+		param.lft_soft_bytes = lifebyte;
+		param.sa_src = src;
+		param.pref_src = plen;
+		param.sa_dst = dst;
+		param.pref_dst = plen;
+		param.ul_proto = RC_PROTO_ANY; /* ??? */
+		param.enckey = pr->keymat->v;
+		param.enckeylen = e_keylen;
+		param.authkey = pr->keymat->v + e_keylen;
+		param.authkeylen = a_keylen;
+		if (iph2->sadb_request.method->add_outbound(&param)) {
+			/* (*update_outbound)() logs error message */
+			return -1;
+		}
 
+#if 0
+		plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_add\n");
 		if (pfkey_send_add(
 				lcconf->sock_pfkey,
 				satype,
 				mode,
-				src,
 				dst,
-				pr->spi_p,
-				pr->reqid_out,
-				wsize,
-				pr->keymat_p->v,
+				src,
+				pr->spi,
+				pr->reqid_in,
+				wsize,	
+				pr->keymat->v,
 				e_type, e_keylen, a_type, a_keylen, flags,
 				0, lifebyte, iph2->approval->lifetime, 0,
 				iph2->seq) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"libipsec failed send add (%s)\n",
 				ipsec_strerror());
 			return -1;
 		}
+#endif
 #endif /* ENABLE_NATT */
 
+#ifdef notyet
 		if (!lcconf->pathinfo[LC_PATHTYPE_BACKUPSA])
 			continue;
 
 		/*
 		 * It maybe good idea to call backupsa_to_file() after
-		 * racoon will receive the sadb_update messages.
+		 * racoon will receive the sadb_add messages.
 		 * But it is impossible because there is not key in the
 		 * information from the kernel.
 		 */
-		if (backupsa_to_file(satype, mode, src, dst,
-				pr->spi_p, pr->reqid_out, 4,
-				pr->keymat_p->v,
+		if (backupsa_to_file(satype, mode, dst, src,
+				pr->spi, pr->reqid_in, 4,
+				pr->keymat->v,
 				e_type, e_keylen, a_type, a_keylen, flags,
 				0, iph2->approval->lifebyte * 1024,
 				iph2->approval->lifetime, 0,
 				iph2->seq) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"backuped SA failed: %s\n",
-				sadbsecas2str(src, dst,
-				satype, pr->spi_p, mode));
+				sadbsecas2str(dst, src,
+				satype, pr->spi, mode));
 		}
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"backuped SA: %s\n",
-			sadbsecas2str(src, dst,
-			satype, pr->spi_p, mode));
+			sadbsecas2str(dst, src,
+			satype, pr->spi, mode));
+#endif
 	}
 
 	return 0;
 }
 
+#if 0
 static int
 pk_recvadd(mhp)
 	caddr_t *mhp;
@@ -1481,7 +1293,7 @@
 	 || mhp[SADB_EXT_SA] == NULL
 	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb add message passed.\n");
 		return -1;
 	}
@@ -1496,7 +1308,7 @@
 
 	/* the message has to be processed or not ? */
 	if (msg->sadb_msg_pid != getpid()) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"%s message is not interesting "
 			"because pid %d is not mine.\n",
 			s_pfkey_type(msg->sadb_msg_type),
@@ -1506,7 +1318,7 @@
 
 	iph2 = getph2byseq(msg->sadb_msg_seq);
 	if (iph2 == NULL) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"seq %d of %s message not interesting.\n",
 			msg->sadb_msg_seq,
 			s_pfkey_type(msg->sadb_msg_type));
@@ -1518,84 +1330,48 @@
 	 * because they must be updated by SADB_UPDATE message
 	 */
 
-	plog(LLV_INFO, LOCATION, NULL,
+	plog(PLOG_INFO, PLOGLOC, NULL,
 		"IPsec-SA established: %s\n",
 		sadbsecas2str(iph2->src, iph2->dst,
 			msg->sadb_msg_satype, sa->sadb_sa_spi, sa_mode));
 
-	plog(LLV_DEBUG, LOCATION, NULL, "===\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "===\n");
 	return 0;
 }
+#endif
 
 static int
-pk_recvexpire(mhp)
-	caddr_t *mhp;
+ikev1_expired(struct sadb_request *req, struct rcpfk_msg *param)
 {
-	struct sadb_msg *msg;
-	struct sadb_sa *sa;
-	struct sockaddr *src, *dst;
+	u_int satype;
 	struct ph2handle *iph2;
-	u_int proto_id, sa_mode;
 
-	/* sanity check */
-	if (mhp[0] == NULL
-	 || mhp[SADB_EXT_SA] == NULL
-	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
-	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
-	 || (mhp[SADB_EXT_LIFETIME_HARD] != NULL
-	  && mhp[SADB_EXT_LIFETIME_SOFT] != NULL)) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"inappropriate sadb expire message passed.\n");
-		return -1;
-	}
-	msg = (struct sadb_msg *)mhp[0];
-	sa = (struct sadb_sa *)mhp[SADB_EXT_SA];
-	src = PFKEY_ADDR_SADDR(mhp[SADB_EXT_ADDRESS_SRC]);
-	dst = PFKEY_ADDR_SADDR(mhp[SADB_EXT_ADDRESS_DST]);
-
-	sa_mode = mhp[SADB_X_EXT_SA2] == NULL
-		? IPSEC_MODE_ANY
-		: ((struct sadb_x_sa2 *)mhp[SADB_X_EXT_SA2])->sadb_x_sa2_mode;
+	TRACE((PLOGLOC, "ikev1_expired(%p)\n", req));
 
-	proto_id = pfkey2ipsecdoi_proto(msg->sadb_msg_satype);
-	if (proto_id == ~0) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"invalid proto_id %d\n", msg->sadb_msg_satype);
-		return -1;
+	satype = rc2ipsecdoi_proto(param->satype);
+	if (satype == ~0) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "invalid satype %d\n", param->satype);
+		return FALSE;
+	}
+
+	iph2 = getph2bysaidx(param->sa_src, param->sa_dst, satype, param->spi);
+	if (!iph2) {
+		TRACE((PLOGLOC, "iph2 == 0\n"));
+		return FALSE;
+	}
+	if (iph2 != req->sa) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "unexpected: iph2 %p != req->sa %p\n",
+		     iph2, req->sa);
+		return FALSE;
 	}
 
-	plog(LLV_INFO, LOCATION, NULL,
-		"IPsec-SA expired: %s\n",
-		sadbsecas2str(src, dst,
-			msg->sadb_msg_satype, sa->sadb_sa_spi, sa_mode));
-
-	iph2 = getph2bysaidx(src, dst, proto_id, sa->sadb_sa_spi);
-	if (iph2 == NULL) {
-		/*
-		 * Ignore it because two expire messages are come up.
-		 * phase2 handler has been deleted already when 2nd message
-		 * is received.
-		 */
-		plog(LLV_DEBUG, LOCATION, NULL,
-			"no such a SA found: %s\n",
-			sadbsecas2str(src, dst,
-			    msg->sadb_msg_satype, sa->sadb_sa_spi,
-			    sa_mode));
-		return 0;
-	}
 	if (iph2->status != PHASE2ST_ESTABLISHED) {
-		/*
-		 * If the status is not equal to PHASE2ST_ESTABLISHED,
-		 * racoon ignores this expire message.  There are two reason.
-		 * One is that the phase 2 probably starts because there is
-		 * a potential that racoon receives the acquire message
-		 * without receiving a expire message.  Another is that racoon
-		 * may receive the multiple expire messages from the kernel.
-		 */
-		plog(LLV_WARNING, LOCATION, NULL,
-			"the expire message is received "
-			"but the handler has not been established.\n");
-		return 0;
+		plog(PLOG_INTWARN, PLOGLOC, 0,
+		     "unexpected expire message (sa state %d)\n",
+		     iph2->status);
+		return FALSE;
 	}
 
 	/* turn off the timer for calling isakmp_ph2expire() */ 
@@ -1613,17 +1389,17 @@
 		iph2->status = PHASE2ST_STATUS2;
 
 		/* start isakmp initiation by using ident exchange */
-		if (isakmp_post_acquire(iph2) < 0) {
-			plog(LLV_ERROR, LOCATION, iph2->dst,
-				"failed to begin ipsec sa "
-				"re-negotication.\n");
+		if (ikev1_post_acquire(iph2->ph1->rmconf, iph2) < 0) {
+			plog(PLOG_INTERR, PLOGLOC, 0,
+			     "failed to begin ipsec sa "
+			     "re-negotication.\n");
 			unbindph12(iph2);
 			remph2(iph2);
 			delph2(iph2);
-			return -1;
+			return TRUE;
 		}
 
-		return 0;
+		return TRUE;
 		/*NOTREACHED*/
 	}
 
@@ -1634,9 +1410,10 @@
 	remph2(iph2);
 	delph2(iph2);
 
-	return 0;
+	return TRUE;
 }
 
+#if 0
 static int
 pk_recvacquire(mhp)
 	caddr_t *mhp;
@@ -1658,7 +1435,7 @@
 	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
 	 || mhp[SADB_X_EXT_POLICY] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb acquire message passed.\n");
 		return -1;
 	}
@@ -1669,7 +1446,7 @@
 
 	/* ignore if type is not IPSEC_POLICY_IPSEC */
 	if (xpl->sadb_x_policy_type != IPSEC_POLICY_IPSEC) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"ignore ACQUIRE message. type is not IPsec.\n");
 		return 0;
 	}
@@ -1685,9 +1462,9 @@
 	  && IN6_IS_ADDR_MULTICAST(&((struct sockaddr_in6 *)sa)->sin6_addr))
 #endif
 	) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"ignore due to multicast address: %s.\n",
-			saddrwop2str(sa));
+		     rcs_sa2str_wop(sa));
 		return 0;
 	}
     }
@@ -1713,7 +1490,7 @@
 		}
 
 		if (!do_listen) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"ignore because do not listen on source address : %s.\n",
 				saddrwop2str(sa));
 			return 0;
@@ -1733,7 +1510,7 @@
 	iph2[0] = getph2byid(src, dst, xpl->sadb_x_policy_id);
 	if (iph2[0] != NULL) {
 		if (iph2[0]->status < PHASE2ST_ESTABLISHED) {
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"ignore the acquire because ph2 found\n");
 			return -1;
 		}
@@ -1745,11 +1522,11 @@
 	/* search for proper policyindex */
 	sp_out = getspbyspid(xpl->sadb_x_policy_id);
 	if (sp_out == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, "no policy found: id:%d.\n",
+		plog(PLOG_INTERR, PLOGLOC, NULL, "no policy found: id:%d.\n",
 			xpl->sadb_x_policy_id);
 		return -1;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"suitable outbound SP found: %s.\n", spidx2str(&sp_out->spidx));
 
 	/* get inbound policy */
@@ -1765,11 +1542,11 @@
 
 	sp_in = getsp(&spidx);
 	if (sp_in) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"suitable inbound SP found: %s.\n",
 			spidx2str(&sp_in->spidx));
 	} else {
-		plog(LLV_NOTIFY, LOCATION, NULL,
+		plog(PLOG_INFO, PLOGLOC, NULL,
 			"no in-bound policy found: %s\n",
 			spidx2str(&spidx));
 	}
@@ -1782,7 +1559,7 @@
 	/* allocate a phase 2 */
 	iph2[n] = newph2();
 	if (iph2[n] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate phase2 entry.\n");
 		return -1;
 	}
@@ -1804,7 +1581,7 @@
 		return -1;
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL,
+	plog(PLOG_DEBUG, PLOGLOC, NULL,
 		"new acquire %s\n", spidx2str(&sp_out->spidx));
 
 	/* get sainfo */
@@ -1814,7 +1591,7 @@
 	idsrc = ipsecdoi_sockaddr2id((struct sockaddr *)&sp_out->spidx.src,
 				sp_out->spidx.prefs, sp_out->spidx.ul_proto);
 	if (idsrc == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get ID for %s\n",
 			spidx2str(&sp_out->spidx));
 		delph2(iph2[n]);
@@ -1823,7 +1600,7 @@
 	iddst = ipsecdoi_sockaddr2id((struct sockaddr *)&sp_out->spidx.dst,
 				sp_out->spidx.prefd, sp_out->spidx.ul_proto);
 	if (iddst == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get ID for %s\n",
 			spidx2str(&sp_out->spidx));
 		vfree(idsrc);
@@ -1834,7 +1611,7 @@
 	vfree(idsrc);
 	vfree(iddst);
 	if (iph2[n]->sainfo == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to get sainfo.\n");
 		delph2(iph2[n]);
 		return -1;
@@ -1843,7 +1620,7 @@
     }
 
 	if (set_proposal_from_policy(iph2[n], sp_out, sp_in) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to create saprop.\n");
 		delph2(iph2[n]);
 		return -1;
@@ -1852,8 +1629,8 @@
 
 	/* start isakmp initiation by using ident exchange */
 	/* XXX should be looped if there are multiple phase 2 handler. */
-	if (isakmp_post_acquire(iph2[n]) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+	if (ikev1_post_acquire(iph2[n]) < 0) {
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to begin ipsec sa negotication.\n");
 		goto err;
 	}
@@ -1870,7 +1647,9 @@
 	}
 	return -1;
 }
+#endif
 
+#ifdef notyet
 static int
 pk_recvdelete(mhp)
 	caddr_t *mhp;
@@ -1890,7 +1669,7 @@
 	 || mhp[SADB_EXT_SA] == NULL
 	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb acquire message passed.\n");
 		return -1;
 	}
@@ -1901,7 +1680,7 @@
 
 	/* the message has to be processed or not ? */
 	if (msg->sadb_msg_pid == getpid()) {
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"%s message is not interesting "
 			"because the message was originated by me.\n",
 			s_pfkey_type(msg->sadb_msg_type));
@@ -1910,7 +1689,7 @@
 
 	proto_id = pfkey2ipsecdoi_proto(msg->sadb_msg_satype);
 	if (proto_id == ~0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"invalid proto_id %d\n", msg->sadb_msg_satype);
 		return -1;
 	}
@@ -1918,14 +1697,14 @@
 	iph2 = getph2bysaidx(src, dst, proto_id, sa->sadb_sa_spi);
 	if (iph2 == NULL) {
 		/* ignore */
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"no iph2 found: %s\n",
 			sadbsecas2str(src, dst, msg->sadb_msg_satype,
 				sa->sadb_sa_spi, IPSEC_MODE_ANY));
 		return 0;
 	}
 
-	plog(LLV_ERROR, LOCATION, NULL,
+	plog(PLOG_INTERR, PLOGLOC, NULL,
 		"pfkey DELETE received: %s\n",
 		sadbsecas2str(iph2->src, iph2->dst,
 			msg->sadb_msg_satype, sa->sadb_sa_spi, IPSEC_MODE_ANY));
@@ -1940,7 +1719,9 @@
 
 	return 0;
 }
+#endif
 
+#ifdef notyet
 static int
 pk_recvflush(mhp)
 	caddr_t *mhp;
@@ -1951,7 +1732,7 @@
 
 	/* sanity check */
 	if (mhp[0] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb acquire message passed.\n");
 		return -1;
 	}
@@ -1960,7 +1741,9 @@
 
 	return 0;
 }
+#endif
 
+#ifdef notyet
 static int
 getsadbpolicy(policy0, policylen0, type, iph2)
 	caddr_t *policy0;
@@ -1993,7 +1776,7 @@
 	/* make policy structure */
 	policy = racoon_malloc(policylen);
 	if (!policy) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"buffer allocation failed.\n");
 		return -1;
 	}
@@ -2018,13 +1801,13 @@
 
 		satype = doi2ipproto(pr->proto_id);
 		if (satype == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"invalid proto_id %d\n", pr->proto_id);
 			goto err;
 		}
 		mode = ipsecdoi2pfkey_mode(pr->encmode);
 		if (mode == ~0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"invalid encmode %d\n", pr->encmode);
 			goto err;
 		}
@@ -2084,7 +1867,7 @@
 	vtime = 0;
 
 	if (getsadbpolicy(&policy, &policylen, SADB_X_SPDUPDATE, iph2)) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"getting sadb policy failed.\n");
 		return -1;
 	}
@@ -2098,12 +1881,12 @@
 			spidx->ul_proto,
 			ltime, vtime,
 			policy, policylen, 0) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"libipsec failed send spdupdate2 (%s)\n",
 			ipsec_strerror());
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_spdupdate2\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_spdupdate2\n");
 
 end:
 	if (policy)
@@ -2126,7 +1909,7 @@
 	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
 	 || mhp[SADB_X_EXT_POLICY] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spdupdate message passed.\n");
 		return -1;
 	}
@@ -2155,7 +1938,7 @@
 
 	sp = getsp(&spidx);
 	if (sp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"such policy does not already exist: \"%s\"\n",
 			spidx2str(&spidx));
 	} else {
@@ -2168,7 +1951,9 @@
 
 	return 0;
 }
+#endif
 
+#ifdef notyet
 /*
  * this function has to be used by responder side.
  */
@@ -2185,7 +1970,7 @@
 	vtime = 0;
 
 	if (getsadbpolicy(&policy, &policylen, SADB_X_SPDADD, iph2)) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"getting sadb policy failed.\n");
 		return -1;
 	}
@@ -2199,12 +1984,12 @@
 			spidx->ul_proto,
 			ltime, vtime,
 			policy, policylen, 0) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"libipsec failed send spdadd2 (%s)\n",
 			ipsec_strerror());
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_spdadd2\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_spdadd2\n");
 
 end:
 	if (policy)
@@ -2227,7 +2012,7 @@
 	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
 	 || mhp[SADB_X_EXT_POLICY] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spdadd message passed.\n");
 		return -1;
 	}
@@ -2256,7 +2041,7 @@
 
 	sp = getsp(&spidx);
 	if (sp != NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"such policy already exists. "
 			"anyway replace it: %s\n",
 			spidx2str(&spidx));
@@ -2282,7 +2067,7 @@
 	int policylen;
 
 	if (getsadbpolicy(&policy, &policylen, SADB_X_SPDDELETE, iph2)) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"getting sadb policy failed.\n");
 		return -1;
 	}
@@ -2295,12 +2080,12 @@
 			spidx->prefd,
 			spidx->ul_proto,
 			policy, policylen, 0) < 0) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"libipsec failed send spddelete (%s)\n",
 			ipsec_strerror());
 		goto end;
 	}
-	plog(LLV_DEBUG, LOCATION, NULL, "call pfkey_send_spddelete\n");
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "call pfkey_send_spddelete\n");
 
 end:
 	if (policy)
@@ -2323,7 +2108,7 @@
 	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
 	 || mhp[SADB_X_EXT_POLICY] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spddelete message passed.\n");
 		return -1;
 	}
@@ -2352,7 +2137,7 @@
 
 	sp = getsp(&spidx);
 	if (sp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"no policy found: %s\n",
 			spidx2str(&spidx));
 		return -1;
@@ -2378,7 +2163,7 @@
 	 || mhp[SADB_EXT_ADDRESS_SRC] == NULL
 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
 	 || mhp[SADB_X_EXT_POLICY] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spdexpire message passed.\n");
 		return -1;
 	}
@@ -2407,7 +2192,7 @@
 
 	sp = getsp(&spidx);
 	if (sp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"no policy found: %s\n",
 			spidx2str(&spidx));
 		return -1;
@@ -2425,7 +2210,7 @@
 {
 	/* sanity check */
 	if (mhp[0] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spdget message passed.\n");
 		return -1;
 	}
@@ -2445,7 +2230,7 @@
 
 	/* sanity check */
 	if (mhp[0] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spddump message passed.\n");
 		return -1;
 	}
@@ -2456,7 +2241,7 @@
 	xpl = (struct sadb_x_policy *)mhp[SADB_X_EXT_POLICY];
 
 	if (saddr == NULL || daddr == NULL || xpl == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spddump message passed.\n");
 		return -1;
 	}
@@ -2482,7 +2267,7 @@
 
 	sp = getsp(&spidx);
 	if (sp != NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"such policy already exists. "
 			"anyway replace it: %s\n",
 			spidx2str(&spidx));
@@ -2502,7 +2287,7 @@
 {
 	/* sanity check */
 	if (mhp[0] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spdflush message passed.\n");
 		return -1;
 	}
@@ -2511,6 +2296,7 @@
 
 	return 0;
 }
+#endif
 
 /*
  * send error against acquire message to kenrel.
@@ -2519,35 +2305,16 @@
 pk_sendeacquire(iph2)
 	struct ph2handle *iph2;
 {
-	struct sadb_msg *newmsg;
-	int len;
-
-	len = sizeof(struct sadb_msg);
-	newmsg = racoon_calloc(1, len);
-	if (newmsg == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
-			"failed to get buffer to send acquire.\n");
-		return -1;
-	}
-
-	memset(newmsg, 0, len);
-	newmsg->sadb_msg_version = PF_KEY_V2;
-	newmsg->sadb_msg_type = SADB_ACQUIRE;
-	newmsg->sadb_msg_errno = ENOENT;	/* XXX */
-	newmsg->sadb_msg_satype = iph2->satype;
-	newmsg->sadb_msg_len = PFKEY_UNIT64(len);
-	newmsg->sadb_msg_reserved = 0;
-	newmsg->sadb_msg_seq = iph2->seq;
-	newmsg->sadb_msg_pid = (u_int32_t)getpid();
-
-	/* send message */
-	len = pfkey_send(lcconf->sock_pfkey, newmsg, len);
-
-	racoon_free(newmsg);
+	struct rcpfk_msg	param;
 
+	param.seq = iph2->seq;
+	param.satype = iph2->satype;
+	param.eno = ENOENT;	/* ??? */
+	(void) iph2->sadb_request.method->acquire_error(&param);
 	return 0;
 }
 
+#ifdef notyet
 /*
  * check if the algorithm is supported or not.
  * OUT	 0: ok
@@ -2569,12 +2336,12 @@
 		sup = SADB_EXT_SUPPORTED_AUTH;
 		break;
 	case IPSECDOI_PROTO_IPCOMP:
-		plog(LLV_DEBUG, LOCATION, NULL,
+		plog(PLOG_DEBUG, PLOGLOC, NULL,
 			"compression algorithm can not be checked "
 			"because sadb message doesn't support it.\n");
 		return 0;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"invalid algorithm class.\n");
 		return -1;
 	}
@@ -2584,7 +2351,7 @@
 
 	if (keylen == 0) {
 		if (ipsec_get_keylen(sup, alg, &alg0)) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"%s.\n", ipsec_strerror());
 			return -1;
 		}
@@ -2593,12 +2360,14 @@
 
 	error = ipsec_check_keylen(sup, alg, keylen);
 	if (error)
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"%s.\n", ipsec_strerror());
 
 	return error;
 }
+#endif
 
+#ifdef notyet
 /*
  * differences with pfkey_recv() in libipsec/pfkey.c:
  * - never performs busy wait loop.
@@ -2644,14 +2413,16 @@
 
 	return newmsg;
 }
+#endif
 
 /* see handler.h */
 u_int32_t
 pk_getseq()
 {
-	return eay_random();
+	return eay_random_uint32();
 }
 
+#ifdef notyet
 static int
 addnewsp(mhp)
 	caddr_t *mhp;
@@ -2664,7 +2435,7 @@
 	if (mhp[SADB_EXT_ADDRESS_SRC] == NULL
 	 || mhp[SADB_EXT_ADDRESS_DST] == NULL
 	 || mhp[SADB_X_EXT_POLICY] == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"inappropriate sadb spd management message passed.\n");
 		return -1;
 	}
@@ -2683,7 +2454,7 @@
 
 	new = newsp();
 	if (new == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate buffer\n");
 		return -1;
 	}
@@ -2709,7 +2480,7 @@
 
 		/* validity check */
 		if (PFKEY_EXTLEN(xpl) < sizeof(*xpl)) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"invalid msg length.\n");
 			return -1;
 		}
@@ -2721,7 +2492,7 @@
 
 			/* length check */
 			if (xisr->sadb_x_ipsecrequest_len < sizeof(*xisr)) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"invalid msg length.\n");
 				return -1;
 			}
@@ -2729,7 +2500,7 @@
 			/* allocate request buffer */
 			*p_isr = newipsecreq();
 			if (*p_isr == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to get new ipsecreq.\n");
 				return -1;
 			}
@@ -2743,7 +2514,7 @@
 			case IPPROTO_IPCOMP:
 				break;
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"invalid proto type: %u\n",
 					xisr->sadb_x_ipsecrequest_proto);
 				return -1;
@@ -2756,7 +2527,7 @@
 				break;
 			case IPSEC_MODE_ANY:
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"invalid mode: %u\n",
 					xisr->sadb_x_ipsecrequest_mode);
 				return -1;
@@ -2774,7 +2545,7 @@
 				break;
 
 			default:
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"invalid level: %u\n",
 					xisr->sadb_x_ipsecrequest_level);
 				return -1;
@@ -2803,7 +2574,7 @@
 
 			/* validity check */
 			if (tlen < 0) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"becoming tlen < 0\n");
 			}
 
@@ -2813,7 +2584,7 @@
 	    }
 		break;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"invalid policy type.\n");
 		return -1;
 	}
@@ -2841,6 +2612,7 @@
 
 	return 0;
 }
+#endif
 
 /* proto/mode/src->dst spi */
 const char *
@@ -2855,11 +2627,11 @@
 	char *p;
 	int blen, i;
 
-	doi_proto = pfkey2ipsecdoi_proto(proto);
+	doi_proto = rc2ipsecdoi_proto(proto);
 	if (doi_proto == ~0)
 		return NULL;
 	if (mode) {
-		doi_mode = pfkey2ipsecdoi_mode(mode);
+		doi_mode = rc2ipsecdoi_mode(mode);
 		if (doi_mode == ~0)
 			return NULL;
 	}
@@ -2876,13 +2648,13 @@
 	p += i;
 	blen -= i;
 
-	i = snprintf(p, blen, "%s->", saddr2str(src));
+	i = snprintf(p, blen, "%s->", rcs_sa2str(src));
 	if (i < 0 || i >= blen)
 		return NULL;
 	p += i;
 	blen -= i;
 
-	i = snprintf(p, blen, "%s ", saddr2str(dst));
+	i = snprintf(p, blen, "%s ", rcs_sa2str(dst));
 	if (i < 0 || i >= blen)
 		return NULL;
 	p += i;
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: plainrsa-gen.8
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: plainrsa-gen.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: plog.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: plog.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: policy.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: policy.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: privsep.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: privsep.h
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/proposal.c ./proposal.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/proposal.c	Sat Jul 16 18:56:40 2005
+++ ./proposal.c	Tue Jan 31 21:49:43 2006
@@ -49,21 +49,22 @@
 #include <errno.h>
 
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 #include "sockmisc.h"
 #include "debug.h"
 
-#include "policy.h"
-#include "pfkey.h"
-#include "isakmp_var.h"
+/* #include "policy.h" */
+/* #include "pfkey.h" */
 #include "isakmp.h"
+#include "isakmp_impl.h"
+#include "isakmp_var.h"
 #include "ipsec_doi.h"
 #include "algorithm.h"
 #include "proposal.h"
 #include "sainfo.h"
-#include "localconf.h"
+/* #include "localconf.h" */
 #include "remoteconf.h"
 #include "oakley.h"
 #include "handler.h"
@@ -73,6 +74,8 @@
 #include "nattraversal.h"
 #endif
 
+#include "racoon.h"
+
 /* %%%
  * modules for ipsec sa spec
  */
@@ -205,7 +208,7 @@
 
 	newpp = newsaprop();
 	if (newpp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate saprop.\n");
 		return NULL;
 	}
@@ -214,23 +217,23 @@
 	/* see proposal.h about lifetime/key length and PFS selection. */
 
 	/* check time/bytes lifetime and PFS */
-	switch (ph1->rmconf->pcheck_level) {
-	case PROP_CHECK_OBEY:
+	switch (ikev1_proposal_check(ph1->rmconf)) {
+	case RCT_PCT_OBEY:
 		newpp->lifetime = pp1->lifetime;
 		newpp->lifebyte = pp1->lifebyte;
 		newpp->pfs_group = pp1->pfs_group;
 		break;
 
-	case PROP_CHECK_STRICT:
+	case RCT_PCT_STRICT:
 		if (pp1->lifetime > pp2->lifetime) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"long lifetime proposed: "
 				"my:%d peer:%d\n",
 				(int)pp2->lifetime, (int)pp1->lifetime);
 			goto err;
 		}
 		if (pp1->lifebyte > pp2->lifebyte) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"long lifebyte proposed: "
 				"my:%d peer:%d\n",
 				pp2->lifebyte, pp1->lifebyte);
@@ -241,7 +244,7 @@
 
     prop_pfs_check:
 		if (pp2->pfs_group != 0 && pp1->pfs_group != pp2->pfs_group) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"pfs group mismatched: "
 				"my:%d peer:%d\n",
 				pp2->pfs_group, pp1->pfs_group);
@@ -250,14 +253,14 @@
 		newpp->pfs_group = pp1->pfs_group;
 		break;
 
-	case PROP_CHECK_CLAIM:
+	case RCT_PCT_CLAIM:
 		/* lifetime */
 		if (pp1->lifetime <= pp2->lifetime) {
 			newpp->lifetime = pp1->lifetime;
 		} else {
 			newpp->lifetime = pp2->lifetime;
 			newpp->claim |= IPSECDOI_ATTR_SA_LD_TYPE_SEC;
-			plog(LLV_NOTIFY, LOCATION, NULL,
+			plog(PLOG_INFO, PLOGLOC, NULL,
 				"use own lifetime: "
 				"my:%d peer:%d\n",
 				(int)pp2->lifetime, (int)pp1->lifetime);
@@ -267,7 +270,7 @@
 		if (pp1->lifebyte > pp2->lifebyte) {
 			newpp->lifebyte = pp2->lifebyte;
 			newpp->claim |= IPSECDOI_ATTR_SA_LD_TYPE_SEC;
-			plog(LLV_NOTIFY, LOCATION, NULL,
+			plog(PLOG_INFO, PLOGLOC, NULL,
 				"use own lifebyte: "
 				"my:%d peer:%d\n",
 				pp2->lifebyte, pp1->lifebyte);
@@ -277,9 +280,9 @@
     		goto prop_pfs_check;
 		break;
 
-	case PROP_CHECK_EXACT:
+	case RCT_PCT_EXACT:
 		if (pp1->lifetime != pp2->lifetime) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"lifetime mismatched: "
 				"my:%d peer:%d\n",
 				(int)pp2->lifetime, (int)pp1->lifetime);
@@ -287,14 +290,14 @@
 		}
 
 		if (pp1->lifebyte != pp2->lifebyte) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"lifebyte mismatched: "
 				"my:%d peer:%d\n",
 				pp2->lifebyte, pp1->lifebyte);
 			goto err;
 		}
 		if (pp1->pfs_group != pp2->pfs_group) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"pfs group mismatched: "
 				"my:%d peer:%d\n",
 				pp2->pfs_group, pp1->pfs_group);
@@ -306,7 +309,7 @@
 		break;
 
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"invalid pcheck_level why?.\n");
 		goto err;
 	}
@@ -352,7 +355,7 @@
 			break;
 
 		if (pr1->proto_id != pr2->proto_id) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"proto_id mismatched: "
 				"my:%s peer:%s\n",
 				s_ipsecdoi_proto(pr2->proto_id),
@@ -375,13 +378,13 @@
 				spisizematch = 1;
 			}
 			if (spisizematch) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				    "IPComp SPI size promoted "
 				    "from 16bit to 32bit\n");
 			}
 		}
 		if (!spisizematch) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"spisize mismatched: "
 				"my:%d peer:%d\n",
 				(int)pr2->spisize, (int)pr1->spisize);
@@ -392,7 +395,7 @@
 		if ((ph1->natt_flags & NAT_DETECTED) && 
 		    natt_udp_encap (pr2->encmode))
 		{
-			plog(LLV_INFO, LOCATION, NULL, "Adjusting my encmode %s->%s\n",
+			plog(PLOG_INFO, PLOGLOC, NULL, "Adjusting my encmode %s->%s\n",
 			     s_ipsecdoi_encmode(pr2->encmode),
 			     s_ipsecdoi_encmode(pr2->encmode - ph1->natt_options->mode_udp_diff));
 			pr2->encmode -= ph1->natt_options->mode_udp_diff;
@@ -402,7 +405,7 @@
 		if ((ph1->natt_flags & NAT_DETECTED) &&
 		    natt_udp_encap (pr1->encmode))
 		{
-			plog(LLV_INFO, LOCATION, NULL, "Adjusting peer's encmode %s(%d)->%s(%d)\n",
+			plog(PLOG_INFO, PLOGLOC, NULL, "Adjusting peer's encmode %s(%d)->%s(%d)\n",
 			     s_ipsecdoi_encmode(pr1->encmode),
 			     pr1->encmode,
 			     s_ipsecdoi_encmode(pr1->encmode - ph1->natt_options->mode_udp_diff),
@@ -413,7 +416,7 @@
 #endif
 
 		if (pr1->encmode != pr2->encmode) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"encmode mismatched: "
 				"my:%s peer:%s\n",
 				s_ipsecdoi_encmode(pr2->encmode),
@@ -433,7 +436,7 @@
 	    found:
 		newpr = newsaproto();
 		if (newpr == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to allocate saproto.\n");
 			goto err;
 		}
@@ -450,7 +453,7 @@
 
 		newtr = newsatrns();
 		if (newtr == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to allocate satrns.\n");
 			goto err;
 		}
@@ -497,20 +500,20 @@
 	const struct saprop *pp1, *pp2;
 {
 	if (pp1->pfs_group != pp2->pfs_group) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"pfs_group mismatch. mine:%d peer:%d\n",
 			pp1->pfs_group, pp2->pfs_group);
 		/* FALLTHRU */
 	}
 
 	if (pp1->lifetime > pp2->lifetime) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"less lifetime proposed. mine:%d peer:%d\n",
 			(int)pp1->lifetime, (int)pp2->lifetime);
 		/* FALLTHRU */
 	}
 	if (pp1->lifebyte > pp2->lifebyte) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"less lifebyte proposed. mine:%d peer:%d\n",
 			pp1->lifebyte, pp2->lifebyte);
 		/* FALLTHRU */
@@ -530,7 +533,7 @@
 	const struct satrns *tr1, *tr2;
 {
 	if (tr1->trns_id != tr2->trns_id) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"trns_id mismatched: "
 			"my:%s peer:%s\n",
 			s_ipsecdoi_trns(proto_id, tr2->trns_id),
@@ -539,7 +542,7 @@
 	}
 
 	if (tr1->authtype != tr2->authtype) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"authtype mismatched: "
 			"my:%s peer:%s\n",
 			s_ipsecdoi_attr_v(IPSECDOI_ATTR_AUTH, tr2->authtype),
@@ -552,7 +555,7 @@
 	 * the initiator.  It should be defined a notify message.
 	 */
 	if (tr1->encklen > tr2->encklen) {
-		plog(LLV_WARNING, LOCATION, NULL,
+		plog(PLOG_PROTOWARN, PLOGLOC, NULL,
 			"less key length proposed, "
 			"mine:%d peer:%d.  Use initiaotr's one.\n",
 			tr2->encklen, tr1->encklen);
@@ -574,7 +577,7 @@
 	switch (pr->proto_id) {
 	case IPSECDOI_PROTO_IPSEC_AH:
 		if (sainfo->algs[algclass_ipsec_auth] == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"no auth algorithm found\n");
 			goto err;
 		}
@@ -587,7 +590,7 @@
 			/* allocate satrns */
 			newtr = newsatrns();
 			if (newtr == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to allocate satrns.\n");
 				goto err;
 			}
@@ -601,7 +604,7 @@
 		break;
 	case IPSECDOI_PROTO_IPSEC_ESP:
 		if (sainfo->algs[algclass_ipsec_enc] == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"no encryption algorithm found\n");
 			goto err;
 		}
@@ -611,7 +614,7 @@
 				/* allocate satrns */
 				newtr = newsatrns();
 				if (newtr == NULL) {
-					plog(LLV_ERROR, LOCATION, NULL,
+					plog(PLOG_INTERR, PLOGLOC, NULL,
 						"failed to allocate satrns.\n");
 					goto err;
 				}
@@ -627,7 +630,7 @@
 		break;
 	case IPSECDOI_PROTO_IPCOMP:
 		if (sainfo->algs[algclass_ipsec_comp] == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"no ipcomp algorithm found\n");
 			goto err;
 		}
@@ -637,7 +640,7 @@
 			/* allocate satrns */
 			newtr = newsatrns();
 			if (newtr == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to allocate satrns.\n");
 				goto err;
 			}
@@ -650,14 +653,14 @@
 		}
 		break;
 	default:
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 			"unknown proto_id (%d).\n", pr->proto_id);
 		goto err;
 	}
 
 	/* no proposal found */
 	if (pr->head == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL, "no algorithms found.\n");
+		plog(PLOG_PROTOERR, PLOGLOC, NULL, "no algorithms found.\n");
 		return -1;
 	}
 
@@ -684,7 +687,7 @@
 	/* allocate ipsec a sa proposal */
 	newpp = newsaprop();
 	if (newpp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate saprop.\n");
 		return NULL;
 	}
@@ -696,7 +699,7 @@
 		/* allocate ipsec sa protocol */
 		newpr = newsaproto();
 		if (newpr == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to allocate saproto.\n");
 			goto err;
 		}
@@ -704,7 +707,7 @@
 		/* check spi size */
 		/* XXX should be handled isakmp cookie */
 		if (sizeof(newpr->spi) < p->prop->spi_size) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"invalid spi size %d.\n", p->prop->spi_size);
 			goto err;
 		}
@@ -725,7 +728,7 @@
 
 		for (t = p; t; t = t->tnext) {
 
-			plog(LLV_DEBUG, LOCATION, NULL,
+			plog(PLOG_DEBUG, PLOGLOC, NULL,
 				"prop#=%d prot-id=%s spi-size=%d "
 				"#trns=%d trns#=%d trns-id=%s\n",
 				t->prop->p_no,
@@ -738,7 +741,7 @@
 			/* allocate ipsec sa transform */
 			newtr = newsatrns();
 			if (newtr == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"failed to allocate satrns.\n");
 				goto err;
 			}
@@ -828,7 +831,7 @@
 	const struct saprop *p;
 
 	if (pp == NULL) {
-		plog(pri, LOCATION, NULL, "(null)");
+		plog(pri, PLOGLOC, NULL, "(null)");
 		return;
 	}
 
@@ -869,7 +872,7 @@
 	if (pr == NULL)
 		return;
 
-	plog(pri, LOCATION, NULL,
+	plog(pri, PLOGLOC, NULL,
 		" (proto_id=%s spisize=%d spi=%08lx spi_p=%08lx "
 		"encmode=%s reqid=%d:%d)\n",
 		s_ipsecdoi_proto(pr->proto_id),
@@ -897,25 +900,25 @@
 
 	switch (proto_id) {
 	case IPSECDOI_PROTO_IPSEC_AH:
-		plog(pri, LOCATION, NULL,
+		plog(pri, PLOGLOC, NULL,
 			"  (trns_id=%s authtype=%s)\n",
 			s_ipsecdoi_trns(proto_id, tr->trns_id),
 			s_ipsecdoi_attr_v(IPSECDOI_ATTR_AUTH, tr->authtype));
 		break;
 	case IPSECDOI_PROTO_IPSEC_ESP:
-		plog(pri, LOCATION, NULL,
+		plog(pri, PLOGLOC, NULL,
 			"  (trns_id=%s encklen=%d authtype=%s)\n",
 			s_ipsecdoi_trns(proto_id, tr->trns_id),
 			tr->encklen,
 			s_ipsecdoi_attr_v(IPSECDOI_ATTR_AUTH, tr->authtype));
 		break;
 	case IPSECDOI_PROTO_IPCOMP:
-		plog(pri, LOCATION, NULL,
+		plog(pri, PLOGLOC, NULL,
 			"  (trns_id=%s)\n",
 			s_ipsecdoi_trns(proto_id, tr->trns_id));
 		break;
 	default:
-		plog(pri, LOCATION, NULL,
+		plog(pri, PLOGLOC, NULL,
 			"(unknown proto_id %d)\n", proto_id);
 	}
 
@@ -936,7 +939,7 @@
 		spc[level] = '\0';
 	}
 
-	plog(pri, LOCATION, NULL,
+	plog(pri, PLOGLOC, NULL,
 		"%s%p: next=%p tnext=%p\n", spc, p, p->next, p->tnext);
 	if (p->next)
 		print_proppair0(pri, p->next, level + 1);
@@ -952,6 +955,97 @@
 	print_proppair0(pri, p, 1);
 }
 
+
+static int
+proto(struct rcf_sa *sa, int proto, int encmode, struct ph2handle *iph2, u_int32_t reqid, struct saprop *pp)
+{
+	struct saproto *newpr;
+
+	if (!sa)
+		return 0;
+
+	newpr = newsaproto();
+	if (!newpr) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "failed to allocate saproto\n");
+		return -1;
+	}
+	newpr->proto_id = proto;
+	if (proto == IPSECDOI_PROTO_IPCOMP) {
+		newpr->spisize = sizeof(u_int16_t);
+	} else {
+		newpr->spisize = sizeof(u_int32_t);
+	}
+	newpr->encmode = encmode;
+
+	if (iph2->side == INITIATOR)
+		newpr->reqid_out = reqid;
+	else
+		newpr->reqid_in = reqid;
+
+	if (set_satrnsbysainfo(newpr, iph2->sainfo) < 0) {
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "failed to get algorithms\n");
+		return -1;
+	}
+
+	inssaprotorev(pp, newpr);
+	return 0;
+}
+
+
+int
+set_proposal_from_policy(struct ph2handle *iph2, struct rcf_policy *p1, struct rcf_policy *p2)
+{
+	struct saprop *newpp;
+	int encmode;
+	struct rcf_ipsec *ips;
+
+	newpp = newsaprop();
+	if (! newpp) {
+		plog(PLOG_INTERR, PLOGLOC, NULL,
+			"failed to allocate saprop.\n");
+		goto err;
+	}
+	newpp->prop_no = 1;
+	newpp->lifetime = iph2->sainfo->lifetime;
+	newpp->lifebyte = iph2->sainfo->lifebyte;
+	newpp->pfs_group = iph2->sainfo->pfs_group;
+
+	switch (p1->ipsec_mode) {
+	case RCT_IPSM_TRANSPORT:
+		encmode = IPSECDOI_ATTR_ENC_MODE_TRNS;
+		break;
+	case RCT_IPSM_TUNNEL:
+		encmode = IPSECDOI_ATTR_ENC_MODE_TUNNEL;
+		break;
+	default:
+		plog(PLOG_INTERR, PLOGLOC, 0,
+		     "unexpected mode: %d\n", p1->ipsec_mode);
+		goto err;
+	}
+
+	for (ips = p1->ips; ips; ips = ips->next) {
+		u_int32_t reqid = 0; /* ??? */
+
+		if (proto(ips->sa_ah, IPSECDOI_PROTO_IPSEC_AH, encmode, iph2, reqid, newpp))
+			goto err;
+		if (proto(ips->sa_esp, IPSECDOI_PROTO_IPSEC_ESP, encmode, iph2, reqid, newpp))
+			goto err;
+		if (proto(ips->sa_ipcomp, IPSECDOI_PROTO_IPCOMP, encmode, iph2, reqid, newpp))
+			goto err;
+	}
+
+	iph2->proposal = newpp;
+	//prinsaprop0(PLOG_DEBUG, newpp);
+	return 0;
+
+ err:
+	return -1;
+}
+
+
+#if 0
 int
 set_proposal_from_policy(iph2, sp_main, sp_sub)
 	struct ph2handle *iph2;
@@ -959,11 +1053,11 @@
 {
 	struct saprop *newpp;
 	struct ipsecrequest *req;
-	int encmodesv = IPSEC_MODE_TRANSPORT; /* use only when complex_bundle */
+	int encmodesv = IPSECDOI_ATTR_ENC_MODE_TRNS /*IPSEC_MODE_TRANSPORT*/; /* use only when complex_bundle */
 
 	newpp = newsaprop();
 	if (newpp == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_INTERR, PLOGLOC, NULL,
 			"failed to allocate saprop.\n");
 		goto err;
 	}
@@ -1019,7 +1113,7 @@
 		/* allocate ipsec sa protocol */
 		newpr = newsaproto();
 		if (newpr == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to allocate saproto.\n");
 			goto err;
 		}
@@ -1045,7 +1139,7 @@
 			newpr->reqid_in = req->saidx.reqid;
 
 		if (set_satrnsbysainfo(newpr, iph2->sainfo) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"failed to get algorithms.\n");
 			goto err;
 		}
@@ -1069,7 +1163,7 @@
 			req = req->next;
 		}
 		if (pr || req) {
-			plog(LLV_NOTIFY, LOCATION, NULL,
+			plog(PLOG_INFO, PLOGLOC, NULL,
 				"There is a difference "
 				"between the in/out bound policies in SPD.\n");
 		}
@@ -1077,12 +1171,13 @@
 
 	iph2->proposal = newpp;
 
-	printsaprop0(LLV_DEBUG, newpp);
+	printsaprop0(PLOG_DEBUG, newpp);
 
 	return 0;
 err:
 	return -1;
 }
+#endif
 
 /*
  * generate a policy from peer's proposal.
@@ -1117,7 +1212,7 @@
 
 		pp0 = newsaprop();
 		if (pp0 == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to allocate saprop.\n");
 			goto end;
 		}
@@ -1127,7 +1222,7 @@
 		pp0->pfs_group = iph2->sainfo->pfs_group;
 
 		if (pp_peer->next != NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_PROTOERR, PLOGLOC, NULL,
 				"pp_peer is inconsistency, ignore it.\n");
 			/*FALLTHROUGH*/
 		}
@@ -1136,7 +1231,7 @@
 
 			newpr = newsaproto();
 			if (newpr == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 				    "failed to allocate saproto.\n");
 				goto end;
 			}
@@ -1150,7 +1245,7 @@
 		}
 
 		if (set_satrnsbysainfo(newpr, iph2->sainfo) < 0) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 				"failed to get algorithms.\n");
 			goto end;
 		}
@@ -1159,8 +1254,8 @@
 		inssaprop(&newpp, pp0);
 	}
 
-	plog(LLV_DEBUG, LOCATION, NULL, "make a proposal from peer's:\n");
-	printsaprop0(LLV_DEBUG, newpp);  
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "make a proposal from peer's:\n");
+	printsaprop0(PLOG_DEBUG, newpp);  
 
 	iph2->proposal = newpp;
 
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: proposal.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: prsa_par.y
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: prsa_tok.l
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: racoon.8
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: racoon.conf.5
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: racoonctl.8
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: racoonctl.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: racoonctl.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: remoteconf.c
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/remoteconf.h ./remoteconf.h
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/remoteconf.h	Tue May  3 07:44:35 2005
+++ ./remoteconf.h	Fri Jan 13 16:30:55 2006
@@ -54,6 +54,7 @@
 #define SCRIPT_MAX		1
 extern char *script_names[SCRIPT_MAX + 1];
 
+#if 0
 struct remoteconf {
 	struct sockaddr *remote;	/* remote IP address */
 					/* if family is AF_UNSPEC, that is
@@ -108,7 +109,7 @@
 	int weak_phase1_check;		/* act on unencrypted deletions ? */
 
 	struct isakmpsa *proposal;	/* proposal list */
-	struct remoteconf *inherited_from;	/* the original rmconf 
+	struct rcf_remote *inherited_from;	/* the original rmconf 
 						   from which this one 
 						   was inherited */
 	struct proposalspec *prhead;
@@ -122,6 +123,7 @@
 
 	TAILQ_ENTRY(remoteconf) chain;	/* next remote conf */
 };
+#endif
 
 struct dhgroup;
 
@@ -143,7 +145,7 @@
 	struct dhgroup *dhgrp;		/* don't use it if aggressive mode */
 
 	struct isakmpsa *next;		/* next transform */
-	struct remoteconf *rmconf;	/* backpointer to remoteconf */
+	struct rcf_remote *rmconf;	/* backpointer to remoteconf */
 };
 
 struct idspec {
@@ -151,34 +153,34 @@
 	vchar_t *id;                    /* identifier */
 };
 
-typedef struct remoteconf * (rmconf_func_t)(struct remoteconf *rmconf, void *data);
+typedef struct rcf_remote * (rmconf_func_t)(struct rcf_remote *rmconf, void *data);
 
-extern struct remoteconf *getrmconf __P((struct sockaddr *));
-extern struct remoteconf *getrmconf_strict
+extern struct rcf_remote *getrmconf __P((struct sockaddr *));
+extern struct rcf_remote *getrmconf_strict
 	__P((struct sockaddr *remote, int allow_anon));
-extern struct remoteconf *copyrmconf __P((struct sockaddr *));
-extern struct remoteconf *newrmconf __P((void));
-extern struct remoteconf *duprmconf __P((struct remoteconf *));
-extern void delrmconf __P((struct remoteconf *));
+extern struct rcf_remote *copyrmconf __P((struct sockaddr *));
+extern struct rcf_remote *newrmconf __P((void));
+extern struct rcf_remote *duprmconf __P((struct rcf_remote *));
+extern void delrmconf __P((struct rcf_remote *));
 extern void delisakmpsa __P((struct isakmpsa *));
 extern void deletypes __P((struct etypes *));
 extern struct etypes * dupetypes __P((struct etypes *));
-extern void insrmconf __P((struct remoteconf *));
-extern void remrmconf __P((struct remoteconf *));
+extern void insrmconf __P((struct rcf_remote *));
+extern void remrmconf __P((struct rcf_remote *));
 extern void flushrmconf __P((void));
 extern void initrmconf __P((void));
 extern void save_rmconf __P((void));
 extern void save_rmconf_flush __P((void));
 
 extern struct etypes *check_etypeok
-	__P((struct remoteconf *, u_int8_t));
-extern struct remoteconf *foreachrmconf __P((rmconf_func_t rmconf_func,
+	__P((struct rcf_remote *, u_int8_t));
+extern struct rcf_remote *foreachrmconf __P((rmconf_func_t rmconf_func,
 					     void *data));
 
 extern struct isakmpsa *newisakmpsa __P((void));
 extern struct isakmpsa *dupisakmpsa __P((struct isakmpsa *));
 
-extern void insisakmpsa __P((struct isakmpsa *, struct remoteconf *));
+extern void insisakmpsa __P((struct isakmpsa *, struct rcf_remote *));
 
 extern void dumprmconf __P((void));
 
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: rfc
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: rsalist.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: rsalist.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: safefile.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: safefile.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: sainfo.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: samples
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: schedule.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: schedule.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: session.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: session.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: sockmisc.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: sockmisc.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: stats.pl
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: str2val.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: str2val.h
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/strnames.c ./strnames.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/strnames.c	Mon Jun 20 03:02:54 2005
+++ ./strnames.c	Thu Feb  2 16:32:54 2006
@@ -35,13 +35,17 @@
 #include <sys/param.h>
 #include <sys/socket.h>
 
-#include <netinet/in.h> 
+#include <netinet/in.h>
+#ifdef HAVE_NET_PFKEYV2_H
+#  include <net/pfkeyv2.h>
+#endif
+#if 0
 #ifdef HAVE_NETINET6_IPSEC
 #  include <netinet6/ipsec.h>
 #else 
 #  include <netinet/ipsec.h>
 #endif
-#include <netinet/in.h>
+#endif
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -49,13 +53,15 @@
 #include <resolv.h>
 #endif
 
+#include "racoon.h"
+
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 
-#include "isakmp_var.h"
 #include "isakmp.h"
+#include "isakmp_var.h"
 #ifdef ENABLE_HYBRID
 #  include "isakmp_xauth.h"
 #  include "isakmp_unity.h"
@@ -64,7 +70,7 @@
 #include "ipsec_doi.h"
 #include "oakley.h"
 #include "handler.h"
-#include "pfkey.h"
+/* #include "pfkey.h" */
 #include "strnames.h"
 #include "algorithm.h"
 
@@ -690,9 +696,11 @@
 { OAKLEY_ATTR_HASH_ALG_MD5,	"MD5",		NULL },
 { OAKLEY_ATTR_HASH_ALG_SHA,	"SHA",		NULL },
 { OAKLEY_ATTR_HASH_ALG_TIGER,	"Tiger",	NULL },
+#ifdef WITH_SHA2
 { OAKLEY_ATTR_HASH_ALG_SHA2_256,"SHA256",	NULL },
 { OAKLEY_ATTR_HASH_ALG_SHA2_384,"SHA384",	NULL },
 { OAKLEY_ATTR_HASH_ALG_SHA2_512,"SHA512",	NULL },
+#endif
 };
 
 char *
@@ -809,6 +817,7 @@
 	return num2str(val);
 }
 
+#if 0
 /* netinet6/ipsec.h */
 static struct ksmap name_ipsec_level[] = {
 { IPSEC_LEVEL_USE,	"use",		NULL },
@@ -826,6 +835,7 @@
 			return name_ipsec_level[i].str;
 	return num2str(k);
 }
+#endif
 
 static struct ksmap name_algclass[] = {
 { algclass_ipsec_enc,	"ipsec enc",	s_ipsecdoi_trns_esp },
@@ -922,6 +932,7 @@
 	return num2str(k);
 }
 
+#if 0
 static struct ksmap name_direction[] = {
 { IPSEC_DIR_INBOUND,	"in",	NULL },
 { IPSEC_DIR_OUTBOUND,	"out",	NULL },
@@ -940,6 +951,7 @@
 			return name_direction[i].str;
 	return num2str(k);
 }
+#endif
 
 char *
 s_proto(k)
@@ -954,7 +966,7 @@
 		return "udp";
 	case IPPROTO_ICMPV6:
 		return "icmpv6";
-	case IPSEC_ULPROTO_ANY:
+	case RC_PROTO_ANY:
 		return "any";
 	}
 
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: throttle.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: throttle.h
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: var.h
diff -u -r /home/fukumoto/tmp/ipsec-tools/src/racoon/vendorid.c ./vendorid.c
--- /home/fukumoto/tmp/ipsec-tools/src/racoon/vendorid.c	Thu Apr  7 08:07:55 2005
+++ ./vendorid.c	Thu Feb  2 17:10:11 2006
@@ -39,18 +39,19 @@
 #include <string.h>
 #include <errno.h>
 #include <ctype.h>
+#include <netinet/in.h>
 
 #include "var.h"
-#include "misc.h"
+/* #include "misc.h" */
 #include "vmbuf.h"
 #include "plog.h"
 #include "debug.h"
 
-#include "localconf.h"
-#include "isakmp_var.h"
+/* #include "localconf.h" */
 #include "isakmp.h"
+#include "isakmp_var.h"
 #include "vendorid.h"
-#include "crypto_openssl.h"
+#include "crypto_impl.h"
 
 static struct vendor_id all_vendor_ids[] = {
 { VENDORID_KAME       , "KAME/racoon" },
@@ -119,7 +120,6 @@
 lookup_vendor_id_by_hash (const char *hash)
 {
 	int i;
-	unsigned char *h = (unsigned char *)hash;
 
 	for (i = 0; i < NUMVENDORIDS; i++)
 		if (strncmp(all_vendor_ids[i].hash->v, hash,
@@ -140,7 +140,7 @@
 		if(i == VENDORID_DPD){
 			all_vendor_ids[i].hash = vmalloc(sizeof(vendorid_dpd_hash));
 			if (all_vendor_ids[i].hash == NULL) {
-				plog(LLV_ERROR, LOCATION, NULL,
+				plog(PLOG_INTERR, PLOGLOC, NULL,
 					"unable to get memory for VID hash\n");
 				exit(1); /* this really shouldn't happen */
 			}
@@ -154,7 +154,7 @@
 
 		all_vendor_ids[i].hash = eay_md5_one(&vid);
 		if (all_vendor_ids[i].hash == NULL)
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 			    "unable to hash vendor ID string\n");
 
 		/* Special cases */
@@ -172,7 +172,6 @@
 set_vendorid(int vendorid)
 {
 	struct vendor_id *current;
-	vchar_t vid, *new;
 
 	if (vendorid == VENDORID_UNKNOWN) {
 		/*
@@ -184,7 +183,7 @@
 
 	current = lookup_vendor_id_by_id(vendorid);
 	if (current == NULL) {
-		plog(LLV_ERROR, LOCATION, NULL,
+		plog(PLOG_PROTOERR, PLOGLOC, NULL,
 		    "invalid vendor ID index: %d\n", vendorid);
 		return (NULL);
 	}
@@ -204,8 +203,7 @@
 int
 check_vendorid(struct isakmp_gen *gen)
 {
-	vchar_t vid, *vidhash;
-	int i, vidlen;
+	int vidlen;
 	struct vendor_id *current;
 
 	if (gen == NULL)
@@ -218,19 +216,19 @@
 		goto unknown;
 	
 	if (current->hash->l < vidlen)
-		plog(LLV_INFO, LOCATION, NULL,
+		plog(PLOG_INFO, PLOGLOC, NULL,
 		     "received broken Microsoft ID: %s\n",
 		     current->string);
 	else
-		plog(LLV_INFO, LOCATION, NULL,
+		plog(PLOG_INFO, PLOGLOC, NULL,
 		     "received Vendor ID: %s\n",
 		     current->string);
 
 	return current->id;
 
 unknown:
-	plog(LLV_DEBUG, LOCATION, NULL, "received unknown Vendor ID\n");
-	plogdump(LLV_DEBUG, (char *)(gen + 1), vidlen);
+	plog(PLOG_DEBUG, PLOGLOC, NULL, "received unknown Vendor ID\n");
+	plogdump(PLOG_DEBUG, PLOGLOC, 0, (char *)(gen + 1), vidlen);
 	return (VENDORID_UNKNOWN);
 }
 
@@ -244,7 +242,7 @@
 		vchar_t *tmp;					    
 				  
 		if ((tmp = vmalloc(8)) == NULL) {
-			plog(LLV_ERROR, LOCATION, NULL,
+			plog(PLOG_INTERR, PLOGLOC, NULL,
 			    "unable to hash vendor ID string\n");
 			return NULL;				    
 		}			
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: vmbuf.c
Only in /home/fukumoto/tmp/ipsec-tools/src/racoon/: vmbuf.h
